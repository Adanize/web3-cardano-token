{"version":3,"sources":["webpack://web3-cardano-token/./node_modules/node-libs-browser/mock/process.js","webpack://web3-cardano-token/./node_modules/core-js/modules/es.typed-array.float64-array.js","webpack://web3-cardano-token/./temporary_modules/@emurgo/cardano-message-signing-nodejs sync","webpack://web3-cardano-token/./node_modules/@babel/runtime/helpers/taggedTemplateLiteral.js","webpack://web3-cardano-token/./temporary_modules/@emurgo/cardano-message-signing-nodejs/emurgo_message_signing.js","webpack://web3-cardano-token/./node_modules/@babel/runtime/helpers/createClass.js","webpack://web3-cardano-token/./node_modules/@babel/runtime/helpers/typeof.js","webpack://web3-cardano-token/./node_modules/@babel/runtime/helpers/classCallCheck.js","webpack://web3-cardano-token/./node_modules/core-js/modules/es.string.raw.js","webpack://web3-cardano-token/./node_modules/path-browserify/index.js"],"names":["exports","nextTick","fn","args","Array","prototype","slice","call","arguments","shift","setTimeout","apply","platform","arch","execPath","title","pid","browser","env","argv","binding","name","Error","path","cwd","chdir","dir","resolve","exit","kill","umask","dlopen","uptime","memoryUsage","uvCounters","features","createTypedArrayConstructor","init","data","byteOffset","length","this","webpackEmptyContext","req","e","code","keys","module","id","_taggedTemplateLiteral","strings","raw","Object","freeze","defineProperties","value","__esModule","wasm","imports","require","String","TextDecoder","TextEncoder","heap","fill","undefined","getObject","idx","push","heap_next","dropObject","takeObject","ret","cachedTextDecoder","ignoreBOM","fatal","decode","cachegetUint8Memory0","getUint8Memory0","buffer","memory","Uint8Array","getStringFromWasm0","ptr","len","subarray","addHeapObject","obj","debugString","val","type","description","isArray","debug","i","className","builtInMatches","exec","toString","JSON","stringify","_","message","stack","WASM_VECTOR_LEN","cachedTextEncoder","encodeString","encodeInto","arg","view","buf","encode","set","read","written","passStringToWasm0","malloc","realloc","mem","offset","charCodeAt","cachegetInt32Memory0","getInt32Memory0","Int32Array","getArrayU8FromWasm0","passArray8ToWasm0","_assertClass","instance","klass","isLikeNone","x","cachegetFloat64Memory0","getFloat64Memory0","Float64Array","LabelKind","Int","Text","SignedMessageKind","COSESIGN","COSESIGN1","SigContext","Signature","Signature1","CounterSignature","CBORSpecialType","Bool","Float","Unassigned","Break","Undefined","Null","CBORValueKind","Bytes","TaggedCBOR","Special","AlgorithmId","EdDSA","ChaCha20Poly1305","KeyType","OKP","EC2","Symmetric","ECKey","CRV","X","Y","D","CurveType","P256","P384","P521","X25519","X448","Ed25519","Ed448","KeyOperation","Sign","Verify","Encrypt","Decrypt","WrapKey","UnwrapKey","DeriveKey","DeriveBits","BigNum","__destroy_into_raw","__wbg_bignum_free","retptr","__wbindgen_add_to_stack_pointer","bignum_to_bytes","r0","r1","v0","__wbindgen_free","bignum_to_str","other","bignum_checked_mul","__wrap","bignum_checked_add","bignum_checked_sub","create","bytes","ptr0","__wbindgen_malloc","len0","bignum_from_bytes","string","__wbindgen_realloc","bignum_from_str","CBORArray","__wbg_cborarray_free","cborarray_to_bytes","cborarray_len","index","cborarray_get","CBORValue","elem","cborarray_add","use_definite","cborarray_set_definite_encoding","cborarray_is_definite","cborarray_from_bytes","cborarray_new","CBORObject","__wbg_cborobject_free","cborobject_to_bytes","cborobject_len","key","cborobject_insert","cborobject_get","cborobject_keys","cborobject_set_definite_encoding","cborobject_is_definite","cborobject_from_bytes","cborobject_new","CBORSpecial","__wbg_cborspecial_free","cborspecial_to_bytes","cborspecial_kind","cborspecial_as_bool","cborspecial_as_float","cborspecial_as_unassigned","cborspecial_from_bytes","b","cborspecial_new_bool","u","cborspecial_new_unassigned","cborspecial_new_break","cborspecial_new_null","cborspecial_new_undefined","__wbg_cborvalue_free","cborvalue_to_bytes","cborvalue_kind","cborvalue_as_int","cborvalue_as_bytes","cborvalue_as_text","cborvalue_as_array","cborvalue_as_object","cborvalue_as_tagged","cborvalue_as_special","cborvalue_from_bytes","int","cborvalue_new_int","cborvalue_new_bytes","text","cborvalue_new_text","arr","cborvalue_new_array","cborvalue_new_object","tagged","cborvalue_new_tagged","special","cborvalue_new_special","COSEEncrypt","__wbg_coseencrypt_free","coseencrypt_to_bytes","coseencrypt0_headers","Headers","coseencrypt0_ciphertext","coseencrypt_recipients","COSERecipients","coseencrypt_from_bytes","headers","ciphertext","recipients","coseencrypt_new","COSEEncrypt0","__wbg_coseencrypt0_free","coseencrypt0_to_bytes","coseencrypt0_from_bytes","coseencrypt0_new","COSEKey","__wbg_cosekey_free","cosekey_to_bytes","key_type","Label","cosekey_set_key_type","cosekey_key_type","key_id","cosekey_set_key_id","cosekey_key_id","algorithm_id","cosekey_set_algorithm_id","cosekey_algorithm_id","key_ops","Labels","cosekey_set_key_ops","cosekey_key_ops","base_init_vector","cosekey_set_base_init_vector","cosekey_base_init_vector","label","cosekey_header","cosekey_set_header","cosekey_from_bytes","cosekey_new","COSERecipient","__wbg_coserecipient_free","coserecipient_to_bytes","coserecipient_from_bytes","__wbg_coserecipients_free","coserecipients_to_bytes","coserecipients_len","coserecipients_get","coserecipients_add","coserecipients_from_bytes","coserecipients_new","COSESign","__wbg_cosesign_free","cosesign_to_bytes","cosesign_signatures","COSESignatures","cosesign_from_bytes","payload","signatures","cosesign_new","COSESign1","__wbg_cosesign1_free","cosesign1_to_bytes","cosesign1_signature","external_aad","external_payload","ptr1","len1","cosesign1_signed_data","SigStructure","cosesign1_from_bytes","signature","cosesign1_new","COSESign1Builder","__wbg_cosesign1builder_free","cosesign1builder_hash_payload","cosesign1builder_set_external_aad","cosesign1builder_make_data_to_sign","signed_sig_structure","cosesign1builder_build","is_payload_external","cosesign1builder_new","COSESignBuilder","__wbg_cosesignbuilder_free","cosesignbuilder_make_data_to_sign","cosesignbuilder_build","cosesignbuilder_new","COSESignature","__wbg_cosesignature_free","cosesignature_to_bytes","cosesignature_signature","cosesignature_from_bytes","cosesignature_new","__wbg_cosesignatures_free","cosesignatures_to_bytes","cosesignatures_get","cosesignatures_add","cosesignatures_from_bytes","__wbg_countersignature_free","countersignature_to_bytes","countersignature_signatures","countersignature_from_bytes","cose_signature","countersignature_new_single","cose_signatures","countersignature_new_multi","EdDSA25519Key","__wbg_eddsa25519key_free","private_key_bytes","eddsa25519key_set_private_key","eddsa25519key_is_for_signing","eddsa25519key_is_for_verifying","eddsa25519key_build","pubkey_bytes","eddsa25519key_new","HeaderMap","__wbg_headermap_free","headermap_to_bytes","headermap_set_algorithm_id","headermap_algorithm_id","criticality","headermap_set_criticality","headermap_criticality","content_type","headermap_set_key_id","headermap_key_id","init_vector","partial_init_vector","headermap_set_partial_init_vector","headermap_partial_init_vector","counter_signature","headermap_set_counter_signature","headermap_counter_signature","headermap_header","headermap_set_header","headermap_keys","headermap_from_bytes","headermap_new","__wbg_headers_free","headers_to_bytes","headers_protected","ProtectedHeaderMap","headers_unprotected","headers_from_bytes","protected_","unprotected_","headers_new","__wbg_int_free","int_is_positive","int_as_positive","int_as_negative","int_as_i32","int_new","int_new_negative","int_new_i32","__wbg_label_free","label_to_bytes","label_kind","label_as_int","label_as_text","label_from_bytes","label_new_int","label_new_text","label_from_algorithm_id","label_from_key_type","ec_key","label_from_ec_key","curve_type","label_from_curve_type","key_op","label_from_key_operation","__wbg_labels_free","labels_to_bytes","labels_get","labels_add","labels_from_bytes","PasswordEncryption","__wbg_passwordencryption_free","passwordencryption_to_bytes","passwordencryption_from_bytes","passwordencryption_new","__wbg_protectedheadermap_free","protectedheadermap_to_bytes","protectedheadermap_deserialized_headers","protectedheadermap_from_bytes","protectedheadermap_new_empty","header_map","protectedheadermap_new","PubKeyEncryption","__wbg_pubkeyencryption_free","pubkeyencryption_to_bytes","pubkeyencryption_from_bytes","pubkeyencryption_new","__wbg_sigstructure_free","sigstructure_to_bytes","sigstructure_context","sigstructure_body_protected","sigstructure_sign_protected","sigstructure_external_aad","sigstructure_payload","sign_protected","sigstructure_set_sign_protected","sigstructure_from_bytes","context","body_protected","sigstructure_new","SignedMessage","__wbg_signedmessage_free","signedmessage_to_bytes","signedmessage_to_user_facing_encoding","signedmessage_kind","signedmessage_as_cose_sign","signedmessage_as_cose_sign1","signedmessage_from_bytes","cose_sign","signedmessage_new_cose_sign","cose_sign1","signedmessage_new_cose_sign1","s","signedmessage_from_user_facing_encoding","__wbg_taggedcbor_free","taggedcbor_to_bytes","taggedcbor_tag","taggedcbor_value","taggedcbor_from_bytes","tag","taggedcbor_new","__wbindgen_object_drop_ref","arg0","__wbindgen_string_new","arg1","__wbindgen_debug_string","__wbindgen_throw","__wbindgen_rethrow","join","__dirname","readFileSync","wasmModule","WebAssembly","Module","wasmInstance","Instance","__wasm","_defineProperties","target","props","descriptor","enumerable","configurable","writable","defineProperty","_createClass","Constructor","protoProps","staticProps","_typeof","Symbol","iterator","constructor","_classCallCheck","TypeError","$","toIndexedObject","toLength","stat","template","rawTemplate","literalSegments","argumentsLength","elements","normalizeArray","parts","allowAboveRoot","up","last","splice","unshift","basename","start","end","matchedSlash","filter","xs","f","res","resolvedPath","resolvedAbsolute","process","charAt","split","p","normalize","isAbsolute","trailingSlash","substr","paths","relative","from","to","trim","fromParts","toParts","Math","min","samePartsLength","outputParts","concat","sep","delimiter","dirname","hasRoot","ext","extname","startDot","startPart","preDotState","str"],"mappings":"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","file":"web3-cardano-token.umd.min.2.js","sourcesContent":["exports.nextTick = function nextTick(fn) {\n    var args = Array.prototype.slice.call(arguments);\n    args.shift();\n    setTimeout(function () {\n        fn.apply(null, args);\n    }, 0);\n};\n\nexports.platform = exports.arch = \nexports.execPath = exports.title = 'browser';\nexports.pid = 1;\nexports.browser = true;\nexports.env = {};\nexports.argv = [];\n\nexports.binding = function (name) {\n\tthrow new Error('No such module. (Possibly not yet loaded)')\n};\n\n(function () {\n    var cwd = '/';\n    var path;\n    exports.cwd = function () { return cwd };\n    exports.chdir = function (dir) {\n        if (!path) path = require('path');\n        cwd = path.resolve(dir, cwd);\n    };\n})();\n\nexports.exit = exports.kill = \nexports.umask = exports.dlopen = \nexports.uptime = exports.memoryUsage = \nexports.uvCounters = function() {};\nexports.features = {};\n","var createTypedArrayConstructor = require('../internals/typed-array-constructor');\n\n// `Float64Array` constructor\n// https://tc39.es/ecma262/#sec-typedarray-objects\ncreateTypedArrayConstructor('Float64', function (init) {\n  return function Float64Array(data, byteOffset, length) {\n    return init(this, data, byteOffset, length);\n  };\n});\n","function webpackEmptyContext(req) {\n\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\te.code = 'MODULE_NOT_FOUND';\n\tthrow e;\n}\nwebpackEmptyContext.keys = function() { return []; };\nwebpackEmptyContext.resolve = webpackEmptyContext;\nmodule.exports = webpackEmptyContext;\nwebpackEmptyContext.id = \"4e10\";","function _taggedTemplateLiteral(strings, raw) {\n  if (!raw) {\n    raw = strings.slice(0);\n  }\n\n  return Object.freeze(Object.defineProperties(strings, {\n    raw: {\n      value: Object.freeze(raw)\n    }\n  }));\n}\n\nmodule.exports = _taggedTemplateLiteral;\nmodule.exports[\"default\"] = module.exports, module.exports.__esModule = true;","let imports = {};\nimports['__wbindgen_placeholder__'] = module.exports;\nlet wasm;\nconst { TextDecoder, TextEncoder } = require(String.raw`util`);\n\nconst heap = new Array(32).fill(undefined);\n\nheap.push(undefined, null, true, false);\n\nfunction getObject(idx) { return heap[idx]; }\n\nlet heap_next = heap.length;\n\nfunction dropObject(idx) {\n    if (idx < 36) return;\n    heap[idx] = heap_next;\n    heap_next = idx;\n}\n\nfunction takeObject(idx) {\n    const ret = getObject(idx);\n    dropObject(idx);\n    return ret;\n}\n\nlet cachedTextDecoder = new TextDecoder('utf-8', { ignoreBOM: true, fatal: true });\n\ncachedTextDecoder.decode();\n\nlet cachegetUint8Memory0 = null;\nfunction getUint8Memory0() {\n    if (cachegetUint8Memory0 === null || cachegetUint8Memory0.buffer !== wasm.memory.buffer) {\n        cachegetUint8Memory0 = new Uint8Array(wasm.memory.buffer);\n    }\n    return cachegetUint8Memory0;\n}\n\nfunction getStringFromWasm0(ptr, len) {\n    return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len));\n}\n\nfunction addHeapObject(obj) {\n    if (heap_next === heap.length) heap.push(heap.length + 1);\n    const idx = heap_next;\n    heap_next = heap[idx];\n\n    heap[idx] = obj;\n    return idx;\n}\n\nfunction debugString(val) {\n    // primitive types\n    const type = typeof val;\n    if (type == 'number' || type == 'boolean' || val == null) {\n        return  `${val}`;\n    }\n    if (type == 'string') {\n        return `\"${val}\"`;\n    }\n    if (type == 'symbol') {\n        const description = val.description;\n        if (description == null) {\n            return 'Symbol';\n        } else {\n            return `Symbol(${description})`;\n        }\n    }\n    if (type == 'function') {\n        const name = val.name;\n        if (typeof name == 'string' && name.length > 0) {\n            return `Function(${name})`;\n        } else {\n            return 'Function';\n        }\n    }\n    // objects\n    if (Array.isArray(val)) {\n        const length = val.length;\n        let debug = '[';\n        if (length > 0) {\n            debug += debugString(val[0]);\n        }\n        for(let i = 1; i < length; i++) {\n            debug += ', ' + debugString(val[i]);\n        }\n        debug += ']';\n        return debug;\n    }\n    // Test for built-in\n    const builtInMatches = /\\[object ([^\\]]+)\\]/.exec(toString.call(val));\n    let className;\n    if (builtInMatches.length > 1) {\n        className = builtInMatches[1];\n    } else {\n        // Failed to match the standard '[object ClassName]'\n        return toString.call(val);\n    }\n    if (className == 'Object') {\n        // we're a user defined class or Object\n        // JSON.stringify avoids problems with cycles, and is generally much\n        // easier than looping through ownProperties of `val`.\n        try {\n            return 'Object(' + JSON.stringify(val) + ')';\n        } catch (_) {\n            return 'Object';\n        }\n    }\n    // errors\n    if (val instanceof Error) {\n        return `${val.name}: ${val.message}\\n${val.stack}`;\n    }\n    // TODO we could test for more things here, like `Set`s and `Map`s.\n    return className;\n}\n\nlet WASM_VECTOR_LEN = 0;\n\nlet cachedTextEncoder = new TextEncoder('utf-8');\n\nconst encodeString = (typeof cachedTextEncoder.encodeInto === 'function'\n    ? function (arg, view) {\n    return cachedTextEncoder.encodeInto(arg, view);\n}\n    : function (arg, view) {\n    const buf = cachedTextEncoder.encode(arg);\n    view.set(buf);\n    return {\n        read: arg.length,\n        written: buf.length\n    };\n});\n\nfunction passStringToWasm0(arg, malloc, realloc) {\n\n    if (realloc === undefined) {\n        const buf = cachedTextEncoder.encode(arg);\n        const ptr = malloc(buf.length);\n        getUint8Memory0().subarray(ptr, ptr + buf.length).set(buf);\n        WASM_VECTOR_LEN = buf.length;\n        return ptr;\n    }\n\n    let len = arg.length;\n    let ptr = malloc(len);\n\n    const mem = getUint8Memory0();\n\n    let offset = 0;\n\n    for (; offset < len; offset++) {\n        const code = arg.charCodeAt(offset);\n        if (code > 0x7F) break;\n        mem[ptr + offset] = code;\n    }\n\n    if (offset !== len) {\n        if (offset !== 0) {\n            arg = arg.slice(offset);\n        }\n        ptr = realloc(ptr, len, len = offset + arg.length * 3);\n        const view = getUint8Memory0().subarray(ptr + offset, ptr + len);\n        const ret = encodeString(arg, view);\n\n        offset += ret.written;\n    }\n\n    WASM_VECTOR_LEN = offset;\n    return ptr;\n}\n\nlet cachegetInt32Memory0 = null;\nfunction getInt32Memory0() {\n    if (cachegetInt32Memory0 === null || cachegetInt32Memory0.buffer !== wasm.memory.buffer) {\n        cachegetInt32Memory0 = new Int32Array(wasm.memory.buffer);\n    }\n    return cachegetInt32Memory0;\n}\n\nfunction getArrayU8FromWasm0(ptr, len) {\n    return getUint8Memory0().subarray(ptr / 1, ptr / 1 + len);\n}\n\nfunction passArray8ToWasm0(arg, malloc) {\n    const ptr = malloc(arg.length * 1);\n    getUint8Memory0().set(arg, ptr / 1);\n    WASM_VECTOR_LEN = arg.length;\n    return ptr;\n}\n\nfunction _assertClass(instance, klass) {\n    if (!(instance instanceof klass)) {\n        throw new Error(`expected instance of ${klass.name}`);\n    }\n    return instance.ptr;\n}\n\nfunction isLikeNone(x) {\n    return x === undefined || x === null;\n}\n\nlet cachegetFloat64Memory0 = null;\nfunction getFloat64Memory0() {\n    if (cachegetFloat64Memory0 === null || cachegetFloat64Memory0.buffer !== wasm.memory.buffer) {\n        cachegetFloat64Memory0 = new Float64Array(wasm.memory.buffer);\n    }\n    return cachegetFloat64Memory0;\n}\n/**\n*/\nmodule.exports.LabelKind = Object.freeze({ Int:0,\"0\":\"Int\",Text:1,\"1\":\"Text\", });\n/**\n*/\nmodule.exports.SignedMessageKind = Object.freeze({ COSESIGN:0,\"0\":\"COSESIGN\",COSESIGN1:1,\"1\":\"COSESIGN1\", });\n/**\n*/\nmodule.exports.SigContext = Object.freeze({ Signature:0,\"0\":\"Signature\",Signature1:1,\"1\":\"Signature1\",CounterSignature:2,\"2\":\"CounterSignature\", });\n/**\n*/\nmodule.exports.CBORSpecialType = Object.freeze({ Bool:0,\"0\":\"Bool\",Float:1,\"1\":\"Float\",Unassigned:2,\"2\":\"Unassigned\",Break:3,\"3\":\"Break\",Undefined:4,\"4\":\"Undefined\",Null:5,\"5\":\"Null\", });\n/**\n*/\nmodule.exports.CBORValueKind = Object.freeze({ Int:0,\"0\":\"Int\",Bytes:1,\"1\":\"Bytes\",Text:2,\"2\":\"Text\",Array:3,\"3\":\"Array\",Object:4,\"4\":\"Object\",TaggedCBOR:5,\"5\":\"TaggedCBOR\",Special:6,\"6\":\"Special\", });\n/**\n*/\nmodule.exports.AlgorithmId = Object.freeze({\n/**\n*r\" EdDSA (Pure EdDSA, not HashedEdDSA) - the algorithm used for Cardano addresses\n*/\nEdDSA:0,\"0\":\"EdDSA\",\n/**\n*r\" ChaCha20/Poly1305 w/ 256-bit key, 128-bit tag\n*/\nChaCha20Poly1305:1,\"1\":\"ChaCha20Poly1305\", });\n/**\n*/\nmodule.exports.KeyType = Object.freeze({\n/**\n*r\" octet key pair\n*/\nOKP:0,\"0\":\"OKP\",\n/**\n*r\" 2-coord EC\n*/\nEC2:1,\"1\":\"EC2\",Symmetric:2,\"2\":\"Symmetric\", });\n/**\n*/\nmodule.exports.ECKey = Object.freeze({ CRV:0,\"0\":\"CRV\",X:1,\"1\":\"X\",Y:2,\"2\":\"Y\",D:3,\"3\":\"D\", });\n/**\n*/\nmodule.exports.CurveType = Object.freeze({ P256:0,\"0\":\"P256\",P384:1,\"1\":\"P384\",P521:2,\"2\":\"P521\",X25519:3,\"3\":\"X25519\",X448:4,\"4\":\"X448\",Ed25519:5,\"5\":\"Ed25519\",Ed448:6,\"6\":\"Ed448\", });\n/**\n*/\nmodule.exports.KeyOperation = Object.freeze({ Sign:0,\"0\":\"Sign\",Verify:1,\"1\":\"Verify\",Encrypt:2,\"2\":\"Encrypt\",Decrypt:3,\"3\":\"Decrypt\",WrapKey:4,\"4\":\"WrapKey\",UnwrapKey:5,\"5\":\"UnwrapKey\",DeriveKey:6,\"6\":\"DeriveKey\",DeriveBits:7,\"7\":\"DeriveBits\", });\n/**\n*/\nclass BigNum {\n\n    static __wrap(ptr) {\n        const obj = Object.create(BigNum.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_bignum_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.bignum_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {BigNum}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.bignum_from_bytes(ptr0, len0);\n        return BigNum.__wrap(ret);\n    }\n    /**\n    * @param {string} string\n    * @returns {BigNum}\n    */\n    static from_str(string) {\n        var ptr0 = passStringToWasm0(string, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.bignum_from_str(ptr0, len0);\n        return BigNum.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_str() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.bignum_to_str(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {BigNum} other\n    * @returns {BigNum}\n    */\n    checked_mul(other) {\n        _assertClass(other, BigNum);\n        var ret = wasm.bignum_checked_mul(this.ptr, other.ptr);\n        return BigNum.__wrap(ret);\n    }\n    /**\n    * @param {BigNum} other\n    * @returns {BigNum}\n    */\n    checked_add(other) {\n        _assertClass(other, BigNum);\n        var ret = wasm.bignum_checked_add(this.ptr, other.ptr);\n        return BigNum.__wrap(ret);\n    }\n    /**\n    * @param {BigNum} other\n    * @returns {BigNum}\n    */\n    checked_sub(other) {\n        _assertClass(other, BigNum);\n        var ret = wasm.bignum_checked_sub(this.ptr, other.ptr);\n        return BigNum.__wrap(ret);\n    }\n}\nmodule.exports.BigNum = BigNum;\n/**\n*/\nclass CBORArray {\n\n    static __wrap(ptr) {\n        const obj = Object.create(CBORArray.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_cborarray_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.cborarray_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {CBORArray}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.cborarray_from_bytes(ptr0, len0);\n        return CBORArray.__wrap(ret);\n    }\n    /**\n    * @returns {CBORArray}\n    */\n    static new() {\n        var ret = wasm.cborarray_new();\n        return CBORArray.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.cborarray_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} index\n    * @returns {CBORValue}\n    */\n    get(index) {\n        var ret = wasm.cborarray_get(this.ptr, index);\n        return CBORValue.__wrap(ret);\n    }\n    /**\n    * @param {CBORValue} elem\n    */\n    add(elem) {\n        _assertClass(elem, CBORValue);\n        wasm.cborarray_add(this.ptr, elem.ptr);\n    }\n    /**\n    * @param {boolean} use_definite\n    */\n    set_definite_encoding(use_definite) {\n        wasm.cborarray_set_definite_encoding(this.ptr, use_definite);\n    }\n    /**\n    * @returns {boolean}\n    */\n    is_definite() {\n        var ret = wasm.cborarray_is_definite(this.ptr);\n        return ret !== 0;\n    }\n}\nmodule.exports.CBORArray = CBORArray;\n/**\n*/\nclass CBORObject {\n\n    static __wrap(ptr) {\n        const obj = Object.create(CBORObject.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_cborobject_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.cborobject_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {CBORObject}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.cborobject_from_bytes(ptr0, len0);\n        return CBORObject.__wrap(ret);\n    }\n    /**\n    * @returns {CBORObject}\n    */\n    static new() {\n        var ret = wasm.cborobject_new();\n        return CBORObject.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.cborobject_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {CBORValue} key\n    * @param {CBORValue} value\n    * @returns {CBORValue | undefined}\n    */\n    insert(key, value) {\n        _assertClass(key, CBORValue);\n        _assertClass(value, CBORValue);\n        var ret = wasm.cborobject_insert(this.ptr, key.ptr, value.ptr);\n        return ret === 0 ? undefined : CBORValue.__wrap(ret);\n    }\n    /**\n    * @param {CBORValue} key\n    * @returns {CBORValue | undefined}\n    */\n    get(key) {\n        _assertClass(key, CBORValue);\n        var ret = wasm.cborobject_get(this.ptr, key.ptr);\n        return ret === 0 ? undefined : CBORValue.__wrap(ret);\n    }\n    /**\n    * @returns {CBORArray}\n    */\n    keys() {\n        var ret = wasm.cborobject_keys(this.ptr);\n        return CBORArray.__wrap(ret);\n    }\n    /**\n    * @param {boolean} use_definite\n    */\n    set_definite_encoding(use_definite) {\n        wasm.cborobject_set_definite_encoding(this.ptr, use_definite);\n    }\n    /**\n    * @returns {boolean}\n    */\n    is_definite() {\n        var ret = wasm.cborobject_is_definite(this.ptr);\n        return ret !== 0;\n    }\n}\nmodule.exports.CBORObject = CBORObject;\n/**\n*/\nclass CBORSpecial {\n\n    static __wrap(ptr) {\n        const obj = Object.create(CBORSpecial.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_cborspecial_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.cborspecial_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {CBORSpecial}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.cborspecial_from_bytes(ptr0, len0);\n        return CBORSpecial.__wrap(ret);\n    }\n    /**\n    * @param {boolean} b\n    * @returns {CBORSpecial}\n    */\n    static new_bool(b) {\n        var ret = wasm.cborspecial_new_bool(b);\n        return CBORSpecial.__wrap(ret);\n    }\n    /**\n    * @param {number} u\n    * @returns {CBORSpecial}\n    */\n    static new_unassigned(u) {\n        var ret = wasm.cborspecial_new_unassigned(u);\n        return CBORSpecial.__wrap(ret);\n    }\n    /**\n    * @returns {CBORSpecial}\n    */\n    static new_break() {\n        var ret = wasm.cborspecial_new_break();\n        return CBORSpecial.__wrap(ret);\n    }\n    /**\n    * @returns {CBORSpecial}\n    */\n    static new_null() {\n        var ret = wasm.cborspecial_new_null();\n        return CBORSpecial.__wrap(ret);\n    }\n    /**\n    * @returns {CBORSpecial}\n    */\n    static new_undefined() {\n        var ret = wasm.cborspecial_new_undefined();\n        return CBORSpecial.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    kind() {\n        var ret = wasm.cborspecial_kind(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {boolean | undefined}\n    */\n    as_bool() {\n        var ret = wasm.cborspecial_as_bool(this.ptr);\n        return ret === 0xFFFFFF ? undefined : ret !== 0;\n    }\n    /**\n    * @returns {number | undefined}\n    */\n    as_float() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.cborspecial_as_float(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getFloat64Memory0()[retptr / 8 + 1];\n            return r0 === 0 ? undefined : r1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {number | undefined}\n    */\n    as_unassigned() {\n        var ret = wasm.cborspecial_as_unassigned(this.ptr);\n        return ret === 0xFFFFFF ? undefined : ret;\n    }\n}\nmodule.exports.CBORSpecial = CBORSpecial;\n/**\n*/\nclass CBORValue {\n\n    static __wrap(ptr) {\n        const obj = Object.create(CBORValue.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_cborvalue_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.cborvalue_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {CBORValue}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.cborvalue_from_bytes(ptr0, len0);\n        return CBORValue.__wrap(ret);\n    }\n    /**\n    * @param {Int} int\n    * @returns {CBORValue}\n    */\n    static new_int(int) {\n        _assertClass(int, Int);\n        var ret = wasm.cborvalue_new_int(int.ptr);\n        return CBORValue.__wrap(ret);\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {CBORValue}\n    */\n    static new_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.cborvalue_new_bytes(ptr0, len0);\n        return CBORValue.__wrap(ret);\n    }\n    /**\n    * @param {string} text\n    * @returns {CBORValue}\n    */\n    static new_text(text) {\n        var ptr0 = passStringToWasm0(text, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.cborvalue_new_text(ptr0, len0);\n        return CBORValue.__wrap(ret);\n    }\n    /**\n    * @param {CBORArray} arr\n    * @returns {CBORValue}\n    */\n    static new_array(arr) {\n        _assertClass(arr, CBORArray);\n        var ret = wasm.cborvalue_new_array(arr.ptr);\n        return CBORValue.__wrap(ret);\n    }\n    /**\n    * @param {CBORObject} obj\n    * @returns {CBORValue}\n    */\n    static new_object(obj) {\n        _assertClass(obj, CBORObject);\n        var ret = wasm.cborvalue_new_object(obj.ptr);\n        return CBORValue.__wrap(ret);\n    }\n    /**\n    * @param {TaggedCBOR} tagged\n    * @returns {CBORValue}\n    */\n    static new_tagged(tagged) {\n        _assertClass(tagged, TaggedCBOR);\n        var ret = wasm.cborvalue_new_tagged(tagged.ptr);\n        return CBORValue.__wrap(ret);\n    }\n    /**\n    * @param {CBORSpecial} special\n    * @returns {CBORValue}\n    */\n    static new_special(special) {\n        _assertClass(special, CBORSpecial);\n        var ret = wasm.cborvalue_new_special(special.ptr);\n        return CBORValue.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    kind() {\n        var ret = wasm.cborvalue_kind(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {Int | undefined}\n    */\n    as_int() {\n        var ret = wasm.cborvalue_as_int(this.ptr);\n        return ret === 0 ? undefined : Int.__wrap(ret);\n    }\n    /**\n    * @returns {Uint8Array | undefined}\n    */\n    as_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.cborvalue_as_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            let v0;\n            if (r0 !== 0) {\n                v0 = getArrayU8FromWasm0(r0, r1).slice();\n                wasm.__wbindgen_free(r0, r1 * 1);\n            }\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string | undefined}\n    */\n    as_text() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.cborvalue_as_text(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            let v0;\n            if (r0 !== 0) {\n                v0 = getStringFromWasm0(r0, r1).slice();\n                wasm.__wbindgen_free(r0, r1 * 1);\n            }\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {CBORArray | undefined}\n    */\n    as_array() {\n        var ret = wasm.cborvalue_as_array(this.ptr);\n        return ret === 0 ? undefined : CBORArray.__wrap(ret);\n    }\n    /**\n    * @returns {CBORObject | undefined}\n    */\n    as_object() {\n        var ret = wasm.cborvalue_as_object(this.ptr);\n        return ret === 0 ? undefined : CBORObject.__wrap(ret);\n    }\n    /**\n    * @returns {TaggedCBOR | undefined}\n    */\n    as_tagged() {\n        var ret = wasm.cborvalue_as_tagged(this.ptr);\n        return ret === 0 ? undefined : TaggedCBOR.__wrap(ret);\n    }\n    /**\n    * @returns {CBORSpecial | undefined}\n    */\n    as_special() {\n        var ret = wasm.cborvalue_as_special(this.ptr);\n        return ret === 0 ? undefined : CBORSpecial.__wrap(ret);\n    }\n}\nmodule.exports.CBORValue = CBORValue;\n/**\n*/\nclass COSEEncrypt {\n\n    static __wrap(ptr) {\n        const obj = Object.create(COSEEncrypt.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_coseencrypt_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.coseencrypt_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {COSEEncrypt}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.coseencrypt_from_bytes(ptr0, len0);\n        return COSEEncrypt.__wrap(ret);\n    }\n    /**\n    * @returns {Headers}\n    */\n    headers() {\n        var ret = wasm.coseencrypt0_headers(this.ptr);\n        return Headers.__wrap(ret);\n    }\n    /**\n    * @returns {Uint8Array | undefined}\n    */\n    ciphertext() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.coseencrypt0_ciphertext(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            let v0;\n            if (r0 !== 0) {\n                v0 = getArrayU8FromWasm0(r0, r1).slice();\n                wasm.__wbindgen_free(r0, r1 * 1);\n            }\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {COSERecipients}\n    */\n    recipients() {\n        var ret = wasm.coseencrypt_recipients(this.ptr);\n        return COSERecipients.__wrap(ret);\n    }\n    /**\n    * @param {Headers} headers\n    * @param {Uint8Array | undefined} ciphertext\n    * @param {COSERecipients} recipients\n    * @returns {COSEEncrypt}\n    */\n    static new(headers, ciphertext, recipients) {\n        _assertClass(headers, Headers);\n        var ptr0 = isLikeNone(ciphertext) ? 0 : passArray8ToWasm0(ciphertext, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        _assertClass(recipients, COSERecipients);\n        var ret = wasm.coseencrypt_new(headers.ptr, ptr0, len0, recipients.ptr);\n        return COSEEncrypt.__wrap(ret);\n    }\n}\nmodule.exports.COSEEncrypt = COSEEncrypt;\n/**\n*/\nclass COSEEncrypt0 {\n\n    static __wrap(ptr) {\n        const obj = Object.create(COSEEncrypt0.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_coseencrypt0_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.coseencrypt0_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {COSEEncrypt0}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.coseencrypt0_from_bytes(ptr0, len0);\n        return COSEEncrypt0.__wrap(ret);\n    }\n    /**\n    * @returns {Headers}\n    */\n    headers() {\n        var ret = wasm.coseencrypt0_headers(this.ptr);\n        return Headers.__wrap(ret);\n    }\n    /**\n    * @returns {Uint8Array | undefined}\n    */\n    ciphertext() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.coseencrypt0_ciphertext(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            let v0;\n            if (r0 !== 0) {\n                v0 = getArrayU8FromWasm0(r0, r1).slice();\n                wasm.__wbindgen_free(r0, r1 * 1);\n            }\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Headers} headers\n    * @param {Uint8Array | undefined} ciphertext\n    * @returns {COSEEncrypt0}\n    */\n    static new(headers, ciphertext) {\n        _assertClass(headers, Headers);\n        var ptr0 = isLikeNone(ciphertext) ? 0 : passArray8ToWasm0(ciphertext, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.coseencrypt0_new(headers.ptr, ptr0, len0);\n        return COSEEncrypt0.__wrap(ret);\n    }\n}\nmodule.exports.COSEEncrypt0 = COSEEncrypt0;\n/**\n*/\nclass COSEKey {\n\n    static __wrap(ptr) {\n        const obj = Object.create(COSEKey.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_cosekey_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.cosekey_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {COSEKey}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.cosekey_from_bytes(ptr0, len0);\n        return COSEKey.__wrap(ret);\n    }\n    /**\n    * @param {Label} key_type\n    */\n    set_key_type(key_type) {\n        _assertClass(key_type, Label);\n        wasm.cosekey_set_key_type(this.ptr, key_type.ptr);\n    }\n    /**\n    * @returns {Label}\n    */\n    key_type() {\n        var ret = wasm.cosekey_key_type(this.ptr);\n        return Label.__wrap(ret);\n    }\n    /**\n    * @param {Uint8Array} key_id\n    */\n    set_key_id(key_id) {\n        var ptr0 = passArray8ToWasm0(key_id, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        wasm.cosekey_set_key_id(this.ptr, ptr0, len0);\n    }\n    /**\n    * @returns {Uint8Array | undefined}\n    */\n    key_id() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.cosekey_key_id(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            let v0;\n            if (r0 !== 0) {\n                v0 = getArrayU8FromWasm0(r0, r1).slice();\n                wasm.__wbindgen_free(r0, r1 * 1);\n            }\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Label} algorithm_id\n    */\n    set_algorithm_id(algorithm_id) {\n        _assertClass(algorithm_id, Label);\n        wasm.cosekey_set_algorithm_id(this.ptr, algorithm_id.ptr);\n    }\n    /**\n    * @returns {Label | undefined}\n    */\n    algorithm_id() {\n        var ret = wasm.cosekey_algorithm_id(this.ptr);\n        return ret === 0 ? undefined : Label.__wrap(ret);\n    }\n    /**\n    * @param {Labels} key_ops\n    */\n    set_key_ops(key_ops) {\n        _assertClass(key_ops, Labels);\n        wasm.cosekey_set_key_ops(this.ptr, key_ops.ptr);\n    }\n    /**\n    * @returns {Labels | undefined}\n    */\n    key_ops() {\n        var ret = wasm.cosekey_key_ops(this.ptr);\n        return ret === 0 ? undefined : Labels.__wrap(ret);\n    }\n    /**\n    * @param {Uint8Array} base_init_vector\n    */\n    set_base_init_vector(base_init_vector) {\n        var ptr0 = passArray8ToWasm0(base_init_vector, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        wasm.cosekey_set_base_init_vector(this.ptr, ptr0, len0);\n    }\n    /**\n    * @returns {Uint8Array | undefined}\n    */\n    base_init_vector() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.cosekey_base_init_vector(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            let v0;\n            if (r0 !== 0) {\n                v0 = getArrayU8FromWasm0(r0, r1).slice();\n                wasm.__wbindgen_free(r0, r1 * 1);\n            }\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Label} label\n    * @returns {CBORValue | undefined}\n    */\n    header(label) {\n        _assertClass(label, Label);\n        var ret = wasm.cosekey_header(this.ptr, label.ptr);\n        return ret === 0 ? undefined : CBORValue.__wrap(ret);\n    }\n    /**\n    * @param {Label} label\n    * @param {CBORValue} value\n    */\n    set_header(label, value) {\n        _assertClass(label, Label);\n        _assertClass(value, CBORValue);\n        wasm.cosekey_set_header(this.ptr, label.ptr, value.ptr);\n    }\n    /**\n    * @param {Label} key_type\n    * @returns {COSEKey}\n    */\n    static new(key_type) {\n        _assertClass(key_type, Label);\n        var ret = wasm.cosekey_new(key_type.ptr);\n        return COSEKey.__wrap(ret);\n    }\n}\nmodule.exports.COSEKey = COSEKey;\n/**\n*/\nclass COSERecipient {\n\n    static __wrap(ptr) {\n        const obj = Object.create(COSERecipient.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_coserecipient_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.coserecipient_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {COSERecipient}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.coserecipient_from_bytes(ptr0, len0);\n        return COSERecipient.__wrap(ret);\n    }\n    /**\n    * @returns {Headers}\n    */\n    headers() {\n        var ret = wasm.coseencrypt0_headers(this.ptr);\n        return Headers.__wrap(ret);\n    }\n    /**\n    * @returns {Uint8Array | undefined}\n    */\n    ciphertext() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.coseencrypt0_ciphertext(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            let v0;\n            if (r0 !== 0) {\n                v0 = getArrayU8FromWasm0(r0, r1).slice();\n                wasm.__wbindgen_free(r0, r1 * 1);\n            }\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Headers} headers\n    * @param {Uint8Array | undefined} ciphertext\n    * @returns {COSERecipient}\n    */\n    static new(headers, ciphertext) {\n        _assertClass(headers, Headers);\n        var ptr0 = isLikeNone(ciphertext) ? 0 : passArray8ToWasm0(ciphertext, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.coseencrypt0_new(headers.ptr, ptr0, len0);\n        return COSERecipient.__wrap(ret);\n    }\n}\nmodule.exports.COSERecipient = COSERecipient;\n/**\n*/\nclass COSERecipients {\n\n    static __wrap(ptr) {\n        const obj = Object.create(COSERecipients.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_coserecipients_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.coserecipients_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {COSERecipients}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.coserecipients_from_bytes(ptr0, len0);\n        return COSERecipients.__wrap(ret);\n    }\n    /**\n    * @returns {COSERecipients}\n    */\n    static new() {\n        var ret = wasm.coserecipients_new();\n        return COSERecipients.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.coserecipients_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} index\n    * @returns {COSERecipient}\n    */\n    get(index) {\n        var ret = wasm.coserecipients_get(this.ptr, index);\n        return COSERecipient.__wrap(ret);\n    }\n    /**\n    * @param {COSERecipient} elem\n    */\n    add(elem) {\n        _assertClass(elem, COSERecipient);\n        wasm.coserecipients_add(this.ptr, elem.ptr);\n    }\n}\nmodule.exports.COSERecipients = COSERecipients;\n/**\n*/\nclass COSESign {\n\n    static __wrap(ptr) {\n        const obj = Object.create(COSESign.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_cosesign_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.cosesign_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {COSESign}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.cosesign_from_bytes(ptr0, len0);\n        return COSESign.__wrap(ret);\n    }\n    /**\n    * @returns {Headers}\n    */\n    headers() {\n        var ret = wasm.coseencrypt0_headers(this.ptr);\n        return Headers.__wrap(ret);\n    }\n    /**\n    * @returns {Uint8Array | undefined}\n    */\n    payload() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.coseencrypt0_ciphertext(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            let v0;\n            if (r0 !== 0) {\n                v0 = getArrayU8FromWasm0(r0, r1).slice();\n                wasm.__wbindgen_free(r0, r1 * 1);\n            }\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {COSESignatures}\n    */\n    signatures() {\n        var ret = wasm.cosesign_signatures(this.ptr);\n        return COSESignatures.__wrap(ret);\n    }\n    /**\n    * @param {Headers} headers\n    * @param {Uint8Array | undefined} payload\n    * @param {COSESignatures} signatures\n    * @returns {COSESign}\n    */\n    static new(headers, payload, signatures) {\n        _assertClass(headers, Headers);\n        var ptr0 = isLikeNone(payload) ? 0 : passArray8ToWasm0(payload, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        _assertClass(signatures, COSESignatures);\n        var ret = wasm.cosesign_new(headers.ptr, ptr0, len0, signatures.ptr);\n        return COSESign.__wrap(ret);\n    }\n}\nmodule.exports.COSESign = COSESign;\n/**\n*/\nclass COSESign1 {\n\n    static __wrap(ptr) {\n        const obj = Object.create(COSESign1.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_cosesign1_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.cosesign1_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {COSESign1}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.cosesign1_from_bytes(ptr0, len0);\n        return COSESign1.__wrap(ret);\n    }\n    /**\n    * @returns {Headers}\n    */\n    headers() {\n        var ret = wasm.coseencrypt0_headers(this.ptr);\n        return Headers.__wrap(ret);\n    }\n    /**\n    * @returns {Uint8Array | undefined}\n    */\n    payload() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.coseencrypt0_ciphertext(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            let v0;\n            if (r0 !== 0) {\n                v0 = getArrayU8FromWasm0(r0, r1).slice();\n                wasm.__wbindgen_free(r0, r1 * 1);\n            }\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    signature() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.cosesign1_signature(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * For verifying, we will want to reverse-construct this SigStructure to check the signature against\n    * # Arguments\n    * * `external_aad` - External application data - see RFC 8152 section 4.3. Set to None if not using this.\n    * @param {Uint8Array | undefined} external_aad\n    * @param {Uint8Array | undefined} external_payload\n    * @returns {SigStructure}\n    */\n    signed_data(external_aad, external_payload) {\n        var ptr0 = isLikeNone(external_aad) ? 0 : passArray8ToWasm0(external_aad, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ptr1 = isLikeNone(external_payload) ? 0 : passArray8ToWasm0(external_payload, wasm.__wbindgen_malloc);\n        var len1 = WASM_VECTOR_LEN;\n        var ret = wasm.cosesign1_signed_data(this.ptr, ptr0, len0, ptr1, len1);\n        return SigStructure.__wrap(ret);\n    }\n    /**\n    * @param {Headers} headers\n    * @param {Uint8Array | undefined} payload\n    * @param {Uint8Array} signature\n    * @returns {COSESign1}\n    */\n    static new(headers, payload, signature) {\n        _assertClass(headers, Headers);\n        var ptr0 = isLikeNone(payload) ? 0 : passArray8ToWasm0(payload, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ptr1 = passArray8ToWasm0(signature, wasm.__wbindgen_malloc);\n        var len1 = WASM_VECTOR_LEN;\n        var ret = wasm.cosesign1_new(headers.ptr, ptr0, len0, ptr1, len1);\n        return COSESign1.__wrap(ret);\n    }\n}\nmodule.exports.COSESign1 = COSESign1;\n/**\n*/\nclass COSESign1Builder {\n\n    static __wrap(ptr) {\n        const obj = Object.create(COSESign1Builder.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_cosesign1builder_free(ptr);\n    }\n    /**\n    * @param {Headers} headers\n    * @param {Uint8Array} payload\n    * @param {boolean} is_payload_external\n    * @returns {COSESign1Builder}\n    */\n    static new(headers, payload, is_payload_external) {\n        _assertClass(headers, Headers);\n        var ptr0 = passArray8ToWasm0(payload, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.cosesign1builder_new(headers.ptr, ptr0, len0, is_payload_external);\n        return COSESign1Builder.__wrap(ret);\n    }\n    /**\n    */\n    hash_payload() {\n        wasm.cosesign1builder_hash_payload(this.ptr);\n    }\n    /**\n    * @param {Uint8Array} external_aad\n    */\n    set_external_aad(external_aad) {\n        var ptr0 = passArray8ToWasm0(external_aad, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        wasm.cosesign1builder_set_external_aad(this.ptr, ptr0, len0);\n    }\n    /**\n    * @returns {SigStructure}\n    */\n    make_data_to_sign() {\n        var ret = wasm.cosesign1builder_make_data_to_sign(this.ptr);\n        return SigStructure.__wrap(ret);\n    }\n    /**\n    * @param {Uint8Array} signed_sig_structure\n    * @returns {COSESign1}\n    */\n    build(signed_sig_structure) {\n        var ptr0 = passArray8ToWasm0(signed_sig_structure, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.cosesign1builder_build(this.ptr, ptr0, len0);\n        return COSESign1.__wrap(ret);\n    }\n}\nmodule.exports.COSESign1Builder = COSESign1Builder;\n/**\n*/\nclass COSESignBuilder {\n\n    static __wrap(ptr) {\n        const obj = Object.create(COSESignBuilder.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_cosesignbuilder_free(ptr);\n    }\n    /**\n    * @param {Headers} headers\n    * @param {Uint8Array} payload\n    * @param {boolean} is_payload_external\n    * @returns {COSESignBuilder}\n    */\n    static new(headers, payload, is_payload_external) {\n        _assertClass(headers, Headers);\n        var ptr0 = passArray8ToWasm0(payload, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.cosesignbuilder_new(headers.ptr, ptr0, len0, is_payload_external);\n        return COSESignBuilder.__wrap(ret);\n    }\n    /**\n    */\n    hash_payload() {\n        wasm.cosesign1builder_hash_payload(this.ptr);\n    }\n    /**\n    * @param {Uint8Array} external_aad\n    */\n    set_external_aad(external_aad) {\n        var ptr0 = passArray8ToWasm0(external_aad, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        wasm.cosesign1builder_set_external_aad(this.ptr, ptr0, len0);\n    }\n    /**\n    * @returns {SigStructure}\n    */\n    make_data_to_sign() {\n        var ret = wasm.cosesignbuilder_make_data_to_sign(this.ptr);\n        return SigStructure.__wrap(ret);\n    }\n    /**\n    * @param {COSESignatures} signed_sig_structure\n    * @returns {COSESign}\n    */\n    build(signed_sig_structure) {\n        _assertClass(signed_sig_structure, COSESignatures);\n        var ret = wasm.cosesignbuilder_build(this.ptr, signed_sig_structure.ptr);\n        return COSESign.__wrap(ret);\n    }\n}\nmodule.exports.COSESignBuilder = COSESignBuilder;\n/**\n*/\nclass COSESignature {\n\n    static __wrap(ptr) {\n        const obj = Object.create(COSESignature.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_cosesignature_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.cosesignature_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {COSESignature}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.cosesignature_from_bytes(ptr0, len0);\n        return COSESignature.__wrap(ret);\n    }\n    /**\n    * @returns {Headers}\n    */\n    headers() {\n        var ret = wasm.coseencrypt0_headers(this.ptr);\n        return Headers.__wrap(ret);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    signature() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.cosesignature_signature(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Headers} headers\n    * @param {Uint8Array} signature\n    * @returns {COSESignature}\n    */\n    static new(headers, signature) {\n        _assertClass(headers, Headers);\n        var ptr0 = passArray8ToWasm0(signature, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.cosesignature_new(headers.ptr, ptr0, len0);\n        return COSESignature.__wrap(ret);\n    }\n}\nmodule.exports.COSESignature = COSESignature;\n/**\n*/\nclass COSESignatures {\n\n    static __wrap(ptr) {\n        const obj = Object.create(COSESignatures.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_cosesignatures_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.cosesignatures_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {COSESignatures}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.cosesignatures_from_bytes(ptr0, len0);\n        return COSESignatures.__wrap(ret);\n    }\n    /**\n    * @returns {COSESignatures}\n    */\n    static new() {\n        var ret = wasm.coserecipients_new();\n        return COSESignatures.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.coserecipients_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} index\n    * @returns {COSESignature}\n    */\n    get(index) {\n        var ret = wasm.cosesignatures_get(this.ptr, index);\n        return COSESignature.__wrap(ret);\n    }\n    /**\n    * @param {COSESignature} elem\n    */\n    add(elem) {\n        _assertClass(elem, COSESignature);\n        wasm.cosesignatures_add(this.ptr, elem.ptr);\n    }\n}\nmodule.exports.COSESignatures = COSESignatures;\n/**\n*/\nclass CounterSignature {\n\n    static __wrap(ptr) {\n        const obj = Object.create(CounterSignature.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_countersignature_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.countersignature_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {CounterSignature}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.countersignature_from_bytes(ptr0, len0);\n        return CounterSignature.__wrap(ret);\n    }\n    /**\n    * @param {COSESignature} cose_signature\n    * @returns {CounterSignature}\n    */\n    static new_single(cose_signature) {\n        _assertClass(cose_signature, COSESignature);\n        var ret = wasm.countersignature_new_single(cose_signature.ptr);\n        return CounterSignature.__wrap(ret);\n    }\n    /**\n    * @param {COSESignatures} cose_signatures\n    * @returns {CounterSignature}\n    */\n    static new_multi(cose_signatures) {\n        _assertClass(cose_signatures, COSESignatures);\n        var ret = wasm.countersignature_new_multi(cose_signatures.ptr);\n        return CounterSignature.__wrap(ret);\n    }\n    /**\n    * @returns {COSESignatures}\n    */\n    signatures() {\n        var ret = wasm.countersignature_signatures(this.ptr);\n        return COSESignatures.__wrap(ret);\n    }\n}\nmodule.exports.CounterSignature = CounterSignature;\n/**\n*/\nclass EdDSA25519Key {\n\n    static __wrap(ptr) {\n        const obj = Object.create(EdDSA25519Key.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_eddsa25519key_free(ptr);\n    }\n    /**\n    * @param {Uint8Array} pubkey_bytes\n    * @returns {EdDSA25519Key}\n    */\n    static new(pubkey_bytes) {\n        var ptr0 = passArray8ToWasm0(pubkey_bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.eddsa25519key_new(ptr0, len0);\n        return EdDSA25519Key.__wrap(ret);\n    }\n    /**\n    * @param {Uint8Array} private_key_bytes\n    */\n    set_private_key(private_key_bytes) {\n        var ptr0 = passArray8ToWasm0(private_key_bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        wasm.eddsa25519key_set_private_key(this.ptr, ptr0, len0);\n    }\n    /**\n    */\n    is_for_signing() {\n        wasm.eddsa25519key_is_for_signing(this.ptr);\n    }\n    /**\n    */\n    is_for_verifying() {\n        wasm.eddsa25519key_is_for_verifying(this.ptr);\n    }\n    /**\n    * @returns {COSEKey}\n    */\n    build() {\n        var ret = wasm.eddsa25519key_build(this.ptr);\n        return COSEKey.__wrap(ret);\n    }\n}\nmodule.exports.EdDSA25519Key = EdDSA25519Key;\n/**\n*/\nclass HeaderMap {\n\n    static __wrap(ptr) {\n        const obj = Object.create(HeaderMap.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_headermap_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.headermap_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {HeaderMap}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.headermap_from_bytes(ptr0, len0);\n        return HeaderMap.__wrap(ret);\n    }\n    /**\n    * @param {Label} algorithm_id\n    */\n    set_algorithm_id(algorithm_id) {\n        _assertClass(algorithm_id, Label);\n        wasm.headermap_set_algorithm_id(this.ptr, algorithm_id.ptr);\n    }\n    /**\n    * @returns {Label | undefined}\n    */\n    algorithm_id() {\n        var ret = wasm.headermap_algorithm_id(this.ptr);\n        return ret === 0 ? undefined : Label.__wrap(ret);\n    }\n    /**\n    * @param {Labels} criticality\n    */\n    set_criticality(criticality) {\n        _assertClass(criticality, Labels);\n        wasm.headermap_set_criticality(this.ptr, criticality.ptr);\n    }\n    /**\n    * @returns {Labels | undefined}\n    */\n    criticality() {\n        var ret = wasm.headermap_criticality(this.ptr);\n        return ret === 0 ? undefined : Labels.__wrap(ret);\n    }\n    /**\n    * @param {Label} content_type\n    */\n    set_content_type(content_type) {\n        _assertClass(content_type, Label);\n        wasm.cosekey_set_algorithm_id(this.ptr, content_type.ptr);\n    }\n    /**\n    * @returns {Label | undefined}\n    */\n    content_type() {\n        var ret = wasm.cosekey_algorithm_id(this.ptr);\n        return ret === 0 ? undefined : Label.__wrap(ret);\n    }\n    /**\n    * @param {Uint8Array} key_id\n    */\n    set_key_id(key_id) {\n        var ptr0 = passArray8ToWasm0(key_id, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        wasm.headermap_set_key_id(this.ptr, ptr0, len0);\n    }\n    /**\n    * @returns {Uint8Array | undefined}\n    */\n    key_id() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.headermap_key_id(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            let v0;\n            if (r0 !== 0) {\n                v0 = getArrayU8FromWasm0(r0, r1).slice();\n                wasm.__wbindgen_free(r0, r1 * 1);\n            }\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} init_vector\n    */\n    set_init_vector(init_vector) {\n        var ptr0 = passArray8ToWasm0(init_vector, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        wasm.cosekey_set_base_init_vector(this.ptr, ptr0, len0);\n    }\n    /**\n    * @returns {Uint8Array | undefined}\n    */\n    init_vector() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.cosekey_base_init_vector(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            let v0;\n            if (r0 !== 0) {\n                v0 = getArrayU8FromWasm0(r0, r1).slice();\n                wasm.__wbindgen_free(r0, r1 * 1);\n            }\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} partial_init_vector\n    */\n    set_partial_init_vector(partial_init_vector) {\n        var ptr0 = passArray8ToWasm0(partial_init_vector, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        wasm.headermap_set_partial_init_vector(this.ptr, ptr0, len0);\n    }\n    /**\n    * @returns {Uint8Array | undefined}\n    */\n    partial_init_vector() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.headermap_partial_init_vector(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            let v0;\n            if (r0 !== 0) {\n                v0 = getArrayU8FromWasm0(r0, r1).slice();\n                wasm.__wbindgen_free(r0, r1 * 1);\n            }\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {CounterSignature} counter_signature\n    */\n    set_counter_signature(counter_signature) {\n        _assertClass(counter_signature, CounterSignature);\n        wasm.headermap_set_counter_signature(this.ptr, counter_signature.ptr);\n    }\n    /**\n    * @returns {CounterSignature | undefined}\n    */\n    counter_signature() {\n        var ret = wasm.headermap_counter_signature(this.ptr);\n        return ret === 0 ? undefined : CounterSignature.__wrap(ret);\n    }\n    /**\n    * @param {Label} label\n    * @returns {CBORValue | undefined}\n    */\n    header(label) {\n        _assertClass(label, Label);\n        var ret = wasm.headermap_header(this.ptr, label.ptr);\n        return ret === 0 ? undefined : CBORValue.__wrap(ret);\n    }\n    /**\n    * @param {Label} label\n    * @param {CBORValue} value\n    */\n    set_header(label, value) {\n        _assertClass(label, Label);\n        _assertClass(value, CBORValue);\n        wasm.headermap_set_header(this.ptr, label.ptr, value.ptr);\n    }\n    /**\n    * @returns {Labels}\n    */\n    keys() {\n        var ret = wasm.headermap_keys(this.ptr);\n        return Labels.__wrap(ret);\n    }\n    /**\n    * @returns {HeaderMap}\n    */\n    static new() {\n        var ret = wasm.headermap_new();\n        return HeaderMap.__wrap(ret);\n    }\n}\nmodule.exports.HeaderMap = HeaderMap;\n/**\n*/\nclass Headers {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Headers.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_headers_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.headers_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {Headers}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.headers_from_bytes(ptr0, len0);\n        return Headers.__wrap(ret);\n    }\n    /**\n    * @returns {ProtectedHeaderMap}\n    */\n    protected() {\n        var ret = wasm.headers_protected(this.ptr);\n        return ProtectedHeaderMap.__wrap(ret);\n    }\n    /**\n    * @returns {HeaderMap}\n    */\n    unprotected() {\n        var ret = wasm.headers_unprotected(this.ptr);\n        return HeaderMap.__wrap(ret);\n    }\n    /**\n    * @param {ProtectedHeaderMap} protected_\n    * @param {HeaderMap} unprotected_\n    * @returns {Headers}\n    */\n    static new(protected_, unprotected_) {\n        _assertClass(protected_, ProtectedHeaderMap);\n        _assertClass(unprotected_, HeaderMap);\n        var ret = wasm.headers_new(protected_.ptr, unprotected_.ptr);\n        return Headers.__wrap(ret);\n    }\n}\nmodule.exports.Headers = Headers;\n/**\n*/\nclass Int {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Int.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_int_free(ptr);\n    }\n    /**\n    * @param {BigNum} x\n    * @returns {Int}\n    */\n    static new(x) {\n        _assertClass(x, BigNum);\n        var ptr0 = x.ptr;\n        x.ptr = 0;\n        var ret = wasm.int_new(ptr0);\n        return Int.__wrap(ret);\n    }\n    /**\n    * @param {BigNum} x\n    * @returns {Int}\n    */\n    static new_negative(x) {\n        _assertClass(x, BigNum);\n        var ptr0 = x.ptr;\n        x.ptr = 0;\n        var ret = wasm.int_new_negative(ptr0);\n        return Int.__wrap(ret);\n    }\n    /**\n    * @param {number} x\n    * @returns {Int}\n    */\n    static new_i32(x) {\n        var ret = wasm.int_new_i32(x);\n        return Int.__wrap(ret);\n    }\n    /**\n    * @returns {boolean}\n    */\n    is_positive() {\n        var ret = wasm.int_is_positive(this.ptr);\n        return ret !== 0;\n    }\n    /**\n    * @returns {BigNum | undefined}\n    */\n    as_positive() {\n        var ret = wasm.int_as_positive(this.ptr);\n        return ret === 0 ? undefined : BigNum.__wrap(ret);\n    }\n    /**\n    * @returns {BigNum | undefined}\n    */\n    as_negative() {\n        var ret = wasm.int_as_negative(this.ptr);\n        return ret === 0 ? undefined : BigNum.__wrap(ret);\n    }\n    /**\n    * @returns {number | undefined}\n    */\n    as_i32() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.int_as_i32(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\nmodule.exports.Int = Int;\n/**\n*/\nclass Label {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Label.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_label_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.label_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {Label}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.label_from_bytes(ptr0, len0);\n        return Label.__wrap(ret);\n    }\n    /**\n    * @param {Int} int\n    * @returns {Label}\n    */\n    static new_int(int) {\n        _assertClass(int, Int);\n        var ret = wasm.label_new_int(int.ptr);\n        return Label.__wrap(ret);\n    }\n    /**\n    * @param {string} text\n    * @returns {Label}\n    */\n    static new_text(text) {\n        var ptr0 = passStringToWasm0(text, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.label_new_text(ptr0, len0);\n        return Label.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    kind() {\n        var ret = wasm.label_kind(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {Int | undefined}\n    */\n    as_int() {\n        var ret = wasm.label_as_int(this.ptr);\n        return ret === 0 ? undefined : Int.__wrap(ret);\n    }\n    /**\n    * @returns {string | undefined}\n    */\n    as_text() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.label_as_text(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            let v0;\n            if (r0 !== 0) {\n                v0 = getStringFromWasm0(r0, r1).slice();\n                wasm.__wbindgen_free(r0, r1 * 1);\n            }\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {number} id\n    * @returns {Label}\n    */\n    static from_algorithm_id(id) {\n        var ret = wasm.label_from_algorithm_id(id);\n        return Label.__wrap(ret);\n    }\n    /**\n    * @param {number} key_type\n    * @returns {Label}\n    */\n    static from_key_type(key_type) {\n        var ret = wasm.label_from_key_type(key_type);\n        return Label.__wrap(ret);\n    }\n    /**\n    * @param {number} ec_key\n    * @returns {Label}\n    */\n    static from_ec_key(ec_key) {\n        var ret = wasm.label_from_ec_key(ec_key);\n        return Label.__wrap(ret);\n    }\n    /**\n    * @param {number} curve_type\n    * @returns {Label}\n    */\n    static from_curve_type(curve_type) {\n        var ret = wasm.label_from_curve_type(curve_type);\n        return Label.__wrap(ret);\n    }\n    /**\n    * @param {number} key_op\n    * @returns {Label}\n    */\n    static from_key_operation(key_op) {\n        var ret = wasm.label_from_key_operation(key_op);\n        return Label.__wrap(ret);\n    }\n}\nmodule.exports.Label = Label;\n/**\n*/\nclass Labels {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Labels.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_labels_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.labels_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {Labels}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.labels_from_bytes(ptr0, len0);\n        return Labels.__wrap(ret);\n    }\n    /**\n    * @returns {Labels}\n    */\n    static new() {\n        var ret = wasm.coserecipients_new();\n        return Labels.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.coserecipients_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} index\n    * @returns {Label}\n    */\n    get(index) {\n        var ret = wasm.labels_get(this.ptr, index);\n        return Label.__wrap(ret);\n    }\n    /**\n    * @param {Label} elem\n    */\n    add(elem) {\n        _assertClass(elem, Label);\n        wasm.labels_add(this.ptr, elem.ptr);\n    }\n}\nmodule.exports.Labels = Labels;\n/**\n*/\nclass PasswordEncryption {\n\n    static __wrap(ptr) {\n        const obj = Object.create(PasswordEncryption.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_passwordencryption_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.passwordencryption_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {PasswordEncryption}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.passwordencryption_from_bytes(ptr0, len0);\n        return PasswordEncryption.__wrap(ret);\n    }\n    /**\n    * @param {COSEEncrypt0} data\n    * @returns {PasswordEncryption}\n    */\n    static new(data) {\n        _assertClass(data, COSEEncrypt0);\n        var ret = wasm.passwordencryption_new(data.ptr);\n        return PasswordEncryption.__wrap(ret);\n    }\n}\nmodule.exports.PasswordEncryption = PasswordEncryption;\n/**\n*/\nclass ProtectedHeaderMap {\n\n    static __wrap(ptr) {\n        const obj = Object.create(ProtectedHeaderMap.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_protectedheadermap_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.protectedheadermap_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {ProtectedHeaderMap}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.protectedheadermap_from_bytes(ptr0, len0);\n        return ProtectedHeaderMap.__wrap(ret);\n    }\n    /**\n    * @returns {ProtectedHeaderMap}\n    */\n    static new_empty() {\n        var ret = wasm.protectedheadermap_new_empty();\n        return ProtectedHeaderMap.__wrap(ret);\n    }\n    /**\n    * @param {HeaderMap} header_map\n    * @returns {ProtectedHeaderMap}\n    */\n    static new(header_map) {\n        _assertClass(header_map, HeaderMap);\n        var ret = wasm.protectedheadermap_new(header_map.ptr);\n        return ProtectedHeaderMap.__wrap(ret);\n    }\n    /**\n    * @returns {HeaderMap}\n    */\n    deserialized_headers() {\n        var ret = wasm.protectedheadermap_deserialized_headers(this.ptr);\n        return HeaderMap.__wrap(ret);\n    }\n}\nmodule.exports.ProtectedHeaderMap = ProtectedHeaderMap;\n/**\n*/\nclass PubKeyEncryption {\n\n    static __wrap(ptr) {\n        const obj = Object.create(PubKeyEncryption.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_pubkeyencryption_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.pubkeyencryption_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {PubKeyEncryption}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.pubkeyencryption_from_bytes(ptr0, len0);\n        return PubKeyEncryption.__wrap(ret);\n    }\n    /**\n    * @param {COSEEncrypt} data\n    * @returns {PubKeyEncryption}\n    */\n    static new(data) {\n        _assertClass(data, COSEEncrypt);\n        var ret = wasm.pubkeyencryption_new(data.ptr);\n        return PubKeyEncryption.__wrap(ret);\n    }\n}\nmodule.exports.PubKeyEncryption = PubKeyEncryption;\n/**\n*/\nclass SigStructure {\n\n    static __wrap(ptr) {\n        const obj = Object.create(SigStructure.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_sigstructure_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.sigstructure_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {SigStructure}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.sigstructure_from_bytes(ptr0, len0);\n        return SigStructure.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    context() {\n        var ret = wasm.sigstructure_context(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {ProtectedHeaderMap}\n    */\n    body_protected() {\n        var ret = wasm.sigstructure_body_protected(this.ptr);\n        return ProtectedHeaderMap.__wrap(ret);\n    }\n    /**\n    * @returns {ProtectedHeaderMap | undefined}\n    */\n    sign_protected() {\n        var ret = wasm.sigstructure_sign_protected(this.ptr);\n        return ret === 0 ? undefined : ProtectedHeaderMap.__wrap(ret);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    external_aad() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.sigstructure_external_aad(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    payload() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.sigstructure_payload(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {ProtectedHeaderMap} sign_protected\n    */\n    set_sign_protected(sign_protected) {\n        _assertClass(sign_protected, ProtectedHeaderMap);\n        wasm.sigstructure_set_sign_protected(this.ptr, sign_protected.ptr);\n    }\n    /**\n    * @param {number} context\n    * @param {ProtectedHeaderMap} body_protected\n    * @param {Uint8Array} external_aad\n    * @param {Uint8Array} payload\n    * @returns {SigStructure}\n    */\n    static new(context, body_protected, external_aad, payload) {\n        _assertClass(body_protected, ProtectedHeaderMap);\n        var ptr0 = passArray8ToWasm0(external_aad, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ptr1 = passArray8ToWasm0(payload, wasm.__wbindgen_malloc);\n        var len1 = WASM_VECTOR_LEN;\n        var ret = wasm.sigstructure_new(context, body_protected.ptr, ptr0, len0, ptr1, len1);\n        return SigStructure.__wrap(ret);\n    }\n}\nmodule.exports.SigStructure = SigStructure;\n/**\n*/\nclass SignedMessage {\n\n    static __wrap(ptr) {\n        const obj = Object.create(SignedMessage.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_signedmessage_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.signedmessage_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {SignedMessage}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.signedmessage_from_bytes(ptr0, len0);\n        return SignedMessage.__wrap(ret);\n    }\n    /**\n    * @param {COSESign} cose_sign\n    * @returns {SignedMessage}\n    */\n    static new_cose_sign(cose_sign) {\n        _assertClass(cose_sign, COSESign);\n        var ret = wasm.signedmessage_new_cose_sign(cose_sign.ptr);\n        return SignedMessage.__wrap(ret);\n    }\n    /**\n    * @param {COSESign1} cose_sign1\n    * @returns {SignedMessage}\n    */\n    static new_cose_sign1(cose_sign1) {\n        _assertClass(cose_sign1, COSESign1);\n        var ret = wasm.signedmessage_new_cose_sign1(cose_sign1.ptr);\n        return SignedMessage.__wrap(ret);\n    }\n    /**\n    * @param {string} s\n    * @returns {SignedMessage}\n    */\n    static from_user_facing_encoding(s) {\n        var ptr0 = passStringToWasm0(s, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.signedmessage_from_user_facing_encoding(ptr0, len0);\n        return SignedMessage.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_user_facing_encoding() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.signedmessage_to_user_facing_encoding(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @returns {number}\n    */\n    kind() {\n        var ret = wasm.signedmessage_kind(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {COSESign | undefined}\n    */\n    as_cose_sign() {\n        var ret = wasm.signedmessage_as_cose_sign(this.ptr);\n        return ret === 0 ? undefined : COSESign.__wrap(ret);\n    }\n    /**\n    * @returns {COSESign1 | undefined}\n    */\n    as_cose_sign1() {\n        var ret = wasm.signedmessage_as_cose_sign1(this.ptr);\n        return ret === 0 ? undefined : COSESign1.__wrap(ret);\n    }\n}\nmodule.exports.SignedMessage = SignedMessage;\n/**\n*/\nclass TaggedCBOR {\n\n    static __wrap(ptr) {\n        const obj = Object.create(TaggedCBOR.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_taggedcbor_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.taggedcbor_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {TaggedCBOR}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.taggedcbor_from_bytes(ptr0, len0);\n        return TaggedCBOR.__wrap(ret);\n    }\n    /**\n    * @returns {BigNum}\n    */\n    tag() {\n        var ret = wasm.taggedcbor_tag(this.ptr);\n        return BigNum.__wrap(ret);\n    }\n    /**\n    * @returns {CBORValue}\n    */\n    value() {\n        var ret = wasm.taggedcbor_value(this.ptr);\n        return CBORValue.__wrap(ret);\n    }\n    /**\n    * @param {BigNum} tag\n    * @param {CBORValue} value\n    * @returns {TaggedCBOR}\n    */\n    static new(tag, value) {\n        _assertClass(tag, BigNum);\n        var ptr0 = tag.ptr;\n        tag.ptr = 0;\n        _assertClass(value, CBORValue);\n        var ret = wasm.taggedcbor_new(ptr0, value.ptr);\n        return TaggedCBOR.__wrap(ret);\n    }\n}\nmodule.exports.TaggedCBOR = TaggedCBOR;\n\nmodule.exports.__wbindgen_object_drop_ref = function(arg0) {\n    takeObject(arg0);\n};\n\nmodule.exports.__wbindgen_string_new = function(arg0, arg1) {\n    var ret = getStringFromWasm0(arg0, arg1);\n    return addHeapObject(ret);\n};\n\nmodule.exports.__wbindgen_debug_string = function(arg0, arg1) {\n    var ret = debugString(getObject(arg1));\n    var ptr0 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n    var len0 = WASM_VECTOR_LEN;\n    getInt32Memory0()[arg0 / 4 + 1] = len0;\n    getInt32Memory0()[arg0 / 4 + 0] = ptr0;\n};\n\nmodule.exports.__wbindgen_throw = function(arg0, arg1) {\n    throw new Error(getStringFromWasm0(arg0, arg1));\n};\n\nmodule.exports.__wbindgen_rethrow = function(arg0) {\n    throw takeObject(arg0);\n};\n\nconst path = require('path').join(__dirname, 'emurgo_message_signing_bg.wasm');\nconst bytes = require('fs').readFileSync(path);\n\nconst wasmModule = new WebAssembly.Module(bytes);\nconst wasmInstance = new WebAssembly.Instance(wasmModule, imports);\nwasm = wasmInstance.exports;\nmodule.exports.__wasm = wasm;\n\n","function _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nmodule.exports = _createClass;\nmodule.exports[\"default\"] = module.exports, module.exports.__esModule = true;","function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    module.exports = _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n\n    module.exports[\"default\"] = module.exports, module.exports.__esModule = true;\n  } else {\n    module.exports = _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n\n    module.exports[\"default\"] = module.exports, module.exports.__esModule = true;\n  }\n\n  return _typeof(obj);\n}\n\nmodule.exports = _typeof;\nmodule.exports[\"default\"] = module.exports, module.exports.__esModule = true;","function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nmodule.exports = _classCallCheck;\nmodule.exports[\"default\"] = module.exports, module.exports.__esModule = true;","var $ = require('../internals/export');\nvar toIndexedObject = require('../internals/to-indexed-object');\nvar toLength = require('../internals/to-length');\n\n// `String.raw` method\n// https://tc39.es/ecma262/#sec-string.raw\n$({ target: 'String', stat: true }, {\n  raw: function raw(template) {\n    var rawTemplate = toIndexedObject(template.raw);\n    var literalSegments = toLength(rawTemplate.length);\n    var argumentsLength = arguments.length;\n    var elements = [];\n    var i = 0;\n    while (literalSegments > i) {\n      elements.push(String(rawTemplate[i++]));\n      if (i < argumentsLength) elements.push(String(arguments[i]));\n    } return elements.join('');\n  }\n});\n","// .dirname, .basename, and .extname methods are extracted from Node.js v8.11.1,\n// backported and transplited with Babel, with backwards-compat fixes\n\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// resolves . and .. elements in a path array with directory names there\n// must be no slashes, empty elements, or device names (c:\\) in the array\n// (so also no leading and trailing slashes - it does not distinguish\n// relative and absolute paths)\nfunction normalizeArray(parts, allowAboveRoot) {\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = parts.length - 1; i >= 0; i--) {\n    var last = parts[i];\n    if (last === '.') {\n      parts.splice(i, 1);\n    } else if (last === '..') {\n      parts.splice(i, 1);\n      up++;\n    } else if (up) {\n      parts.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (allowAboveRoot) {\n    for (; up--; up) {\n      parts.unshift('..');\n    }\n  }\n\n  return parts;\n}\n\n// path.resolve([from ...], to)\n// posix version\nexports.resolve = function() {\n  var resolvedPath = '',\n      resolvedAbsolute = false;\n\n  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n    var path = (i >= 0) ? arguments[i] : process.cwd();\n\n    // Skip empty and invalid entries\n    if (typeof path !== 'string') {\n      throw new TypeError('Arguments to path.resolve must be strings');\n    } else if (!path) {\n      continue;\n    }\n\n    resolvedPath = path + '/' + resolvedPath;\n    resolvedAbsolute = path.charAt(0) === '/';\n  }\n\n  // At this point the path should be resolved to a full absolute path, but\n  // handle relative paths to be safe (might happen when process.cwd() fails)\n\n  // Normalize the path\n  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {\n    return !!p;\n  }), !resolvedAbsolute).join('/');\n\n  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\n};\n\n// path.normalize(path)\n// posix version\nexports.normalize = function(path) {\n  var isAbsolute = exports.isAbsolute(path),\n      trailingSlash = substr(path, -1) === '/';\n\n  // Normalize the path\n  path = normalizeArray(filter(path.split('/'), function(p) {\n    return !!p;\n  }), !isAbsolute).join('/');\n\n  if (!path && !isAbsolute) {\n    path = '.';\n  }\n  if (path && trailingSlash) {\n    path += '/';\n  }\n\n  return (isAbsolute ? '/' : '') + path;\n};\n\n// posix version\nexports.isAbsolute = function(path) {\n  return path.charAt(0) === '/';\n};\n\n// posix version\nexports.join = function() {\n  var paths = Array.prototype.slice.call(arguments, 0);\n  return exports.normalize(filter(paths, function(p, index) {\n    if (typeof p !== 'string') {\n      throw new TypeError('Arguments to path.join must be strings');\n    }\n    return p;\n  }).join('/'));\n};\n\n\n// path.relative(from, to)\n// posix version\nexports.relative = function(from, to) {\n  from = exports.resolve(from).substr(1);\n  to = exports.resolve(to).substr(1);\n\n  function trim(arr) {\n    var start = 0;\n    for (; start < arr.length; start++) {\n      if (arr[start] !== '') break;\n    }\n\n    var end = arr.length - 1;\n    for (; end >= 0; end--) {\n      if (arr[end] !== '') break;\n    }\n\n    if (start > end) return [];\n    return arr.slice(start, end - start + 1);\n  }\n\n  var fromParts = trim(from.split('/'));\n  var toParts = trim(to.split('/'));\n\n  var length = Math.min(fromParts.length, toParts.length);\n  var samePartsLength = length;\n  for (var i = 0; i < length; i++) {\n    if (fromParts[i] !== toParts[i]) {\n      samePartsLength = i;\n      break;\n    }\n  }\n\n  var outputParts = [];\n  for (var i = samePartsLength; i < fromParts.length; i++) {\n    outputParts.push('..');\n  }\n\n  outputParts = outputParts.concat(toParts.slice(samePartsLength));\n\n  return outputParts.join('/');\n};\n\nexports.sep = '/';\nexports.delimiter = ':';\n\nexports.dirname = function (path) {\n  if (typeof path !== 'string') path = path + '';\n  if (path.length === 0) return '.';\n  var code = path.charCodeAt(0);\n  var hasRoot = code === 47 /*/*/;\n  var end = -1;\n  var matchedSlash = true;\n  for (var i = path.length - 1; i >= 1; --i) {\n    code = path.charCodeAt(i);\n    if (code === 47 /*/*/) {\n        if (!matchedSlash) {\n          end = i;\n          break;\n        }\n      } else {\n      // We saw the first non-path separator\n      matchedSlash = false;\n    }\n  }\n\n  if (end === -1) return hasRoot ? '/' : '.';\n  if (hasRoot && end === 1) {\n    // return '//';\n    // Backwards-compat fix:\n    return '/';\n  }\n  return path.slice(0, end);\n};\n\nfunction basename(path) {\n  if (typeof path !== 'string') path = path + '';\n\n  var start = 0;\n  var end = -1;\n  var matchedSlash = true;\n  var i;\n\n  for (i = path.length - 1; i >= 0; --i) {\n    if (path.charCodeAt(i) === 47 /*/*/) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string, stop now\n        if (!matchedSlash) {\n          start = i + 1;\n          break;\n        }\n      } else if (end === -1) {\n      // We saw the first non-path separator, mark this as the end of our\n      // path component\n      matchedSlash = false;\n      end = i + 1;\n    }\n  }\n\n  if (end === -1) return '';\n  return path.slice(start, end);\n}\n\n// Uses a mixed approach for backwards-compatibility, as ext behavior changed\n// in new Node.js versions, so only basename() above is backported here\nexports.basename = function (path, ext) {\n  var f = basename(path);\n  if (ext && f.substr(-1 * ext.length) === ext) {\n    f = f.substr(0, f.length - ext.length);\n  }\n  return f;\n};\n\nexports.extname = function (path) {\n  if (typeof path !== 'string') path = path + '';\n  var startDot = -1;\n  var startPart = 0;\n  var end = -1;\n  var matchedSlash = true;\n  // Track the state of characters (if any) we see before our first dot and\n  // after any path separator we find\n  var preDotState = 0;\n  for (var i = path.length - 1; i >= 0; --i) {\n    var code = path.charCodeAt(i);\n    if (code === 47 /*/*/) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string, stop now\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n        continue;\n      }\n    if (end === -1) {\n      // We saw the first non-path separator, mark this as the end of our\n      // extension\n      matchedSlash = false;\n      end = i + 1;\n    }\n    if (code === 46 /*.*/) {\n        // If this is our first dot, mark it as the start of our extension\n        if (startDot === -1)\n          startDot = i;\n        else if (preDotState !== 1)\n          preDotState = 1;\n    } else if (startDot !== -1) {\n      // We saw a non-dot and non-path separator before our dot, so we should\n      // have a good chance at having a non-empty extension\n      preDotState = -1;\n    }\n  }\n\n  if (startDot === -1 || end === -1 ||\n      // We saw a non-dot character immediately before the dot\n      preDotState === 0 ||\n      // The (right-most) trimmed path component is exactly '..'\n      preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n    return '';\n  }\n  return path.slice(startDot, end);\n};\n\nfunction filter (xs, f) {\n    if (xs.filter) return xs.filter(f);\n    var res = [];\n    for (var i = 0; i < xs.length; i++) {\n        if (f(xs[i], i, xs)) res.push(xs[i]);\n    }\n    return res;\n}\n\n// String.prototype.substr - negative index don't work in IE8\nvar substr = 'ab'.substr(-1) === 'b'\n    ? function (str, start, len) { return str.substr(start, len) }\n    : function (str, start, len) {\n        if (start < 0) start = str.length + start;\n        return str.substr(start, len);\n    }\n;\n"],"sourceRoot":""}