{"version":3,"sources":["webpack://web3-cardano-token/./temporary_modules/@emurgo/cardano-serialization-lib-browser/cardano_serialization_lib_bg.js","webpack://web3-cardano-token/./temporary_modules/@emurgo/cardano-serialization-lib-browser sync","webpack://web3-cardano-token/./node_modules/@babel/runtime/helpers/esm/typeof.js","webpack://web3-cardano-token/./temporary_modules/@emurgo/cardano-serialization-lib-browser/cardano_serialization_lib.js","webpack://web3-cardano-token/(webpack)/buildin/harmony-module.js","webpack://web3-cardano-token/./node_modules/core-js/modules/es.typed-array.uint32-array.js"],"names":["heap","Array","fill","undefined","getObject","idx","push","heap_next","length","dropObject","takeObject","ret","lTextDecoder","TextDecoder","module","require","cachedTextDecoder","ignoreBOM","fatal","decode","cachegetUint8Memory0","getUint8Memory0","buffer","wasm","Uint8Array","getStringFromWasm0","ptr","len","subarray","addHeapObject","obj","WASM_VECTOR_LEN","lTextEncoder","TextEncoder","cachedTextEncoder","encodeString","encodeInto","arg","view","buf","encode","set","read","written","passStringToWasm0","malloc","realloc","mem","offset","code","charCodeAt","slice","isLikeNone","x","cachegetInt32Memory0","getInt32Memory0","Int32Array","debugString","val","type","description","name","isArray","debug","i","className","builtInMatches","exec","toString","call","JSON","stringify","_","Error","message","stack","getArrayU8FromWasm0","passArray8ToWasm0","_assertClass","instance","klass","cachegetUint32Memory0","getUint32Memory0","Uint32Array","getArrayU32FromWasm0","passArray32ToWasm0","encode_arbitrary_bytes_as_metadatum","bytes","ptr0","len0","TransactionMetadatum","__wrap","decode_arbitrary_bytes_from_metadatum","metadata","retptr","r0","r1","v0","encode_json_str_to_metadatum","json","schema","decode_metadatum_to_json_str","metadatum","encrypt_with_password","password","salt","nonce","data","ptr1","len1","ptr2","len2","ptr3","len3","decrypt_with_password","make_daedalus_bootstrap_witness","tx_body_hash","addr","key","TransactionHash","ByronAddress","LegacyDaedalusPrivateKey","BootstrapWitness","make_icarus_bootstrap_witness","Bip32PrivateKey","make_vkey_witness","sk","PrivateKey","Vkeywitness","hash_auxiliary_data","auxiliary_data","AuxiliaryData","AuxiliaryDataHash","hash_transaction","tx_body","TransactionBody","hash_plutus_data","plutus_data","PlutusData","DataHash","hash_script_data","redeemers","cost_models","datums","Redeemers","Costmdls","PlutusList","ScriptDataHash","get_implicit_input","txbody","pool_deposit","key_deposit","BigNum","Value","get_deposit","min_ada_required","assets","has_data_hash","coins_per_utxo_word","encode_json_str_to_native_script","self_xpub","NativeScript","min_fee","tx","linear_fee","Transaction","LinearFee","CertificateKind","Object","freeze","StakeRegistration","StakeDeregistration","StakeDelegation","PoolRegistration","PoolRetirement","GenesisKeyDelegation","MoveInstantaneousRewardsCert","MIRPot","Reserves","Treasury","MIRKind","ToOtherPot","ToStakeCredentials","RelayKind","SingleHostAddr","SingleHostName","MultiHostName","NativeScriptKind","ScriptPubkey","ScriptAll","ScriptAny","ScriptNOfK","TimelockStart","TimelockExpiry","ScriptHashNamespace","NetworkIdKind","Testnet","Mainnet","TransactionMetadatumKind","MetadataMap","MetadataList","Int","Bytes","Text","MetadataJsonSchema","NoConversions","BasicConversions","DetailedSchema","ScriptSchema","Wallet","Node","StakeCredKind","Key","Script","LanguageKind","PlutusV1","PlutusDataKind","ConstrPlutusData","Map","List","Integer","RedeemerTagKind","Spend","Mint","Cert","Reward","Address","this","__destroy_into_raw","prefix","create","prototype","bech_str","AssetName","AssetNames","index","elem","Assets","value","GeneralTransactionMetadata","NativeScripts","native_scripts","PlutusScripts","plutus_scripts","AuxiliaryDataSet","tx_index","BaseAddress","StakeCredential","network","payment","stake","BigInt","text","other","rhs_value","string","Bip32PublicKey","bech32_str","entropy","PublicKey","Block","Header","TransactionBodies","TransactionWitnessSets","header","transaction_bodies","transaction_witness_sets","auxiliary_data_set","invalid_transactions","BlockHash","Vkey","Ed25519Signature","vkey","signature","chain_code","attributes","BootstrapWitnesses","s","protocol_magic","Certificate","stake_registration","stake_deregistration","stake_delegation","pool_registration","pool_retirement","genesis_key_delegation","move_instantaneous_rewards_cert","Certificates","tag","CostModel","operation","cost","Language","Languages","DNSRecordAorAAAA","dns_name","DNSRecordSRV","Ed25519KeyHash","Ed25519KeyHashes","input","EnterpriseAddress","ExUnitPrices","UnitInterval","mem_price","step_price","ExUnits","steps","TransactionMetadatumLabels","GenesisDelegateHash","GenesisHash","GenesisHashes","VRFKeyHash","genesishash","genesis_delegate_hash","vrf_keyhash","HeaderBody","KESSignature","header_body","body_signature","VRFVKey","VRFCert","OperationalCert","ProtocolVersion","block_number","slot","prev_hash","issuer_vkey","vrf_vkey","nonce_vrf","leader_vrf","block_body_size","block_body_hash","operational_cert","protocol_version","Ipv4","Ipv6","KESVKey","coefficient","constant","MIRToStakeCredentials","cred","delta","StakeCredentials","ScriptHash","MintAssets","ScriptHashes","MoveInstantaneousReward","pot","amount","amounts","move_instantaneous_reward","MultiAsset","rhs_ma","namespace","script_pubkey","script_all","script_any","script_n_of_k","timelock_start","timelock_expiry","NetworkId","NetworkInfo","network_id","Nonce","hash","hot_vkey","sequence_number","kes_period","sigma","PlutusMap","constr_plutus_data","map","list","integer","PlutusScript","Pointer","cert_index","PointerAddress","PoolMetadata","URL","PoolMetadataHash","url","pool_metadata_hash","PoolParams","RewardAddress","Relays","operator","pledge","margin","reward_account","pool_owners","relays","pool_metadata","pool_params","pool_keyhash","epoch","ProposedProtocolParameterUpdates","ProtocolParamUpdate","minfee_a","minfee_b","max_block_body_size","max_tx_size","max_block_header_size","max_epoch","n_opt","pool_pledge_influence","expansion_rate","treasury_growth_rate","d","extra_entropy","ProtocolVersions","min_pool_cost","ada_per_utxo_byte","execution_costs","max_tx_ex_units","max_block_ex_units","max_value_size","major","minor","PublicKeys","Redeemer","RedeemerTag","ex_units","Relay","single_host_addr","single_host_name","multi_host_name","RewardAddresses","n","addr_keyhash","port","ipv4","ipv6","stake_credential","Strings","TransactionWitnessSet","valid","body","witness_set","TransactionInputs","TransactionOutputs","certs","withdrawals","Withdrawals","update","Update","auxiliary_data_hash","validity_start_interval","mint","script_data_hash","collateral","required_signers","inputs","outputs","fee","ttl","TransactionBuilder","TransactionInput","address","output","TransactionOutput","prefer_pure_change","transaction_id","int","data_hash","TransactionUnspentOutput","vkeys","Vkeywitnesses","bootstraps","numerator","denominator","proposed_protocol_parameter_updates","proof","coin","multiasset","rhs","pk","Vkeys","__wbindgen_object_drop_ref","arg0","__wbindgen_string_new","arg1","__wbg_new_3a746f2619705add","Function","__wbg_call_f54d3a6dadb199ca","__wbindgen_jsval_eq","__wbg_self_ac379e780a0d8b94","self","__wbg_crypto_1e4302b85d4f64a2","crypto","__wbindgen_is_undefined","__wbg_getRandomValues_1b4ba144162a5c9e","getRandomValues","__wbg_require_6461b1e9a0d7c34a","__wbg_getRandomValues_1ef11e888e5228e9","arg2","__wbg_randomFillSync_1b52c8482374c55b","randomFillSync","__wbindgen_string_get","__wbindgen_debug_string","__wbindgen_throw","__wbindgen_rethrow","webpackEmptyContext","req","e","keys","resolve","exports","id","_typeof","Symbol","iterator","constructor","originalModule","webpackPolyfill","children","defineProperty","enumerable","get","l","createTypedArrayConstructor","init","byteOffset"],"mappings":"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","file":"web3-cardano-token.umd.min.4.js","sourcesContent":["import * as wasm from './cardano_serialization_lib_bg.wasm';\n\nconst heap = new Array(32).fill(undefined);\n\nheap.push(undefined, null, true, false);\n\nfunction getObject(idx) { return heap[idx]; }\n\nlet heap_next = heap.length;\n\nfunction dropObject(idx) {\n    if (idx < 36) return;\n    heap[idx] = heap_next;\n    heap_next = idx;\n}\n\nfunction takeObject(idx) {\n    const ret = getObject(idx);\n    dropObject(idx);\n    return ret;\n}\n\nconst lTextDecoder = typeof TextDecoder === 'undefined' ? (0, module.require)('util').TextDecoder : TextDecoder;\n\nlet cachedTextDecoder = new lTextDecoder('utf-8', { ignoreBOM: true, fatal: true });\n\ncachedTextDecoder.decode();\n\nlet cachegetUint8Memory0 = null;\nfunction getUint8Memory0() {\n    if (cachegetUint8Memory0 === null || cachegetUint8Memory0.buffer !== wasm.memory.buffer) {\n        cachegetUint8Memory0 = new Uint8Array(wasm.memory.buffer);\n    }\n    return cachegetUint8Memory0;\n}\n\nfunction getStringFromWasm0(ptr, len) {\n    return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len));\n}\n\nfunction addHeapObject(obj) {\n    if (heap_next === heap.length) heap.push(heap.length + 1);\n    const idx = heap_next;\n    heap_next = heap[idx];\n\n    heap[idx] = obj;\n    return idx;\n}\n\nlet WASM_VECTOR_LEN = 0;\n\nconst lTextEncoder = typeof TextEncoder === 'undefined' ? (0, module.require)('util').TextEncoder : TextEncoder;\n\nlet cachedTextEncoder = new lTextEncoder('utf-8');\n\nconst encodeString = (typeof cachedTextEncoder.encodeInto === 'function'\n    ? function (arg, view) {\n    return cachedTextEncoder.encodeInto(arg, view);\n}\n    : function (arg, view) {\n    const buf = cachedTextEncoder.encode(arg);\n    view.set(buf);\n    return {\n        read: arg.length,\n        written: buf.length\n    };\n});\n\nfunction passStringToWasm0(arg, malloc, realloc) {\n\n    if (realloc === undefined) {\n        const buf = cachedTextEncoder.encode(arg);\n        const ptr = malloc(buf.length);\n        getUint8Memory0().subarray(ptr, ptr + buf.length).set(buf);\n        WASM_VECTOR_LEN = buf.length;\n        return ptr;\n    }\n\n    let len = arg.length;\n    let ptr = malloc(len);\n\n    const mem = getUint8Memory0();\n\n    let offset = 0;\n\n    for (; offset < len; offset++) {\n        const code = arg.charCodeAt(offset);\n        if (code > 0x7F) break;\n        mem[ptr + offset] = code;\n    }\n\n    if (offset !== len) {\n        if (offset !== 0) {\n            arg = arg.slice(offset);\n        }\n        ptr = realloc(ptr, len, len = offset + arg.length * 3);\n        const view = getUint8Memory0().subarray(ptr + offset, ptr + len);\n        const ret = encodeString(arg, view);\n\n        offset += ret.written;\n    }\n\n    WASM_VECTOR_LEN = offset;\n    return ptr;\n}\n\nfunction isLikeNone(x) {\n    return x === undefined || x === null;\n}\n\nlet cachegetInt32Memory0 = null;\nfunction getInt32Memory0() {\n    if (cachegetInt32Memory0 === null || cachegetInt32Memory0.buffer !== wasm.memory.buffer) {\n        cachegetInt32Memory0 = new Int32Array(wasm.memory.buffer);\n    }\n    return cachegetInt32Memory0;\n}\n\nfunction debugString(val) {\n    // primitive types\n    const type = typeof val;\n    if (type == 'number' || type == 'boolean' || val == null) {\n        return  `${val}`;\n    }\n    if (type == 'string') {\n        return `\"${val}\"`;\n    }\n    if (type == 'symbol') {\n        const description = val.description;\n        if (description == null) {\n            return 'Symbol';\n        } else {\n            return `Symbol(${description})`;\n        }\n    }\n    if (type == 'function') {\n        const name = val.name;\n        if (typeof name == 'string' && name.length > 0) {\n            return `Function(${name})`;\n        } else {\n            return 'Function';\n        }\n    }\n    // objects\n    if (Array.isArray(val)) {\n        const length = val.length;\n        let debug = '[';\n        if (length > 0) {\n            debug += debugString(val[0]);\n        }\n        for(let i = 1; i < length; i++) {\n            debug += ', ' + debugString(val[i]);\n        }\n        debug += ']';\n        return debug;\n    }\n    // Test for built-in\n    const builtInMatches = /\\[object ([^\\]]+)\\]/.exec(toString.call(val));\n    let className;\n    if (builtInMatches.length > 1) {\n        className = builtInMatches[1];\n    } else {\n        // Failed to match the standard '[object ClassName]'\n        return toString.call(val);\n    }\n    if (className == 'Object') {\n        // we're a user defined class or Object\n        // JSON.stringify avoids problems with cycles, and is generally much\n        // easier than looping through ownProperties of `val`.\n        try {\n            return 'Object(' + JSON.stringify(val) + ')';\n        } catch (_) {\n            return 'Object';\n        }\n    }\n    // errors\n    if (val instanceof Error) {\n        return `${val.name}: ${val.message}\\n${val.stack}`;\n    }\n    // TODO we could test for more things here, like `Set`s and `Map`s.\n    return className;\n}\n\nfunction getArrayU8FromWasm0(ptr, len) {\n    return getUint8Memory0().subarray(ptr / 1, ptr / 1 + len);\n}\n\nfunction passArray8ToWasm0(arg, malloc) {\n    const ptr = malloc(arg.length * 1);\n    getUint8Memory0().set(arg, ptr / 1);\n    WASM_VECTOR_LEN = arg.length;\n    return ptr;\n}\n\nfunction _assertClass(instance, klass) {\n    if (!(instance instanceof klass)) {\n        throw new Error(`expected instance of ${klass.name}`);\n    }\n    return instance.ptr;\n}\n\nlet cachegetUint32Memory0 = null;\nfunction getUint32Memory0() {\n    if (cachegetUint32Memory0 === null || cachegetUint32Memory0.buffer !== wasm.memory.buffer) {\n        cachegetUint32Memory0 = new Uint32Array(wasm.memory.buffer);\n    }\n    return cachegetUint32Memory0;\n}\n\nfunction getArrayU32FromWasm0(ptr, len) {\n    return getUint32Memory0().subarray(ptr / 4, ptr / 4 + len);\n}\n\nfunction passArray32ToWasm0(arg, malloc) {\n    const ptr = malloc(arg.length * 4);\n    getUint32Memory0().set(arg, ptr / 4);\n    WASM_VECTOR_LEN = arg.length;\n    return ptr;\n}\n/**\n* @param {Uint8Array} bytes\n* @returns {TransactionMetadatum}\n*/\nexport function encode_arbitrary_bytes_as_metadatum(bytes) {\n    var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n    var len0 = WASM_VECTOR_LEN;\n    var ret = wasm.encode_arbitrary_bytes_as_metadatum(ptr0, len0);\n    return TransactionMetadatum.__wrap(ret);\n}\n\n/**\n* @param {TransactionMetadatum} metadata\n* @returns {Uint8Array}\n*/\nexport function decode_arbitrary_bytes_from_metadatum(metadata) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        _assertClass(metadata, TransactionMetadatum);\n        wasm.decode_arbitrary_bytes_from_metadatum(retptr, metadata.ptr);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var v0 = getArrayU8FromWasm0(r0, r1).slice();\n        wasm.__wbindgen_free(r0, r1 * 1);\n        return v0;\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\n/**\n* @param {string} json\n* @param {number} schema\n* @returns {TransactionMetadatum}\n*/\nexport function encode_json_str_to_metadatum(json, schema) {\n    var ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n    var len0 = WASM_VECTOR_LEN;\n    var ret = wasm.encode_json_str_to_metadatum(ptr0, len0, schema);\n    return TransactionMetadatum.__wrap(ret);\n}\n\n/**\n* @param {TransactionMetadatum} metadatum\n* @param {number} schema\n* @returns {string}\n*/\nexport function decode_metadatum_to_json_str(metadatum, schema) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        _assertClass(metadatum, TransactionMetadatum);\n        wasm.decode_metadatum_to_json_str(retptr, metadatum.ptr, schema);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        return getStringFromWasm0(r0, r1);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n        wasm.__wbindgen_free(r0, r1);\n    }\n}\n\n/**\n* @param {string} password\n* @param {string} salt\n* @param {string} nonce\n* @param {string} data\n* @returns {string}\n*/\nexport function encrypt_with_password(password, salt, nonce, data) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        var ptr0 = passStringToWasm0(password, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ptr1 = passStringToWasm0(salt, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len1 = WASM_VECTOR_LEN;\n        var ptr2 = passStringToWasm0(nonce, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len2 = WASM_VECTOR_LEN;\n        var ptr3 = passStringToWasm0(data, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len3 = WASM_VECTOR_LEN;\n        wasm.encrypt_with_password(retptr, ptr0, len0, ptr1, len1, ptr2, len2, ptr3, len3);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        return getStringFromWasm0(r0, r1);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n        wasm.__wbindgen_free(r0, r1);\n    }\n}\n\n/**\n* @param {string} password\n* @param {string} data\n* @returns {string}\n*/\nexport function decrypt_with_password(password, data) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        var ptr0 = passStringToWasm0(password, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ptr1 = passStringToWasm0(data, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len1 = WASM_VECTOR_LEN;\n        wasm.decrypt_with_password(retptr, ptr0, len0, ptr1, len1);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        return getStringFromWasm0(r0, r1);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n        wasm.__wbindgen_free(r0, r1);\n    }\n}\n\n/**\n* @param {TransactionHash} tx_body_hash\n* @param {ByronAddress} addr\n* @param {LegacyDaedalusPrivateKey} key\n* @returns {BootstrapWitness}\n*/\nexport function make_daedalus_bootstrap_witness(tx_body_hash, addr, key) {\n    _assertClass(tx_body_hash, TransactionHash);\n    _assertClass(addr, ByronAddress);\n    _assertClass(key, LegacyDaedalusPrivateKey);\n    var ret = wasm.make_daedalus_bootstrap_witness(tx_body_hash.ptr, addr.ptr, key.ptr);\n    return BootstrapWitness.__wrap(ret);\n}\n\n/**\n* @param {TransactionHash} tx_body_hash\n* @param {ByronAddress} addr\n* @param {Bip32PrivateKey} key\n* @returns {BootstrapWitness}\n*/\nexport function make_icarus_bootstrap_witness(tx_body_hash, addr, key) {\n    _assertClass(tx_body_hash, TransactionHash);\n    _assertClass(addr, ByronAddress);\n    _assertClass(key, Bip32PrivateKey);\n    var ret = wasm.make_icarus_bootstrap_witness(tx_body_hash.ptr, addr.ptr, key.ptr);\n    return BootstrapWitness.__wrap(ret);\n}\n\n/**\n* @param {TransactionHash} tx_body_hash\n* @param {PrivateKey} sk\n* @returns {Vkeywitness}\n*/\nexport function make_vkey_witness(tx_body_hash, sk) {\n    _assertClass(tx_body_hash, TransactionHash);\n    _assertClass(sk, PrivateKey);\n    var ret = wasm.make_vkey_witness(tx_body_hash.ptr, sk.ptr);\n    return Vkeywitness.__wrap(ret);\n}\n\n/**\n* @param {AuxiliaryData} auxiliary_data\n* @returns {AuxiliaryDataHash}\n*/\nexport function hash_auxiliary_data(auxiliary_data) {\n    _assertClass(auxiliary_data, AuxiliaryData);\n    var ret = wasm.hash_auxiliary_data(auxiliary_data.ptr);\n    return AuxiliaryDataHash.__wrap(ret);\n}\n\n/**\n* @param {TransactionBody} tx_body\n* @returns {TransactionHash}\n*/\nexport function hash_transaction(tx_body) {\n    _assertClass(tx_body, TransactionBody);\n    var ret = wasm.hash_transaction(tx_body.ptr);\n    return TransactionHash.__wrap(ret);\n}\n\n/**\n* @param {PlutusData} plutus_data\n* @returns {DataHash}\n*/\nexport function hash_plutus_data(plutus_data) {\n    _assertClass(plutus_data, PlutusData);\n    var ret = wasm.hash_plutus_data(plutus_data.ptr);\n    return DataHash.__wrap(ret);\n}\n\n/**\n* @param {Redeemers} redeemers\n* @param {Costmdls} cost_models\n* @param {PlutusList | undefined} datums\n* @returns {ScriptDataHash}\n*/\nexport function hash_script_data(redeemers, cost_models, datums) {\n    _assertClass(redeemers, Redeemers);\n    _assertClass(cost_models, Costmdls);\n    let ptr0 = 0;\n    if (!isLikeNone(datums)) {\n        _assertClass(datums, PlutusList);\n        ptr0 = datums.ptr;\n        datums.ptr = 0;\n    }\n    var ret = wasm.hash_script_data(redeemers.ptr, cost_models.ptr, ptr0);\n    return ScriptDataHash.__wrap(ret);\n}\n\n/**\n* @param {TransactionBody} txbody\n* @param {BigNum} pool_deposit\n* @param {BigNum} key_deposit\n* @returns {Value}\n*/\nexport function get_implicit_input(txbody, pool_deposit, key_deposit) {\n    _assertClass(txbody, TransactionBody);\n    _assertClass(pool_deposit, BigNum);\n    _assertClass(key_deposit, BigNum);\n    var ret = wasm.get_implicit_input(txbody.ptr, pool_deposit.ptr, key_deposit.ptr);\n    return Value.__wrap(ret);\n}\n\n/**\n* @param {TransactionBody} txbody\n* @param {BigNum} pool_deposit\n* @param {BigNum} key_deposit\n* @returns {BigNum}\n*/\nexport function get_deposit(txbody, pool_deposit, key_deposit) {\n    _assertClass(txbody, TransactionBody);\n    _assertClass(pool_deposit, BigNum);\n    _assertClass(key_deposit, BigNum);\n    var ret = wasm.get_deposit(txbody.ptr, pool_deposit.ptr, key_deposit.ptr);\n    return BigNum.__wrap(ret);\n}\n\n/**\n* @param {Value} assets\n* @param {boolean} has_data_hash\n* @param {BigNum} coins_per_utxo_word\n* @returns {BigNum}\n*/\nexport function min_ada_required(assets, has_data_hash, coins_per_utxo_word) {\n    _assertClass(assets, Value);\n    _assertClass(coins_per_utxo_word, BigNum);\n    var ret = wasm.min_ada_required(assets.ptr, has_data_hash, coins_per_utxo_word.ptr);\n    return BigNum.__wrap(ret);\n}\n\n/**\n* Receives a script JSON string\n* and returns a NativeScript.\n* Cardano Wallet and Node styles are supported.\n*\n* * wallet: https://github.com/input-output-hk/cardano-wallet/blob/master/specifications/api/swagger.yaml\n* * node: https://github.com/input-output-hk/cardano-node/blob/master/doc/reference/simple-scripts.md\n*\n* self_xpub is expected to be a Bip32PublicKey as hex-encoded bytes\n* @param {string} json\n* @param {string} self_xpub\n* @param {number} schema\n* @returns {NativeScript}\n*/\nexport function encode_json_str_to_native_script(json, self_xpub, schema) {\n    var ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n    var len0 = WASM_VECTOR_LEN;\n    var ptr1 = passStringToWasm0(self_xpub, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n    var len1 = WASM_VECTOR_LEN;\n    var ret = wasm.encode_json_str_to_native_script(ptr0, len0, ptr1, len1, schema);\n    return NativeScript.__wrap(ret);\n}\n\n/**\n* @param {Transaction} tx\n* @param {LinearFee} linear_fee\n* @returns {BigNum}\n*/\nexport function min_fee(tx, linear_fee) {\n    _assertClass(tx, Transaction);\n    _assertClass(linear_fee, LinearFee);\n    var ret = wasm.min_fee(tx.ptr, linear_fee.ptr);\n    return BigNum.__wrap(ret);\n}\n\n/**\n*/\nexport const CertificateKind = Object.freeze({ StakeRegistration:0,\"0\":\"StakeRegistration\",StakeDeregistration:1,\"1\":\"StakeDeregistration\",StakeDelegation:2,\"2\":\"StakeDelegation\",PoolRegistration:3,\"3\":\"PoolRegistration\",PoolRetirement:4,\"4\":\"PoolRetirement\",GenesisKeyDelegation:5,\"5\":\"GenesisKeyDelegation\",MoveInstantaneousRewardsCert:6,\"6\":\"MoveInstantaneousRewardsCert\", });\n/**\n*/\nexport const MIRPot = Object.freeze({ Reserves:0,\"0\":\"Reserves\",Treasury:1,\"1\":\"Treasury\", });\n/**\n*/\nexport const MIRKind = Object.freeze({ ToOtherPot:0,\"0\":\"ToOtherPot\",ToStakeCredentials:1,\"1\":\"ToStakeCredentials\", });\n/**\n*/\nexport const RelayKind = Object.freeze({ SingleHostAddr:0,\"0\":\"SingleHostAddr\",SingleHostName:1,\"1\":\"SingleHostName\",MultiHostName:2,\"2\":\"MultiHostName\", });\n/**\n*/\nexport const NativeScriptKind = Object.freeze({ ScriptPubkey:0,\"0\":\"ScriptPubkey\",ScriptAll:1,\"1\":\"ScriptAll\",ScriptAny:2,\"2\":\"ScriptAny\",ScriptNOfK:3,\"3\":\"ScriptNOfK\",TimelockStart:4,\"4\":\"TimelockStart\",TimelockExpiry:5,\"5\":\"TimelockExpiry\", });\n/**\n* Each new language uses a different namespace for hashing its script\n* This is because you could have a language where the same bytes have different semantics\n* So this avoids scripts in different languages mapping to the same hash\n* Note that the enum value here is different than the enum value for deciding the cost model of a script\n*/\nexport const ScriptHashNamespace = Object.freeze({ NativeScript:0,\"0\":\"NativeScript\", });\n/**\n*/\nexport const NetworkIdKind = Object.freeze({ Testnet:0,\"0\":\"Testnet\",Mainnet:1,\"1\":\"Mainnet\", });\n/**\n*/\nexport const TransactionMetadatumKind = Object.freeze({ MetadataMap:0,\"0\":\"MetadataMap\",MetadataList:1,\"1\":\"MetadataList\",Int:2,\"2\":\"Int\",Bytes:3,\"3\":\"Bytes\",Text:4,\"4\":\"Text\", });\n/**\n*/\nexport const MetadataJsonSchema = Object.freeze({ NoConversions:0,\"0\":\"NoConversions\",BasicConversions:1,\"1\":\"BasicConversions\",DetailedSchema:2,\"2\":\"DetailedSchema\", });\n/**\n* Used to choosed the schema for a script JSON string\n*/\nexport const ScriptSchema = Object.freeze({ Wallet:0,\"0\":\"Wallet\",Node:1,\"1\":\"Node\", });\n/**\n*/\nexport const StakeCredKind = Object.freeze({ Key:0,\"0\":\"Key\",Script:1,\"1\":\"Script\", });\n/**\n*/\nexport const LanguageKind = Object.freeze({ PlutusV1:0,\"0\":\"PlutusV1\", });\n/**\n*/\nexport const PlutusDataKind = Object.freeze({ ConstrPlutusData:0,\"0\":\"ConstrPlutusData\",Map:1,\"1\":\"Map\",List:2,\"2\":\"List\",Integer:3,\"3\":\"Integer\",Bytes:4,\"4\":\"Bytes\", });\n/**\n*/\nexport const RedeemerTagKind = Object.freeze({ Spend:0,\"0\":\"Spend\",Mint:1,\"1\":\"Mint\",Cert:2,\"2\":\"Cert\",Reward:3,\"3\":\"Reward\", });\n/**\n*/\nexport class Address {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Address.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_address_free(ptr);\n    }\n    /**\n    * @param {Uint8Array} data\n    * @returns {Address}\n    */\n    static from_bytes(data) {\n        var ptr0 = passArray8ToWasm0(data, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.address_from_bytes(ptr0, len0);\n        return Address.__wrap(ret);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.address_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string | undefined} prefix\n    * @returns {string}\n    */\n    to_bech32(prefix) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = isLikeNone(prefix) ? 0 : passStringToWasm0(prefix, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.address_to_bech32(retptr, this.ptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} bech_str\n    * @returns {Address}\n    */\n    static from_bech32(bech_str) {\n        var ptr0 = passStringToWasm0(bech_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.address_from_bech32(ptr0, len0);\n        return Address.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    network_id() {\n        var ret = wasm.address_network_id(this.ptr);\n        return ret;\n    }\n}\n/**\n*/\nexport class AssetName {\n\n    static __wrap(ptr) {\n        const obj = Object.create(AssetName.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_assetname_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.assetname_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {AssetName}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.assetname_from_bytes(ptr0, len0);\n        return AssetName.__wrap(ret);\n    }\n    /**\n    * @param {Uint8Array} name\n    * @returns {AssetName}\n    */\n    static new(name) {\n        var ptr0 = passArray8ToWasm0(name, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.assetname_new(ptr0, len0);\n        return AssetName.__wrap(ret);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    name() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.assetname_name(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n*/\nexport class AssetNames {\n\n    static __wrap(ptr) {\n        const obj = Object.create(AssetNames.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_assetnames_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.assetnames_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {AssetNames}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.assetnames_from_bytes(ptr0, len0);\n        return AssetNames.__wrap(ret);\n    }\n    /**\n    * @returns {AssetNames}\n    */\n    static new() {\n        var ret = wasm.assetnames_new();\n        return AssetNames.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.assetnames_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} index\n    * @returns {AssetName}\n    */\n    get(index) {\n        var ret = wasm.assetnames_get(this.ptr, index);\n        return AssetName.__wrap(ret);\n    }\n    /**\n    * @param {AssetName} elem\n    */\n    add(elem) {\n        _assertClass(elem, AssetName);\n        wasm.assetnames_add(this.ptr, elem.ptr);\n    }\n}\n/**\n*/\nexport class Assets {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Assets.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_assets_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.assets_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {Assets}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.assets_from_bytes(ptr0, len0);\n        return Assets.__wrap(ret);\n    }\n    /**\n    * @returns {Assets}\n    */\n    static new() {\n        var ret = wasm.assets_new();\n        return Assets.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.assets_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {AssetName} key\n    * @param {BigNum} value\n    * @returns {BigNum | undefined}\n    */\n    insert(key, value) {\n        _assertClass(key, AssetName);\n        _assertClass(value, BigNum);\n        var ret = wasm.assets_insert(this.ptr, key.ptr, value.ptr);\n        return ret === 0 ? undefined : BigNum.__wrap(ret);\n    }\n    /**\n    * @param {AssetName} key\n    * @returns {BigNum | undefined}\n    */\n    get(key) {\n        _assertClass(key, AssetName);\n        var ret = wasm.assets_get(this.ptr, key.ptr);\n        return ret === 0 ? undefined : BigNum.__wrap(ret);\n    }\n    /**\n    * @returns {AssetNames}\n    */\n    keys() {\n        var ret = wasm.assets_keys(this.ptr);\n        return AssetNames.__wrap(ret);\n    }\n}\n/**\n*/\nexport class AuxiliaryData {\n\n    static __wrap(ptr) {\n        const obj = Object.create(AuxiliaryData.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_auxiliarydata_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.auxiliarydata_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {AuxiliaryData}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.auxiliarydata_from_bytes(ptr0, len0);\n        return AuxiliaryData.__wrap(ret);\n    }\n    /**\n    * @returns {AuxiliaryData}\n    */\n    static new() {\n        var ret = wasm.auxiliarydata_new();\n        return AuxiliaryData.__wrap(ret);\n    }\n    /**\n    * @returns {GeneralTransactionMetadata | undefined}\n    */\n    metadata() {\n        var ret = wasm.auxiliarydata_metadata(this.ptr);\n        return ret === 0 ? undefined : GeneralTransactionMetadata.__wrap(ret);\n    }\n    /**\n    * @param {GeneralTransactionMetadata} metadata\n    */\n    set_metadata(metadata) {\n        _assertClass(metadata, GeneralTransactionMetadata);\n        wasm.auxiliarydata_set_metadata(this.ptr, metadata.ptr);\n    }\n    /**\n    * @returns {NativeScripts | undefined}\n    */\n    native_scripts() {\n        var ret = wasm.auxiliarydata_native_scripts(this.ptr);\n        return ret === 0 ? undefined : NativeScripts.__wrap(ret);\n    }\n    /**\n    * @param {NativeScripts} native_scripts\n    */\n    set_native_scripts(native_scripts) {\n        _assertClass(native_scripts, NativeScripts);\n        wasm.auxiliarydata_set_native_scripts(this.ptr, native_scripts.ptr);\n    }\n    /**\n    * @returns {PlutusScripts | undefined}\n    */\n    plutus_scripts() {\n        var ret = wasm.auxiliarydata_plutus_scripts(this.ptr);\n        return ret === 0 ? undefined : PlutusScripts.__wrap(ret);\n    }\n    /**\n    * @param {PlutusScripts} plutus_scripts\n    */\n    set_plutus_scripts(plutus_scripts) {\n        _assertClass(plutus_scripts, PlutusScripts);\n        wasm.auxiliarydata_set_plutus_scripts(this.ptr, plutus_scripts.ptr);\n    }\n}\n/**\n*/\nexport class AuxiliaryDataHash {\n\n    static __wrap(ptr) {\n        const obj = Object.create(AuxiliaryDataHash.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_auxiliarydatahash_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.auxiliarydatahash_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} prefix\n    * @returns {string}\n    */\n    to_bech32(prefix) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passStringToWasm0(prefix, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.auxiliarydatahash_to_bech32(retptr, this.ptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} bech_str\n    * @returns {AuxiliaryDataHash}\n    */\n    static from_bech32(bech_str) {\n        var ptr0 = passStringToWasm0(bech_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.auxiliarydatahash_from_bech32(ptr0, len0);\n        return AuxiliaryDataHash.__wrap(ret);\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {AuxiliaryDataHash}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.auxiliarydatahash_from_bytes(ptr0, len0);\n        return AuxiliaryDataHash.__wrap(ret);\n    }\n}\n/**\n*/\nexport class AuxiliaryDataSet {\n\n    static __wrap(ptr) {\n        const obj = Object.create(AuxiliaryDataSet.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_auxiliarydataset_free(ptr);\n    }\n    /**\n    * @returns {AuxiliaryDataSet}\n    */\n    static new() {\n        var ret = wasm.auxiliarydataset_new();\n        return AuxiliaryDataSet.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.auxiliarydataset_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} tx_index\n    * @param {AuxiliaryData} data\n    * @returns {AuxiliaryData | undefined}\n    */\n    insert(tx_index, data) {\n        _assertClass(data, AuxiliaryData);\n        var ret = wasm.auxiliarydataset_insert(this.ptr, tx_index, data.ptr);\n        return ret === 0 ? undefined : AuxiliaryData.__wrap(ret);\n    }\n    /**\n    * @param {number} tx_index\n    * @returns {AuxiliaryData | undefined}\n    */\n    get(tx_index) {\n        var ret = wasm.auxiliarydataset_get(this.ptr, tx_index);\n        return ret === 0 ? undefined : AuxiliaryData.__wrap(ret);\n    }\n    /**\n    * @returns {Uint32Array}\n    */\n    indices() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.auxiliarydataset_indices(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU32FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 4);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n*/\nexport class BaseAddress {\n\n    static __wrap(ptr) {\n        const obj = Object.create(BaseAddress.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_baseaddress_free(ptr);\n    }\n    /**\n    * @param {number} network\n    * @param {StakeCredential} payment\n    * @param {StakeCredential} stake\n    * @returns {BaseAddress}\n    */\n    static new(network, payment, stake) {\n        _assertClass(payment, StakeCredential);\n        _assertClass(stake, StakeCredential);\n        var ret = wasm.baseaddress_new(network, payment.ptr, stake.ptr);\n        return BaseAddress.__wrap(ret);\n    }\n    /**\n    * @returns {StakeCredential}\n    */\n    payment_cred() {\n        var ret = wasm.baseaddress_payment_cred(this.ptr);\n        return StakeCredential.__wrap(ret);\n    }\n    /**\n    * @returns {StakeCredential}\n    */\n    stake_cred() {\n        var ret = wasm.baseaddress_stake_cred(this.ptr);\n        return StakeCredential.__wrap(ret);\n    }\n    /**\n    * @returns {Address}\n    */\n    to_address() {\n        var ret = wasm.baseaddress_to_address(this.ptr);\n        return Address.__wrap(ret);\n    }\n    /**\n    * @param {Address} addr\n    * @returns {BaseAddress | undefined}\n    */\n    static from_address(addr) {\n        _assertClass(addr, Address);\n        var ret = wasm.baseaddress_from_address(addr.ptr);\n        return ret === 0 ? undefined : BaseAddress.__wrap(ret);\n    }\n}\n/**\n*/\nexport class BigInt {\n\n    static __wrap(ptr) {\n        const obj = Object.create(BigInt.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_bigint_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.bigint_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {BigInt}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.bigint_from_bytes(ptr0, len0);\n        return BigInt.__wrap(ret);\n    }\n    /**\n    * @returns {BigNum | undefined}\n    */\n    as_u64() {\n        var ret = wasm.bigint_as_u64(this.ptr);\n        return ret === 0 ? undefined : BigNum.__wrap(ret);\n    }\n    /**\n    * @param {string} text\n    * @returns {BigInt}\n    */\n    static from_str(text) {\n        var ptr0 = passStringToWasm0(text, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.bigint_from_str(ptr0, len0);\n        return BigInt.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_str() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.bigint_to_str(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n}\n/**\n*/\nexport class BigNum {\n\n    static __wrap(ptr) {\n        const obj = Object.create(BigNum.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_bignum_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.bignum_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {BigNum}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.bignum_from_bytes(ptr0, len0);\n        return BigNum.__wrap(ret);\n    }\n    /**\n    * @param {string} string\n    * @returns {BigNum}\n    */\n    static from_str(string) {\n        var ptr0 = passStringToWasm0(string, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.bignum_from_str(ptr0, len0);\n        return BigNum.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_str() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.bignum_to_str(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @returns {BigNum}\n    */\n    static zero() {\n        var ret = wasm.bignum_zero();\n        return BigNum.__wrap(ret);\n    }\n    /**\n    * @returns {boolean}\n    */\n    is_zero() {\n        var ret = wasm.bignum_is_zero(this.ptr);\n        return ret !== 0;\n    }\n    /**\n    * @param {BigNum} other\n    * @returns {BigNum}\n    */\n    checked_mul(other) {\n        _assertClass(other, BigNum);\n        var ret = wasm.bignum_checked_mul(this.ptr, other.ptr);\n        return BigNum.__wrap(ret);\n    }\n    /**\n    * @param {BigNum} other\n    * @returns {BigNum}\n    */\n    checked_add(other) {\n        _assertClass(other, BigNum);\n        var ret = wasm.bignum_checked_add(this.ptr, other.ptr);\n        return BigNum.__wrap(ret);\n    }\n    /**\n    * @param {BigNum} other\n    * @returns {BigNum}\n    */\n    checked_sub(other) {\n        _assertClass(other, BigNum);\n        var ret = wasm.bignum_checked_sub(this.ptr, other.ptr);\n        return BigNum.__wrap(ret);\n    }\n    /**\n    * returns 0 if it would otherwise underflow\n    * @param {BigNum} other\n    * @returns {BigNum}\n    */\n    clamped_sub(other) {\n        _assertClass(other, BigNum);\n        var ret = wasm.bignum_clamped_sub(this.ptr, other.ptr);\n        return BigNum.__wrap(ret);\n    }\n    /**\n    * @param {BigNum} rhs_value\n    * @returns {number}\n    */\n    compare(rhs_value) {\n        _assertClass(rhs_value, BigNum);\n        var ret = wasm.bignum_compare(this.ptr, rhs_value.ptr);\n        return ret;\n    }\n}\n/**\n*/\nexport class Bip32PrivateKey {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Bip32PrivateKey.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_bip32privatekey_free(ptr);\n    }\n    /**\n    * derive this private key with the given index.\n    *\n    * # Security considerations\n    *\n    * * hard derivation index cannot be soft derived with the public key\n    *\n    * # Hard derivation vs Soft derivation\n    *\n    * If you pass an index below 0x80000000 then it is a soft derivation.\n    * The advantage of soft derivation is that it is possible to derive the\n    * public key too. I.e. derivation the private key with a soft derivation\n    * index and then retrieving the associated public key is equivalent to\n    * deriving the public key associated to the parent private key.\n    *\n    * Hard derivation index does not allow public key derivation.\n    *\n    * This is why deriving the private key should not fail while deriving\n    * the public key may fail (if the derivation index is invalid).\n    * @param {number} index\n    * @returns {Bip32PrivateKey}\n    */\n    derive(index) {\n        var ret = wasm.bip32privatekey_derive(this.ptr, index);\n        return Bip32PrivateKey.__wrap(ret);\n    }\n    /**\n    * 128-byte xprv a key format in Cardano that some software still uses or requires\n    * the traditional 96-byte xprv is simply encoded as\n    * prv | chaincode\n    * however, because some software may not know how to compute a public key from a private key,\n    * the 128-byte inlines the public key in the following format\n    * prv | pub | chaincode\n    * so be careful if you see the term \"xprv\" as it could refer to either one\n    * our library does not require the pub (instead we compute the pub key when needed)\n    * @param {Uint8Array} bytes\n    * @returns {Bip32PrivateKey}\n    */\n    static from_128_xprv(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.bip32privatekey_from_128_xprv(ptr0, len0);\n        return Bip32PrivateKey.__wrap(ret);\n    }\n    /**\n    * see from_128_xprv\n    * @returns {Uint8Array}\n    */\n    to_128_xprv() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.bip32privatekey_to_128_xprv(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {Bip32PrivateKey}\n    */\n    static generate_ed25519_bip32() {\n        var ret = wasm.bip32privatekey_generate_ed25519_bip32();\n        return Bip32PrivateKey.__wrap(ret);\n    }\n    /**\n    * @returns {PrivateKey}\n    */\n    to_raw_key() {\n        var ret = wasm.bip32privatekey_to_raw_key(this.ptr);\n        return PrivateKey.__wrap(ret);\n    }\n    /**\n    * @returns {Bip32PublicKey}\n    */\n    to_public() {\n        var ret = wasm.bip32privatekey_to_public(this.ptr);\n        return Bip32PublicKey.__wrap(ret);\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {Bip32PrivateKey}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.bip32privatekey_from_bytes(ptr0, len0);\n        return Bip32PrivateKey.__wrap(ret);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    as_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.bip32privatekey_as_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} bech32_str\n    * @returns {Bip32PrivateKey}\n    */\n    static from_bech32(bech32_str) {\n        var ptr0 = passStringToWasm0(bech32_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.bip32privatekey_from_bech32(ptr0, len0);\n        return Bip32PrivateKey.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_bech32() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.bip32privatekey_to_bech32(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {Uint8Array} entropy\n    * @param {Uint8Array} password\n    * @returns {Bip32PrivateKey}\n    */\n    static from_bip39_entropy(entropy, password) {\n        var ptr0 = passArray8ToWasm0(entropy, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ptr1 = passArray8ToWasm0(password, wasm.__wbindgen_malloc);\n        var len1 = WASM_VECTOR_LEN;\n        var ret = wasm.bip32privatekey_from_bip39_entropy(ptr0, len0, ptr1, len1);\n        return Bip32PrivateKey.__wrap(ret);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    chaincode() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.bip32privatekey_chaincode(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n*/\nexport class Bip32PublicKey {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Bip32PublicKey.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_bip32publickey_free(ptr);\n    }\n    /**\n    * derive this public key with the given index.\n    *\n    * # Errors\n    *\n    * If the index is not a soft derivation index (< 0x80000000) then\n    * calling this method will fail.\n    *\n    * # Security considerations\n    *\n    * * hard derivation index cannot be soft derived with the public key\n    *\n    * # Hard derivation vs Soft derivation\n    *\n    * If you pass an index below 0x80000000 then it is a soft derivation.\n    * The advantage of soft derivation is that it is possible to derive the\n    * public key too. I.e. derivation the private key with a soft derivation\n    * index and then retrieving the associated public key is equivalent to\n    * deriving the public key associated to the parent private key.\n    *\n    * Hard derivation index does not allow public key derivation.\n    *\n    * This is why deriving the private key should not fail while deriving\n    * the public key may fail (if the derivation index is invalid).\n    * @param {number} index\n    * @returns {Bip32PublicKey}\n    */\n    derive(index) {\n        var ret = wasm.bip32publickey_derive(this.ptr, index);\n        return Bip32PublicKey.__wrap(ret);\n    }\n    /**\n    * @returns {PublicKey}\n    */\n    to_raw_key() {\n        var ret = wasm.bip32publickey_to_raw_key(this.ptr);\n        return PublicKey.__wrap(ret);\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {Bip32PublicKey}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.bip32publickey_from_bytes(ptr0, len0);\n        return Bip32PublicKey.__wrap(ret);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    as_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.bip32publickey_as_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} bech32_str\n    * @returns {Bip32PublicKey}\n    */\n    static from_bech32(bech32_str) {\n        var ptr0 = passStringToWasm0(bech32_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.bip32publickey_from_bech32(ptr0, len0);\n        return Bip32PublicKey.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_bech32() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.bip32publickey_to_bech32(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    chaincode() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.bip32publickey_chaincode(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n*/\nexport class Block {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Block.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_block_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.block_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {Block}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.block_from_bytes(ptr0, len0);\n        return Block.__wrap(ret);\n    }\n    /**\n    * @returns {Header}\n    */\n    header() {\n        var ret = wasm.block_header(this.ptr);\n        return Header.__wrap(ret);\n    }\n    /**\n    * @returns {TransactionBodies}\n    */\n    transaction_bodies() {\n        var ret = wasm.block_transaction_bodies(this.ptr);\n        return TransactionBodies.__wrap(ret);\n    }\n    /**\n    * @returns {TransactionWitnessSets}\n    */\n    transaction_witness_sets() {\n        var ret = wasm.block_transaction_witness_sets(this.ptr);\n        return TransactionWitnessSets.__wrap(ret);\n    }\n    /**\n    * @returns {AuxiliaryDataSet}\n    */\n    auxiliary_data_set() {\n        var ret = wasm.block_auxiliary_data_set(this.ptr);\n        return AuxiliaryDataSet.__wrap(ret);\n    }\n    /**\n    * @returns {Uint32Array}\n    */\n    invalid_transactions() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.block_invalid_transactions(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU32FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 4);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Header} header\n    * @param {TransactionBodies} transaction_bodies\n    * @param {TransactionWitnessSets} transaction_witness_sets\n    * @param {AuxiliaryDataSet} auxiliary_data_set\n    * @param {Uint32Array} invalid_transactions\n    * @returns {Block}\n    */\n    static new(header, transaction_bodies, transaction_witness_sets, auxiliary_data_set, invalid_transactions) {\n        _assertClass(header, Header);\n        _assertClass(transaction_bodies, TransactionBodies);\n        _assertClass(transaction_witness_sets, TransactionWitnessSets);\n        _assertClass(auxiliary_data_set, AuxiliaryDataSet);\n        var ptr0 = passArray32ToWasm0(invalid_transactions, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.block_new(header.ptr, transaction_bodies.ptr, transaction_witness_sets.ptr, auxiliary_data_set.ptr, ptr0, len0);\n        return Block.__wrap(ret);\n    }\n}\n/**\n*/\nexport class BlockHash {\n\n    static __wrap(ptr) {\n        const obj = Object.create(BlockHash.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_blockhash_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.blockhash_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} prefix\n    * @returns {string}\n    */\n    to_bech32(prefix) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passStringToWasm0(prefix, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.blockhash_to_bech32(retptr, this.ptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} bech_str\n    * @returns {BlockHash}\n    */\n    static from_bech32(bech_str) {\n        var ptr0 = passStringToWasm0(bech_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.blockhash_from_bech32(ptr0, len0);\n        return BlockHash.__wrap(ret);\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {BlockHash}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.blockhash_from_bytes(ptr0, len0);\n        return BlockHash.__wrap(ret);\n    }\n}\n/**\n*/\nexport class BootstrapWitness {\n\n    static __wrap(ptr) {\n        const obj = Object.create(BootstrapWitness.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_bootstrapwitness_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.bootstrapwitness_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {BootstrapWitness}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.bootstrapwitness_from_bytes(ptr0, len0);\n        return BootstrapWitness.__wrap(ret);\n    }\n    /**\n    * @returns {Vkey}\n    */\n    vkey() {\n        var ret = wasm.bootstrapwitness_vkey(this.ptr);\n        return Vkey.__wrap(ret);\n    }\n    /**\n    * @returns {Ed25519Signature}\n    */\n    signature() {\n        var ret = wasm.bootstrapwitness_signature(this.ptr);\n        return Ed25519Signature.__wrap(ret);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    chain_code() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.bootstrapwitness_chain_code(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    attributes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.bootstrapwitness_attributes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Vkey} vkey\n    * @param {Ed25519Signature} signature\n    * @param {Uint8Array} chain_code\n    * @param {Uint8Array} attributes\n    * @returns {BootstrapWitness}\n    */\n    static new(vkey, signature, chain_code, attributes) {\n        _assertClass(vkey, Vkey);\n        _assertClass(signature, Ed25519Signature);\n        var ptr0 = passArray8ToWasm0(chain_code, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ptr1 = passArray8ToWasm0(attributes, wasm.__wbindgen_malloc);\n        var len1 = WASM_VECTOR_LEN;\n        var ret = wasm.bootstrapwitness_new(vkey.ptr, signature.ptr, ptr0, len0, ptr1, len1);\n        return BootstrapWitness.__wrap(ret);\n    }\n}\n/**\n*/\nexport class BootstrapWitnesses {\n\n    static __wrap(ptr) {\n        const obj = Object.create(BootstrapWitnesses.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_bootstrapwitnesses_free(ptr);\n    }\n    /**\n    * @returns {BootstrapWitnesses}\n    */\n    static new() {\n        var ret = wasm.bootstrapwitnesses_new();\n        return BootstrapWitnesses.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.bootstrapwitnesses_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} index\n    * @returns {BootstrapWitness}\n    */\n    get(index) {\n        var ret = wasm.bootstrapwitnesses_get(this.ptr, index);\n        return BootstrapWitness.__wrap(ret);\n    }\n    /**\n    * @param {BootstrapWitness} elem\n    */\n    add(elem) {\n        _assertClass(elem, BootstrapWitness);\n        wasm.bootstrapwitnesses_add(this.ptr, elem.ptr);\n    }\n}\n/**\n*/\nexport class ByronAddress {\n\n    static __wrap(ptr) {\n        const obj = Object.create(ByronAddress.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_byronaddress_free(ptr);\n    }\n    /**\n    * @returns {string}\n    */\n    to_base58() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.byronaddress_to_base58(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.byronaddress_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {ByronAddress}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.byronaddress_from_bytes(ptr0, len0);\n        return ByronAddress.__wrap(ret);\n    }\n    /**\n    * returns the byron protocol magic embedded in the address, or mainnet id if none is present\n    * note: for bech32 addresses, you need to use network_id instead\n    * @returns {number}\n    */\n    byron_protocol_magic() {\n        var ret = wasm.byronaddress_byron_protocol_magic(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    attributes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.byronaddress_attributes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {number}\n    */\n    network_id() {\n        var ret = wasm.byronaddress_network_id(this.ptr);\n        return ret;\n    }\n    /**\n    * @param {string} s\n    * @returns {ByronAddress}\n    */\n    static from_base58(s) {\n        var ptr0 = passStringToWasm0(s, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.byronaddress_from_base58(ptr0, len0);\n        return ByronAddress.__wrap(ret);\n    }\n    /**\n    * @param {Bip32PublicKey} key\n    * @param {number} protocol_magic\n    * @returns {ByronAddress}\n    */\n    static icarus_from_key(key, protocol_magic) {\n        _assertClass(key, Bip32PublicKey);\n        var ret = wasm.byronaddress_icarus_from_key(key.ptr, protocol_magic);\n        return ByronAddress.__wrap(ret);\n    }\n    /**\n    * @param {string} s\n    * @returns {boolean}\n    */\n    static is_valid(s) {\n        var ptr0 = passStringToWasm0(s, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.byronaddress_is_valid(ptr0, len0);\n        return ret !== 0;\n    }\n    /**\n    * @returns {Address}\n    */\n    to_address() {\n        var ret = wasm.byronaddress_to_address(this.ptr);\n        return Address.__wrap(ret);\n    }\n    /**\n    * @param {Address} addr\n    * @returns {ByronAddress | undefined}\n    */\n    static from_address(addr) {\n        _assertClass(addr, Address);\n        var ret = wasm.byronaddress_from_address(addr.ptr);\n        return ret === 0 ? undefined : ByronAddress.__wrap(ret);\n    }\n}\n/**\n*/\nexport class Certificate {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Certificate.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_certificate_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.certificate_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {Certificate}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.certificate_from_bytes(ptr0, len0);\n        return Certificate.__wrap(ret);\n    }\n    /**\n    * @param {StakeRegistration} stake_registration\n    * @returns {Certificate}\n    */\n    static new_stake_registration(stake_registration) {\n        _assertClass(stake_registration, StakeRegistration);\n        var ret = wasm.certificate_new_stake_registration(stake_registration.ptr);\n        return Certificate.__wrap(ret);\n    }\n    /**\n    * @param {StakeDeregistration} stake_deregistration\n    * @returns {Certificate}\n    */\n    static new_stake_deregistration(stake_deregistration) {\n        _assertClass(stake_deregistration, StakeDeregistration);\n        var ret = wasm.certificate_new_stake_deregistration(stake_deregistration.ptr);\n        return Certificate.__wrap(ret);\n    }\n    /**\n    * @param {StakeDelegation} stake_delegation\n    * @returns {Certificate}\n    */\n    static new_stake_delegation(stake_delegation) {\n        _assertClass(stake_delegation, StakeDelegation);\n        var ret = wasm.certificate_new_stake_delegation(stake_delegation.ptr);\n        return Certificate.__wrap(ret);\n    }\n    /**\n    * @param {PoolRegistration} pool_registration\n    * @returns {Certificate}\n    */\n    static new_pool_registration(pool_registration) {\n        _assertClass(pool_registration, PoolRegistration);\n        var ret = wasm.certificate_new_pool_registration(pool_registration.ptr);\n        return Certificate.__wrap(ret);\n    }\n    /**\n    * @param {PoolRetirement} pool_retirement\n    * @returns {Certificate}\n    */\n    static new_pool_retirement(pool_retirement) {\n        _assertClass(pool_retirement, PoolRetirement);\n        var ret = wasm.certificate_new_pool_retirement(pool_retirement.ptr);\n        return Certificate.__wrap(ret);\n    }\n    /**\n    * @param {GenesisKeyDelegation} genesis_key_delegation\n    * @returns {Certificate}\n    */\n    static new_genesis_key_delegation(genesis_key_delegation) {\n        _assertClass(genesis_key_delegation, GenesisKeyDelegation);\n        var ret = wasm.certificate_new_genesis_key_delegation(genesis_key_delegation.ptr);\n        return Certificate.__wrap(ret);\n    }\n    /**\n    * @param {MoveInstantaneousRewardsCert} move_instantaneous_rewards_cert\n    * @returns {Certificate}\n    */\n    static new_move_instantaneous_rewards_cert(move_instantaneous_rewards_cert) {\n        _assertClass(move_instantaneous_rewards_cert, MoveInstantaneousRewardsCert);\n        var ret = wasm.certificate_new_move_instantaneous_rewards_cert(move_instantaneous_rewards_cert.ptr);\n        return Certificate.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    kind() {\n        var ret = wasm.certificate_kind(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {StakeRegistration | undefined}\n    */\n    as_stake_registration() {\n        var ret = wasm.certificate_as_stake_registration(this.ptr);\n        return ret === 0 ? undefined : StakeRegistration.__wrap(ret);\n    }\n    /**\n    * @returns {StakeDeregistration | undefined}\n    */\n    as_stake_deregistration() {\n        var ret = wasm.certificate_as_stake_deregistration(this.ptr);\n        return ret === 0 ? undefined : StakeDeregistration.__wrap(ret);\n    }\n    /**\n    * @returns {StakeDelegation | undefined}\n    */\n    as_stake_delegation() {\n        var ret = wasm.certificate_as_stake_delegation(this.ptr);\n        return ret === 0 ? undefined : StakeDelegation.__wrap(ret);\n    }\n    /**\n    * @returns {PoolRegistration | undefined}\n    */\n    as_pool_registration() {\n        var ret = wasm.certificate_as_pool_registration(this.ptr);\n        return ret === 0 ? undefined : PoolRegistration.__wrap(ret);\n    }\n    /**\n    * @returns {PoolRetirement | undefined}\n    */\n    as_pool_retirement() {\n        var ret = wasm.certificate_as_pool_retirement(this.ptr);\n        return ret === 0 ? undefined : PoolRetirement.__wrap(ret);\n    }\n    /**\n    * @returns {GenesisKeyDelegation | undefined}\n    */\n    as_genesis_key_delegation() {\n        var ret = wasm.certificate_as_genesis_key_delegation(this.ptr);\n        return ret === 0 ? undefined : GenesisKeyDelegation.__wrap(ret);\n    }\n    /**\n    * @returns {MoveInstantaneousRewardsCert | undefined}\n    */\n    as_move_instantaneous_rewards_cert() {\n        var ret = wasm.certificate_as_move_instantaneous_rewards_cert(this.ptr);\n        return ret === 0 ? undefined : MoveInstantaneousRewardsCert.__wrap(ret);\n    }\n}\n/**\n*/\nexport class Certificates {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Certificates.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_certificates_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.certificates_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {Certificates}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.certificates_from_bytes(ptr0, len0);\n        return Certificates.__wrap(ret);\n    }\n    /**\n    * @returns {Certificates}\n    */\n    static new() {\n        var ret = wasm.certificates_new();\n        return Certificates.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.certificates_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} index\n    * @returns {Certificate}\n    */\n    get(index) {\n        var ret = wasm.certificates_get(this.ptr, index);\n        return Certificate.__wrap(ret);\n    }\n    /**\n    * @param {Certificate} elem\n    */\n    add(elem) {\n        _assertClass(elem, Certificate);\n        wasm.certificates_add(this.ptr, elem.ptr);\n    }\n}\n/**\n*/\nexport class ConstrPlutusData {\n\n    static __wrap(ptr) {\n        const obj = Object.create(ConstrPlutusData.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_constrplutusdata_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.constrplutusdata_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {ConstrPlutusData}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.constrplutusdata_from_bytes(ptr0, len0);\n        return ConstrPlutusData.__wrap(ret);\n    }\n    /**\n    * @returns {Int}\n    */\n    tag() {\n        var ret = wasm.constrplutusdata_tag(this.ptr);\n        return Int.__wrap(ret);\n    }\n    /**\n    * @returns {PlutusList}\n    */\n    data() {\n        var ret = wasm.constrplutusdata_data(this.ptr);\n        return PlutusList.__wrap(ret);\n    }\n    /**\n    * @param {Int} tag\n    * @param {PlutusList} data\n    * @returns {ConstrPlutusData}\n    */\n    static new(tag, data) {\n        _assertClass(tag, Int);\n        var ptr0 = tag.ptr;\n        tag.ptr = 0;\n        _assertClass(data, PlutusList);\n        var ret = wasm.constrplutusdata_new(ptr0, data.ptr);\n        return ConstrPlutusData.__wrap(ret);\n    }\n}\n/**\n*/\nexport class CostModel {\n\n    static __wrap(ptr) {\n        const obj = Object.create(CostModel.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_costmodel_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.costmodel_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {CostModel}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.costmodel_from_bytes(ptr0, len0);\n        return CostModel.__wrap(ret);\n    }\n    /**\n    * @returns {CostModel}\n    */\n    static new() {\n        var ret = wasm.costmodel_new();\n        return CostModel.__wrap(ret);\n    }\n    /**\n    * @param {number} operation\n    * @param {Int} cost\n    * @returns {Int}\n    */\n    set(operation, cost) {\n        _assertClass(cost, Int);\n        var ret = wasm.costmodel_set(this.ptr, operation, cost.ptr);\n        return Int.__wrap(ret);\n    }\n    /**\n    * @param {number} operation\n    * @returns {Int}\n    */\n    get(operation) {\n        var ret = wasm.costmodel_get(this.ptr, operation);\n        return Int.__wrap(ret);\n    }\n}\n/**\n*/\nexport class Costmdls {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Costmdls.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_costmdls_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.costmdls_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {Costmdls}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.costmdls_from_bytes(ptr0, len0);\n        return Costmdls.__wrap(ret);\n    }\n    /**\n    * @returns {Costmdls}\n    */\n    static new() {\n        var ret = wasm.costmdls_new();\n        return Costmdls.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.costmdls_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {Language} key\n    * @param {CostModel} value\n    * @returns {CostModel | undefined}\n    */\n    insert(key, value) {\n        _assertClass(key, Language);\n        _assertClass(value, CostModel);\n        var ret = wasm.costmdls_insert(this.ptr, key.ptr, value.ptr);\n        return ret === 0 ? undefined : CostModel.__wrap(ret);\n    }\n    /**\n    * @param {Language} key\n    * @returns {CostModel | undefined}\n    */\n    get(key) {\n        _assertClass(key, Language);\n        var ret = wasm.costmdls_get(this.ptr, key.ptr);\n        return ret === 0 ? undefined : CostModel.__wrap(ret);\n    }\n    /**\n    * @returns {Languages}\n    */\n    keys() {\n        var ret = wasm.costmdls_keys(this.ptr);\n        return Languages.__wrap(ret);\n    }\n}\n/**\n*/\nexport class DNSRecordAorAAAA {\n\n    static __wrap(ptr) {\n        const obj = Object.create(DNSRecordAorAAAA.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_dnsrecordaoraaaa_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.dnsrecordaoraaaa_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {DNSRecordAorAAAA}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.dnsrecordaoraaaa_from_bytes(ptr0, len0);\n        return DNSRecordAorAAAA.__wrap(ret);\n    }\n    /**\n    * @param {string} dns_name\n    * @returns {DNSRecordAorAAAA}\n    */\n    static new(dns_name) {\n        var ptr0 = passStringToWasm0(dns_name, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.dnsrecordaoraaaa_new(ptr0, len0);\n        return DNSRecordAorAAAA.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    record() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.dnsrecordaoraaaa_record(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n}\n/**\n*/\nexport class DNSRecordSRV {\n\n    static __wrap(ptr) {\n        const obj = Object.create(DNSRecordSRV.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_dnsrecordsrv_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.dnsrecordsrv_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {DNSRecordSRV}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.dnsrecordsrv_from_bytes(ptr0, len0);\n        return DNSRecordSRV.__wrap(ret);\n    }\n    /**\n    * @param {string} dns_name\n    * @returns {DNSRecordSRV}\n    */\n    static new(dns_name) {\n        var ptr0 = passStringToWasm0(dns_name, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.dnsrecordsrv_new(ptr0, len0);\n        return DNSRecordSRV.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    record() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.dnsrecordsrv_record(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n}\n/**\n*/\nexport class DataHash {\n\n    static __wrap(ptr) {\n        const obj = Object.create(DataHash.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_datahash_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.datahash_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} prefix\n    * @returns {string}\n    */\n    to_bech32(prefix) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passStringToWasm0(prefix, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.datahash_to_bech32(retptr, this.ptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} bech_str\n    * @returns {DataHash}\n    */\n    static from_bech32(bech_str) {\n        var ptr0 = passStringToWasm0(bech_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.datahash_from_bech32(ptr0, len0);\n        return DataHash.__wrap(ret);\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {DataHash}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.datahash_from_bytes(ptr0, len0);\n        return DataHash.__wrap(ret);\n    }\n}\n/**\n*/\nexport class Ed25519KeyHash {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Ed25519KeyHash.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_ed25519keyhash_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.ed25519keyhash_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} prefix\n    * @returns {string}\n    */\n    to_bech32(prefix) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passStringToWasm0(prefix, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.ed25519keyhash_to_bech32(retptr, this.ptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} bech_str\n    * @returns {Ed25519KeyHash}\n    */\n    static from_bech32(bech_str) {\n        var ptr0 = passStringToWasm0(bech_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.ed25519keyhash_from_bech32(ptr0, len0);\n        return Ed25519KeyHash.__wrap(ret);\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {Ed25519KeyHash}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.ed25519keyhash_from_bytes(ptr0, len0);\n        return Ed25519KeyHash.__wrap(ret);\n    }\n}\n/**\n*/\nexport class Ed25519KeyHashes {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Ed25519KeyHashes.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_ed25519keyhashes_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.ed25519keyhashes_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {Ed25519KeyHashes}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.ed25519keyhashes_from_bytes(ptr0, len0);\n        return Ed25519KeyHashes.__wrap(ret);\n    }\n    /**\n    * @returns {Ed25519KeyHashes}\n    */\n    static new() {\n        var ret = wasm.ed25519keyhashes_new();\n        return Ed25519KeyHashes.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.ed25519keyhashes_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} index\n    * @returns {Ed25519KeyHash}\n    */\n    get(index) {\n        var ret = wasm.ed25519keyhashes_get(this.ptr, index);\n        return Ed25519KeyHash.__wrap(ret);\n    }\n    /**\n    * @param {Ed25519KeyHash} elem\n    */\n    add(elem) {\n        _assertClass(elem, Ed25519KeyHash);\n        wasm.ed25519keyhashes_add(this.ptr, elem.ptr);\n    }\n}\n/**\n*/\nexport class Ed25519Signature {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Ed25519Signature.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_ed25519signature_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.ed25519signature_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_bech32() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.ed25519signature_to_bech32(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    to_hex() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.ed25519signature_to_hex(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} bech32_str\n    * @returns {Ed25519Signature}\n    */\n    static from_bech32(bech32_str) {\n        var ptr0 = passStringToWasm0(bech32_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.ed25519signature_from_bech32(ptr0, len0);\n        return Ed25519Signature.__wrap(ret);\n    }\n    /**\n    * @param {string} input\n    * @returns {Ed25519Signature}\n    */\n    static from_hex(input) {\n        var ptr0 = passStringToWasm0(input, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.ed25519signature_from_hex(ptr0, len0);\n        return Ed25519Signature.__wrap(ret);\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {Ed25519Signature}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.ed25519signature_from_bytes(ptr0, len0);\n        return Ed25519Signature.__wrap(ret);\n    }\n}\n/**\n*/\nexport class EnterpriseAddress {\n\n    static __wrap(ptr) {\n        const obj = Object.create(EnterpriseAddress.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_enterpriseaddress_free(ptr);\n    }\n    /**\n    * @param {number} network\n    * @param {StakeCredential} payment\n    * @returns {EnterpriseAddress}\n    */\n    static new(network, payment) {\n        _assertClass(payment, StakeCredential);\n        var ret = wasm.enterpriseaddress_new(network, payment.ptr);\n        return EnterpriseAddress.__wrap(ret);\n    }\n    /**\n    * @returns {StakeCredential}\n    */\n    payment_cred() {\n        var ret = wasm.enterpriseaddress_payment_cred(this.ptr);\n        return StakeCredential.__wrap(ret);\n    }\n    /**\n    * @returns {Address}\n    */\n    to_address() {\n        var ret = wasm.enterpriseaddress_to_address(this.ptr);\n        return Address.__wrap(ret);\n    }\n    /**\n    * @param {Address} addr\n    * @returns {EnterpriseAddress | undefined}\n    */\n    static from_address(addr) {\n        _assertClass(addr, Address);\n        var ret = wasm.enterpriseaddress_from_address(addr.ptr);\n        return ret === 0 ? undefined : EnterpriseAddress.__wrap(ret);\n    }\n}\n/**\n*/\nexport class ExUnitPrices {\n\n    static __wrap(ptr) {\n        const obj = Object.create(ExUnitPrices.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_exunitprices_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.exunitprices_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {ExUnitPrices}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.exunitprices_from_bytes(ptr0, len0);\n        return ExUnitPrices.__wrap(ret);\n    }\n    /**\n    * @returns {UnitInterval}\n    */\n    mem_price() {\n        var ret = wasm.exunitprices_mem_price(this.ptr);\n        return UnitInterval.__wrap(ret);\n    }\n    /**\n    * @returns {UnitInterval}\n    */\n    step_price() {\n        var ret = wasm.exunitprices_step_price(this.ptr);\n        return UnitInterval.__wrap(ret);\n    }\n    /**\n    * @param {UnitInterval} mem_price\n    * @param {UnitInterval} step_price\n    * @returns {ExUnitPrices}\n    */\n    static new(mem_price, step_price) {\n        _assertClass(mem_price, UnitInterval);\n        _assertClass(step_price, UnitInterval);\n        var ret = wasm.exunitprices_new(mem_price.ptr, step_price.ptr);\n        return ExUnitPrices.__wrap(ret);\n    }\n}\n/**\n*/\nexport class ExUnits {\n\n    static __wrap(ptr) {\n        const obj = Object.create(ExUnits.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_exunits_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.exunits_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {ExUnits}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.exunits_from_bytes(ptr0, len0);\n        return ExUnits.__wrap(ret);\n    }\n    /**\n    * @returns {BigNum}\n    */\n    mem() {\n        var ret = wasm.exunits_mem(this.ptr);\n        return BigNum.__wrap(ret);\n    }\n    /**\n    * @returns {BigNum}\n    */\n    steps() {\n        var ret = wasm.exunits_steps(this.ptr);\n        return BigNum.__wrap(ret);\n    }\n    /**\n    * @param {BigNum} mem\n    * @param {BigNum} steps\n    * @returns {ExUnits}\n    */\n    static new(mem, steps) {\n        _assertClass(mem, BigNum);\n        _assertClass(steps, BigNum);\n        var ret = wasm.exunits_new(mem.ptr, steps.ptr);\n        return ExUnits.__wrap(ret);\n    }\n}\n/**\n*/\nexport class GeneralTransactionMetadata {\n\n    static __wrap(ptr) {\n        const obj = Object.create(GeneralTransactionMetadata.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_generaltransactionmetadata_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.generaltransactionmetadata_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {GeneralTransactionMetadata}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.generaltransactionmetadata_from_bytes(ptr0, len0);\n        return GeneralTransactionMetadata.__wrap(ret);\n    }\n    /**\n    * @returns {GeneralTransactionMetadata}\n    */\n    static new() {\n        var ret = wasm.generaltransactionmetadata_new();\n        return GeneralTransactionMetadata.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.generaltransactionmetadata_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {BigNum} key\n    * @param {TransactionMetadatum} value\n    * @returns {TransactionMetadatum | undefined}\n    */\n    insert(key, value) {\n        _assertClass(key, BigNum);\n        _assertClass(value, TransactionMetadatum);\n        var ret = wasm.generaltransactionmetadata_insert(this.ptr, key.ptr, value.ptr);\n        return ret === 0 ? undefined : TransactionMetadatum.__wrap(ret);\n    }\n    /**\n    * @param {BigNum} key\n    * @returns {TransactionMetadatum | undefined}\n    */\n    get(key) {\n        _assertClass(key, BigNum);\n        var ret = wasm.generaltransactionmetadata_get(this.ptr, key.ptr);\n        return ret === 0 ? undefined : TransactionMetadatum.__wrap(ret);\n    }\n    /**\n    * @returns {TransactionMetadatumLabels}\n    */\n    keys() {\n        var ret = wasm.generaltransactionmetadata_keys(this.ptr);\n        return TransactionMetadatumLabels.__wrap(ret);\n    }\n}\n/**\n*/\nexport class GenesisDelegateHash {\n\n    static __wrap(ptr) {\n        const obj = Object.create(GenesisDelegateHash.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_genesisdelegatehash_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.genesisdelegatehash_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} prefix\n    * @returns {string}\n    */\n    to_bech32(prefix) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passStringToWasm0(prefix, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.genesisdelegatehash_to_bech32(retptr, this.ptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} bech_str\n    * @returns {GenesisDelegateHash}\n    */\n    static from_bech32(bech_str) {\n        var ptr0 = passStringToWasm0(bech_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.genesisdelegatehash_from_bech32(ptr0, len0);\n        return GenesisDelegateHash.__wrap(ret);\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {GenesisDelegateHash}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.genesisdelegatehash_from_bytes(ptr0, len0);\n        return GenesisDelegateHash.__wrap(ret);\n    }\n}\n/**\n*/\nexport class GenesisHash {\n\n    static __wrap(ptr) {\n        const obj = Object.create(GenesisHash.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_genesishash_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.genesishash_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} prefix\n    * @returns {string}\n    */\n    to_bech32(prefix) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passStringToWasm0(prefix, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.genesishash_to_bech32(retptr, this.ptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} bech_str\n    * @returns {GenesisHash}\n    */\n    static from_bech32(bech_str) {\n        var ptr0 = passStringToWasm0(bech_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.genesishash_from_bech32(ptr0, len0);\n        return GenesisHash.__wrap(ret);\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {GenesisHash}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.genesishash_from_bytes(ptr0, len0);\n        return GenesisHash.__wrap(ret);\n    }\n}\n/**\n*/\nexport class GenesisHashes {\n\n    static __wrap(ptr) {\n        const obj = Object.create(GenesisHashes.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_genesishashes_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.genesishashes_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {GenesisHashes}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.genesishashes_from_bytes(ptr0, len0);\n        return GenesisHashes.__wrap(ret);\n    }\n    /**\n    * @returns {GenesisHashes}\n    */\n    static new() {\n        var ret = wasm.genesishashes_new();\n        return GenesisHashes.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.genesishashes_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} index\n    * @returns {GenesisHash}\n    */\n    get(index) {\n        var ret = wasm.genesishashes_get(this.ptr, index);\n        return GenesisHash.__wrap(ret);\n    }\n    /**\n    * @param {GenesisHash} elem\n    */\n    add(elem) {\n        _assertClass(elem, GenesisHash);\n        wasm.genesishashes_add(this.ptr, elem.ptr);\n    }\n}\n/**\n*/\nexport class GenesisKeyDelegation {\n\n    static __wrap(ptr) {\n        const obj = Object.create(GenesisKeyDelegation.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_genesiskeydelegation_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.genesiskeydelegation_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {GenesisKeyDelegation}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.genesiskeydelegation_from_bytes(ptr0, len0);\n        return GenesisKeyDelegation.__wrap(ret);\n    }\n    /**\n    * @returns {GenesisHash}\n    */\n    genesishash() {\n        var ret = wasm.genesiskeydelegation_genesishash(this.ptr);\n        return GenesisHash.__wrap(ret);\n    }\n    /**\n    * @returns {GenesisDelegateHash}\n    */\n    genesis_delegate_hash() {\n        var ret = wasm.genesiskeydelegation_genesis_delegate_hash(this.ptr);\n        return GenesisDelegateHash.__wrap(ret);\n    }\n    /**\n    * @returns {VRFKeyHash}\n    */\n    vrf_keyhash() {\n        var ret = wasm.genesiskeydelegation_vrf_keyhash(this.ptr);\n        return VRFKeyHash.__wrap(ret);\n    }\n    /**\n    * @param {GenesisHash} genesishash\n    * @param {GenesisDelegateHash} genesis_delegate_hash\n    * @param {VRFKeyHash} vrf_keyhash\n    * @returns {GenesisKeyDelegation}\n    */\n    static new(genesishash, genesis_delegate_hash, vrf_keyhash) {\n        _assertClass(genesishash, GenesisHash);\n        _assertClass(genesis_delegate_hash, GenesisDelegateHash);\n        _assertClass(vrf_keyhash, VRFKeyHash);\n        var ret = wasm.genesiskeydelegation_new(genesishash.ptr, genesis_delegate_hash.ptr, vrf_keyhash.ptr);\n        return GenesisKeyDelegation.__wrap(ret);\n    }\n}\n/**\n*/\nexport class Header {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Header.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_header_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.header_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {Header}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.header_from_bytes(ptr0, len0);\n        return Header.__wrap(ret);\n    }\n    /**\n    * @returns {HeaderBody}\n    */\n    header_body() {\n        var ret = wasm.header_header_body(this.ptr);\n        return HeaderBody.__wrap(ret);\n    }\n    /**\n    * @returns {KESSignature}\n    */\n    body_signature() {\n        var ret = wasm.header_body_signature(this.ptr);\n        return KESSignature.__wrap(ret);\n    }\n    /**\n    * @param {HeaderBody} header_body\n    * @param {KESSignature} body_signature\n    * @returns {Header}\n    */\n    static new(header_body, body_signature) {\n        _assertClass(header_body, HeaderBody);\n        _assertClass(body_signature, KESSignature);\n        var ret = wasm.header_new(header_body.ptr, body_signature.ptr);\n        return Header.__wrap(ret);\n    }\n}\n/**\n*/\nexport class HeaderBody {\n\n    static __wrap(ptr) {\n        const obj = Object.create(HeaderBody.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_headerbody_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.headerbody_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {HeaderBody}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.headerbody_from_bytes(ptr0, len0);\n        return HeaderBody.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    block_number() {\n        var ret = wasm.headerbody_block_number(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {number}\n    */\n    slot() {\n        var ret = wasm.headerbody_slot(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {BlockHash | undefined}\n    */\n    prev_hash() {\n        var ret = wasm.headerbody_prev_hash(this.ptr);\n        return ret === 0 ? undefined : BlockHash.__wrap(ret);\n    }\n    /**\n    * @returns {Vkey}\n    */\n    issuer_vkey() {\n        var ret = wasm.headerbody_issuer_vkey(this.ptr);\n        return Vkey.__wrap(ret);\n    }\n    /**\n    * @returns {VRFVKey}\n    */\n    vrf_vkey() {\n        var ret = wasm.headerbody_vrf_vkey(this.ptr);\n        return VRFVKey.__wrap(ret);\n    }\n    /**\n    * @returns {VRFCert}\n    */\n    nonce_vrf() {\n        var ret = wasm.headerbody_nonce_vrf(this.ptr);\n        return VRFCert.__wrap(ret);\n    }\n    /**\n    * @returns {VRFCert}\n    */\n    leader_vrf() {\n        var ret = wasm.headerbody_leader_vrf(this.ptr);\n        return VRFCert.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    block_body_size() {\n        var ret = wasm.headerbody_block_body_size(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {BlockHash}\n    */\n    block_body_hash() {\n        var ret = wasm.headerbody_block_body_hash(this.ptr);\n        return BlockHash.__wrap(ret);\n    }\n    /**\n    * @returns {OperationalCert}\n    */\n    operational_cert() {\n        var ret = wasm.headerbody_operational_cert(this.ptr);\n        return OperationalCert.__wrap(ret);\n    }\n    /**\n    * @returns {ProtocolVersion}\n    */\n    protocol_version() {\n        var ret = wasm.headerbody_protocol_version(this.ptr);\n        return ProtocolVersion.__wrap(ret);\n    }\n    /**\n    * @param {number} block_number\n    * @param {number} slot\n    * @param {BlockHash | undefined} prev_hash\n    * @param {Vkey} issuer_vkey\n    * @param {VRFVKey} vrf_vkey\n    * @param {VRFCert} nonce_vrf\n    * @param {VRFCert} leader_vrf\n    * @param {number} block_body_size\n    * @param {BlockHash} block_body_hash\n    * @param {OperationalCert} operational_cert\n    * @param {ProtocolVersion} protocol_version\n    * @returns {HeaderBody}\n    */\n    static new(block_number, slot, prev_hash, issuer_vkey, vrf_vkey, nonce_vrf, leader_vrf, block_body_size, block_body_hash, operational_cert, protocol_version) {\n        let ptr0 = 0;\n        if (!isLikeNone(prev_hash)) {\n            _assertClass(prev_hash, BlockHash);\n            ptr0 = prev_hash.ptr;\n            prev_hash.ptr = 0;\n        }\n        _assertClass(issuer_vkey, Vkey);\n        _assertClass(vrf_vkey, VRFVKey);\n        _assertClass(nonce_vrf, VRFCert);\n        _assertClass(leader_vrf, VRFCert);\n        _assertClass(block_body_hash, BlockHash);\n        _assertClass(operational_cert, OperationalCert);\n        _assertClass(protocol_version, ProtocolVersion);\n        var ret = wasm.headerbody_new(block_number, slot, ptr0, issuer_vkey.ptr, vrf_vkey.ptr, nonce_vrf.ptr, leader_vrf.ptr, block_body_size, block_body_hash.ptr, operational_cert.ptr, protocol_version.ptr);\n        return HeaderBody.__wrap(ret);\n    }\n}\n/**\n*/\nexport class Int {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Int.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_int_free(ptr);\n    }\n    /**\n    * @param {BigNum} x\n    * @returns {Int}\n    */\n    static new(x) {\n        _assertClass(x, BigNum);\n        var ret = wasm.int_new(x.ptr);\n        return Int.__wrap(ret);\n    }\n    /**\n    * @param {BigNum} x\n    * @returns {Int}\n    */\n    static new_negative(x) {\n        _assertClass(x, BigNum);\n        var ret = wasm.int_new_negative(x.ptr);\n        return Int.__wrap(ret);\n    }\n    /**\n    * @param {number} x\n    * @returns {Int}\n    */\n    static new_i32(x) {\n        var ret = wasm.int_new_i32(x);\n        return Int.__wrap(ret);\n    }\n    /**\n    * @returns {boolean}\n    */\n    is_positive() {\n        var ret = wasm.int_is_positive(this.ptr);\n        return ret !== 0;\n    }\n    /**\n    * @returns {BigNum | undefined}\n    */\n    as_positive() {\n        var ret = wasm.int_as_positive(this.ptr);\n        return ret === 0 ? undefined : BigNum.__wrap(ret);\n    }\n    /**\n    * @returns {BigNum | undefined}\n    */\n    as_negative() {\n        var ret = wasm.int_as_negative(this.ptr);\n        return ret === 0 ? undefined : BigNum.__wrap(ret);\n    }\n    /**\n    * @returns {number | undefined}\n    */\n    as_i32() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.int_as_i32(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n*/\nexport class Ipv4 {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Ipv4.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_ipv4_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.ipv4_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {Ipv4}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.ipv4_from_bytes(ptr0, len0);\n        return Ipv4.__wrap(ret);\n    }\n    /**\n    * @param {Uint8Array} data\n    * @returns {Ipv4}\n    */\n    static new(data) {\n        var ptr0 = passArray8ToWasm0(data, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.ipv4_new(ptr0, len0);\n        return Ipv4.__wrap(ret);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    ip() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.ipv4_ip(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n*/\nexport class Ipv6 {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Ipv6.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_ipv6_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.ipv6_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {Ipv6}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.ipv6_from_bytes(ptr0, len0);\n        return Ipv6.__wrap(ret);\n    }\n    /**\n    * @param {Uint8Array} data\n    * @returns {Ipv6}\n    */\n    static new(data) {\n        var ptr0 = passArray8ToWasm0(data, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.ipv6_new(ptr0, len0);\n        return Ipv6.__wrap(ret);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    ip() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.ipv6_ip(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n*/\nexport class KESSignature {\n\n    static __wrap(ptr) {\n        const obj = Object.create(KESSignature.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_kessignature_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.kessignature_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {KESSignature}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.kessignature_from_bytes(ptr0, len0);\n        return KESSignature.__wrap(ret);\n    }\n}\n/**\n*/\nexport class KESVKey {\n\n    static __wrap(ptr) {\n        const obj = Object.create(KESVKey.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_kesvkey_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.kesvkey_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} prefix\n    * @returns {string}\n    */\n    to_bech32(prefix) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passStringToWasm0(prefix, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.kesvkey_to_bech32(retptr, this.ptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} bech_str\n    * @returns {KESVKey}\n    */\n    static from_bech32(bech_str) {\n        var ptr0 = passStringToWasm0(bech_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.kesvkey_from_bech32(ptr0, len0);\n        return KESVKey.__wrap(ret);\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {KESVKey}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.kesvkey_from_bytes(ptr0, len0);\n        return KESVKey.__wrap(ret);\n    }\n}\n/**\n*/\nexport class Language {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Language.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_language_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.language_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {Language}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.language_from_bytes(ptr0, len0);\n        return Language.__wrap(ret);\n    }\n    /**\n    * @returns {Language}\n    */\n    static new_plutus_v1() {\n        var ret = wasm.language_new_plutus_v1();\n        return Language.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    kind() {\n        var ret = wasm.language_kind(this.ptr);\n        return ret >>> 0;\n    }\n}\n/**\n*/\nexport class Languages {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Languages.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_languages_free(ptr);\n    }\n    /**\n    * @returns {Languages}\n    */\n    static new() {\n        var ret = wasm.languages_new();\n        return Languages.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.languages_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} index\n    * @returns {Language}\n    */\n    get(index) {\n        var ret = wasm.languages_get(this.ptr, index);\n        return Language.__wrap(ret);\n    }\n    /**\n    * @param {Language} elem\n    */\n    add(elem) {\n        _assertClass(elem, Language);\n        var ptr0 = elem.ptr;\n        elem.ptr = 0;\n        wasm.languages_add(this.ptr, ptr0);\n    }\n}\n/**\n*/\nexport class LegacyDaedalusPrivateKey {\n\n    static __wrap(ptr) {\n        const obj = Object.create(LegacyDaedalusPrivateKey.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_legacydaedalusprivatekey_free(ptr);\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {LegacyDaedalusPrivateKey}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.legacydaedalusprivatekey_from_bytes(ptr0, len0);\n        return LegacyDaedalusPrivateKey.__wrap(ret);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    as_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.legacydaedalusprivatekey_as_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    chaincode() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.legacydaedalusprivatekey_chaincode(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n*/\nexport class LinearFee {\n\n    static __wrap(ptr) {\n        const obj = Object.create(LinearFee.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_linearfee_free(ptr);\n    }\n    /**\n    * @returns {BigNum}\n    */\n    constant() {\n        var ret = wasm.linearfee_constant(this.ptr);\n        return BigNum.__wrap(ret);\n    }\n    /**\n    * @returns {BigNum}\n    */\n    coefficient() {\n        var ret = wasm.linearfee_coefficient(this.ptr);\n        return BigNum.__wrap(ret);\n    }\n    /**\n    * @param {BigNum} coefficient\n    * @param {BigNum} constant\n    * @returns {LinearFee}\n    */\n    static new(coefficient, constant) {\n        _assertClass(coefficient, BigNum);\n        _assertClass(constant, BigNum);\n        var ret = wasm.linearfee_new(coefficient.ptr, constant.ptr);\n        return LinearFee.__wrap(ret);\n    }\n}\n/**\n*/\nexport class MIRToStakeCredentials {\n\n    static __wrap(ptr) {\n        const obj = Object.create(MIRToStakeCredentials.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_mirtostakecredentials_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.mirtostakecredentials_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {MIRToStakeCredentials}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.mirtostakecredentials_from_bytes(ptr0, len0);\n        return MIRToStakeCredentials.__wrap(ret);\n    }\n    /**\n    * @returns {MIRToStakeCredentials}\n    */\n    static new() {\n        var ret = wasm.mirtostakecredentials_new();\n        return MIRToStakeCredentials.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.mirtostakecredentials_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {StakeCredential} cred\n    * @param {Int} delta\n    * @returns {Int | undefined}\n    */\n    insert(cred, delta) {\n        _assertClass(cred, StakeCredential);\n        _assertClass(delta, Int);\n        var ret = wasm.mirtostakecredentials_insert(this.ptr, cred.ptr, delta.ptr);\n        return ret === 0 ? undefined : Int.__wrap(ret);\n    }\n    /**\n    * @param {StakeCredential} cred\n    * @returns {Int | undefined}\n    */\n    get(cred) {\n        _assertClass(cred, StakeCredential);\n        var ret = wasm.mirtostakecredentials_get(this.ptr, cred.ptr);\n        return ret === 0 ? undefined : Int.__wrap(ret);\n    }\n    /**\n    * @returns {StakeCredentials}\n    */\n    keys() {\n        var ret = wasm.mirtostakecredentials_keys(this.ptr);\n        return StakeCredentials.__wrap(ret);\n    }\n}\n/**\n*/\nexport class MetadataList {\n\n    static __wrap(ptr) {\n        const obj = Object.create(MetadataList.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_metadatalist_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.metadatalist_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {MetadataList}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.metadatalist_from_bytes(ptr0, len0);\n        return MetadataList.__wrap(ret);\n    }\n    /**\n    * @returns {MetadataList}\n    */\n    static new() {\n        var ret = wasm.metadatalist_new();\n        return MetadataList.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.metadatalist_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} index\n    * @returns {TransactionMetadatum}\n    */\n    get(index) {\n        var ret = wasm.metadatalist_get(this.ptr, index);\n        return TransactionMetadatum.__wrap(ret);\n    }\n    /**\n    * @param {TransactionMetadatum} elem\n    */\n    add(elem) {\n        _assertClass(elem, TransactionMetadatum);\n        wasm.metadatalist_add(this.ptr, elem.ptr);\n    }\n}\n/**\n*/\nexport class MetadataMap {\n\n    static __wrap(ptr) {\n        const obj = Object.create(MetadataMap.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_metadatamap_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.metadatamap_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {MetadataMap}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.metadatamap_from_bytes(ptr0, len0);\n        return MetadataMap.__wrap(ret);\n    }\n    /**\n    * @returns {MetadataMap}\n    */\n    static new() {\n        var ret = wasm.metadatamap_new();\n        return MetadataMap.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.metadatamap_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {TransactionMetadatum} key\n    * @param {TransactionMetadatum} value\n    * @returns {TransactionMetadatum | undefined}\n    */\n    insert(key, value) {\n        _assertClass(key, TransactionMetadatum);\n        _assertClass(value, TransactionMetadatum);\n        var ret = wasm.metadatamap_insert(this.ptr, key.ptr, value.ptr);\n        return ret === 0 ? undefined : TransactionMetadatum.__wrap(ret);\n    }\n    /**\n    * @param {string} key\n    * @param {TransactionMetadatum} value\n    * @returns {TransactionMetadatum | undefined}\n    */\n    insert_str(key, value) {\n        var ptr0 = passStringToWasm0(key, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        _assertClass(value, TransactionMetadatum);\n        var ret = wasm.metadatamap_insert_str(this.ptr, ptr0, len0, value.ptr);\n        return ret === 0 ? undefined : TransactionMetadatum.__wrap(ret);\n    }\n    /**\n    * @param {number} key\n    * @param {TransactionMetadatum} value\n    * @returns {TransactionMetadatum | undefined}\n    */\n    insert_i32(key, value) {\n        _assertClass(value, TransactionMetadatum);\n        var ret = wasm.metadatamap_insert_i32(this.ptr, key, value.ptr);\n        return ret === 0 ? undefined : TransactionMetadatum.__wrap(ret);\n    }\n    /**\n    * @param {TransactionMetadatum} key\n    * @returns {TransactionMetadatum}\n    */\n    get(key) {\n        _assertClass(key, TransactionMetadatum);\n        var ret = wasm.metadatamap_get(this.ptr, key.ptr);\n        return TransactionMetadatum.__wrap(ret);\n    }\n    /**\n    * @param {string} key\n    * @returns {TransactionMetadatum}\n    */\n    get_str(key) {\n        var ptr0 = passStringToWasm0(key, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.metadatamap_get_str(this.ptr, ptr0, len0);\n        return TransactionMetadatum.__wrap(ret);\n    }\n    /**\n    * @param {number} key\n    * @returns {TransactionMetadatum}\n    */\n    get_i32(key) {\n        var ret = wasm.metadatamap_get_i32(this.ptr, key);\n        return TransactionMetadatum.__wrap(ret);\n    }\n    /**\n    * @param {TransactionMetadatum} key\n    * @returns {boolean}\n    */\n    has(key) {\n        _assertClass(key, TransactionMetadatum);\n        var ret = wasm.metadatamap_has(this.ptr, key.ptr);\n        return ret !== 0;\n    }\n    /**\n    * @returns {MetadataList}\n    */\n    keys() {\n        var ret = wasm.metadatamap_keys(this.ptr);\n        return MetadataList.__wrap(ret);\n    }\n}\n/**\n*/\nexport class Mint {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Mint.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_mint_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.mint_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {Mint}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.mint_from_bytes(ptr0, len0);\n        return Mint.__wrap(ret);\n    }\n    /**\n    * @returns {Mint}\n    */\n    static new() {\n        var ret = wasm.mint_new();\n        return Mint.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.mint_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {ScriptHash} key\n    * @param {MintAssets} value\n    * @returns {MintAssets | undefined}\n    */\n    insert(key, value) {\n        _assertClass(key, ScriptHash);\n        _assertClass(value, MintAssets);\n        var ret = wasm.mint_insert(this.ptr, key.ptr, value.ptr);\n        return ret === 0 ? undefined : MintAssets.__wrap(ret);\n    }\n    /**\n    * @param {ScriptHash} key\n    * @returns {MintAssets | undefined}\n    */\n    get(key) {\n        _assertClass(key, ScriptHash);\n        var ret = wasm.mint_get(this.ptr, key.ptr);\n        return ret === 0 ? undefined : MintAssets.__wrap(ret);\n    }\n    /**\n    * @returns {ScriptHashes}\n    */\n    keys() {\n        var ret = wasm.mint_keys(this.ptr);\n        return ScriptHashes.__wrap(ret);\n    }\n}\n/**\n*/\nexport class MintAssets {\n\n    static __wrap(ptr) {\n        const obj = Object.create(MintAssets.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_mintassets_free(ptr);\n    }\n    /**\n    * @returns {MintAssets}\n    */\n    static new() {\n        var ret = wasm.mintassets_new();\n        return MintAssets.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.mintassets_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {AssetName} key\n    * @param {Int} value\n    * @returns {Int | undefined}\n    */\n    insert(key, value) {\n        _assertClass(key, AssetName);\n        _assertClass(value, Int);\n        var ptr0 = value.ptr;\n        value.ptr = 0;\n        var ret = wasm.mintassets_insert(this.ptr, key.ptr, ptr0);\n        return ret === 0 ? undefined : Int.__wrap(ret);\n    }\n    /**\n    * @param {AssetName} key\n    * @returns {Int | undefined}\n    */\n    get(key) {\n        _assertClass(key, AssetName);\n        var ret = wasm.mintassets_get(this.ptr, key.ptr);\n        return ret === 0 ? undefined : Int.__wrap(ret);\n    }\n    /**\n    * @returns {AssetNames}\n    */\n    keys() {\n        var ret = wasm.mintassets_keys(this.ptr);\n        return AssetNames.__wrap(ret);\n    }\n}\n/**\n*/\nexport class MoveInstantaneousReward {\n\n    static __wrap(ptr) {\n        const obj = Object.create(MoveInstantaneousReward.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_moveinstantaneousreward_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.moveinstantaneousreward_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {MoveInstantaneousReward}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.moveinstantaneousreward_from_bytes(ptr0, len0);\n        return MoveInstantaneousReward.__wrap(ret);\n    }\n    /**\n    * @param {number} pot\n    * @param {BigNum} amount\n    * @returns {MoveInstantaneousReward}\n    */\n    static new_to_other_pot(pot, amount) {\n        _assertClass(amount, BigNum);\n        var ret = wasm.moveinstantaneousreward_new_to_other_pot(pot, amount.ptr);\n        return MoveInstantaneousReward.__wrap(ret);\n    }\n    /**\n    * @param {number} pot\n    * @param {MIRToStakeCredentials} amounts\n    * @returns {MoveInstantaneousReward}\n    */\n    static new_to_stake_creds(pot, amounts) {\n        _assertClass(amounts, MIRToStakeCredentials);\n        var ret = wasm.moveinstantaneousreward_new_to_stake_creds(pot, amounts.ptr);\n        return MoveInstantaneousReward.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    pot() {\n        var ret = wasm.moveinstantaneousreward_pot(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {number}\n    */\n    kind() {\n        var ret = wasm.moveinstantaneousreward_kind(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {BigNum | undefined}\n    */\n    as_to_other_pot() {\n        var ret = wasm.moveinstantaneousreward_as_to_other_pot(this.ptr);\n        return ret === 0 ? undefined : BigNum.__wrap(ret);\n    }\n    /**\n    * @returns {MIRToStakeCredentials | undefined}\n    */\n    as_to_stake_creds() {\n        var ret = wasm.moveinstantaneousreward_as_to_stake_creds(this.ptr);\n        return ret === 0 ? undefined : MIRToStakeCredentials.__wrap(ret);\n    }\n}\n/**\n*/\nexport class MoveInstantaneousRewardsCert {\n\n    static __wrap(ptr) {\n        const obj = Object.create(MoveInstantaneousRewardsCert.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_moveinstantaneousrewardscert_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.moveinstantaneousrewardscert_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {MoveInstantaneousRewardsCert}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.moveinstantaneousrewardscert_from_bytes(ptr0, len0);\n        return MoveInstantaneousRewardsCert.__wrap(ret);\n    }\n    /**\n    * @returns {MoveInstantaneousReward}\n    */\n    move_instantaneous_reward() {\n        var ret = wasm.moveinstantaneousrewardscert_move_instantaneous_reward(this.ptr);\n        return MoveInstantaneousReward.__wrap(ret);\n    }\n    /**\n    * @param {MoveInstantaneousReward} move_instantaneous_reward\n    * @returns {MoveInstantaneousRewardsCert}\n    */\n    static new(move_instantaneous_reward) {\n        _assertClass(move_instantaneous_reward, MoveInstantaneousReward);\n        var ret = wasm.moveinstantaneousrewardscert_new(move_instantaneous_reward.ptr);\n        return MoveInstantaneousRewardsCert.__wrap(ret);\n    }\n}\n/**\n*/\nexport class MultiAsset {\n\n    static __wrap(ptr) {\n        const obj = Object.create(MultiAsset.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_multiasset_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.multiasset_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {MultiAsset}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.multiasset_from_bytes(ptr0, len0);\n        return MultiAsset.__wrap(ret);\n    }\n    /**\n    * @returns {MultiAsset}\n    */\n    static new() {\n        var ret = wasm.multiasset_new();\n        return MultiAsset.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.multiasset_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {ScriptHash} key\n    * @param {Assets} value\n    * @returns {Assets | undefined}\n    */\n    insert(key, value) {\n        _assertClass(key, ScriptHash);\n        _assertClass(value, Assets);\n        var ret = wasm.multiasset_insert(this.ptr, key.ptr, value.ptr);\n        return ret === 0 ? undefined : Assets.__wrap(ret);\n    }\n    /**\n    * @param {ScriptHash} key\n    * @returns {Assets | undefined}\n    */\n    get(key) {\n        _assertClass(key, ScriptHash);\n        var ret = wasm.multiasset_get(this.ptr, key.ptr);\n        return ret === 0 ? undefined : Assets.__wrap(ret);\n    }\n    /**\n    * @returns {ScriptHashes}\n    */\n    keys() {\n        var ret = wasm.multiasset_keys(this.ptr);\n        return ScriptHashes.__wrap(ret);\n    }\n    /**\n    * removes an asset from the list if the result is 0 or less\n    * @param {MultiAsset} rhs_ma\n    * @returns {MultiAsset}\n    */\n    sub(rhs_ma) {\n        _assertClass(rhs_ma, MultiAsset);\n        var ret = wasm.multiasset_sub(this.ptr, rhs_ma.ptr);\n        return MultiAsset.__wrap(ret);\n    }\n}\n/**\n*/\nexport class MultiHostName {\n\n    static __wrap(ptr) {\n        const obj = Object.create(MultiHostName.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_multihostname_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.multihostname_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {MultiHostName}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.multihostname_from_bytes(ptr0, len0);\n        return MultiHostName.__wrap(ret);\n    }\n    /**\n    * @returns {DNSRecordSRV}\n    */\n    dns_name() {\n        var ret = wasm.multihostname_dns_name(this.ptr);\n        return DNSRecordSRV.__wrap(ret);\n    }\n    /**\n    * @param {DNSRecordSRV} dns_name\n    * @returns {MultiHostName}\n    */\n    static new(dns_name) {\n        _assertClass(dns_name, DNSRecordSRV);\n        var ret = wasm.multihostname_new(dns_name.ptr);\n        return MultiHostName.__wrap(ret);\n    }\n}\n/**\n*/\nexport class NativeScript {\n\n    static __wrap(ptr) {\n        const obj = Object.create(NativeScript.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_nativescript_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.nativescript_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {NativeScript}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.nativescript_from_bytes(ptr0, len0);\n        return NativeScript.__wrap(ret);\n    }\n    /**\n    * @param {number} namespace\n    * @returns {ScriptHash}\n    */\n    hash(namespace) {\n        var ret = wasm.nativescript_hash(this.ptr, namespace);\n        return ScriptHash.__wrap(ret);\n    }\n    /**\n    * @param {ScriptPubkey} script_pubkey\n    * @returns {NativeScript}\n    */\n    static new_script_pubkey(script_pubkey) {\n        _assertClass(script_pubkey, ScriptPubkey);\n        var ret = wasm.nativescript_new_script_pubkey(script_pubkey.ptr);\n        return NativeScript.__wrap(ret);\n    }\n    /**\n    * @param {ScriptAll} script_all\n    * @returns {NativeScript}\n    */\n    static new_script_all(script_all) {\n        _assertClass(script_all, ScriptAll);\n        var ret = wasm.nativescript_new_script_all(script_all.ptr);\n        return NativeScript.__wrap(ret);\n    }\n    /**\n    * @param {ScriptAny} script_any\n    * @returns {NativeScript}\n    */\n    static new_script_any(script_any) {\n        _assertClass(script_any, ScriptAny);\n        var ret = wasm.nativescript_new_script_any(script_any.ptr);\n        return NativeScript.__wrap(ret);\n    }\n    /**\n    * @param {ScriptNOfK} script_n_of_k\n    * @returns {NativeScript}\n    */\n    static new_script_n_of_k(script_n_of_k) {\n        _assertClass(script_n_of_k, ScriptNOfK);\n        var ret = wasm.nativescript_new_script_n_of_k(script_n_of_k.ptr);\n        return NativeScript.__wrap(ret);\n    }\n    /**\n    * @param {TimelockStart} timelock_start\n    * @returns {NativeScript}\n    */\n    static new_timelock_start(timelock_start) {\n        _assertClass(timelock_start, TimelockStart);\n        var ret = wasm.nativescript_new_timelock_start(timelock_start.ptr);\n        return NativeScript.__wrap(ret);\n    }\n    /**\n    * @param {TimelockExpiry} timelock_expiry\n    * @returns {NativeScript}\n    */\n    static new_timelock_expiry(timelock_expiry) {\n        _assertClass(timelock_expiry, TimelockExpiry);\n        var ret = wasm.nativescript_new_timelock_expiry(timelock_expiry.ptr);\n        return NativeScript.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    kind() {\n        var ret = wasm.nativescript_kind(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {ScriptPubkey | undefined}\n    */\n    as_script_pubkey() {\n        var ret = wasm.nativescript_as_script_pubkey(this.ptr);\n        return ret === 0 ? undefined : ScriptPubkey.__wrap(ret);\n    }\n    /**\n    * @returns {ScriptAll | undefined}\n    */\n    as_script_all() {\n        var ret = wasm.nativescript_as_script_all(this.ptr);\n        return ret === 0 ? undefined : ScriptAll.__wrap(ret);\n    }\n    /**\n    * @returns {ScriptAny | undefined}\n    */\n    as_script_any() {\n        var ret = wasm.nativescript_as_script_any(this.ptr);\n        return ret === 0 ? undefined : ScriptAny.__wrap(ret);\n    }\n    /**\n    * @returns {ScriptNOfK | undefined}\n    */\n    as_script_n_of_k() {\n        var ret = wasm.nativescript_as_script_n_of_k(this.ptr);\n        return ret === 0 ? undefined : ScriptNOfK.__wrap(ret);\n    }\n    /**\n    * @returns {TimelockStart | undefined}\n    */\n    as_timelock_start() {\n        var ret = wasm.nativescript_as_timelock_start(this.ptr);\n        return ret === 0 ? undefined : TimelockStart.__wrap(ret);\n    }\n    /**\n    * @returns {TimelockExpiry | undefined}\n    */\n    as_timelock_expiry() {\n        var ret = wasm.nativescript_as_timelock_expiry(this.ptr);\n        return ret === 0 ? undefined : TimelockExpiry.__wrap(ret);\n    }\n}\n/**\n*/\nexport class NativeScripts {\n\n    static __wrap(ptr) {\n        const obj = Object.create(NativeScripts.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_nativescripts_free(ptr);\n    }\n    /**\n    * @returns {NativeScripts}\n    */\n    static new() {\n        var ret = wasm.nativescripts_new();\n        return NativeScripts.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.nativescripts_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} index\n    * @returns {NativeScript}\n    */\n    get(index) {\n        var ret = wasm.nativescripts_get(this.ptr, index);\n        return NativeScript.__wrap(ret);\n    }\n    /**\n    * @param {NativeScript} elem\n    */\n    add(elem) {\n        _assertClass(elem, NativeScript);\n        wasm.nativescripts_add(this.ptr, elem.ptr);\n    }\n}\n/**\n*/\nexport class NetworkId {\n\n    static __wrap(ptr) {\n        const obj = Object.create(NetworkId.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_networkid_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.networkid_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {NetworkId}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.networkid_from_bytes(ptr0, len0);\n        return NetworkId.__wrap(ret);\n    }\n    /**\n    * @returns {NetworkId}\n    */\n    static testnet() {\n        var ret = wasm.networkid_testnet();\n        return NetworkId.__wrap(ret);\n    }\n    /**\n    * @returns {NetworkId}\n    */\n    static mainnet() {\n        var ret = wasm.networkid_mainnet();\n        return NetworkId.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    kind() {\n        var ret = wasm.networkid_kind(this.ptr);\n        return ret >>> 0;\n    }\n}\n/**\n*/\nexport class NetworkInfo {\n\n    static __wrap(ptr) {\n        const obj = Object.create(NetworkInfo.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_networkinfo_free(ptr);\n    }\n    /**\n    * @param {number} network_id\n    * @param {number} protocol_magic\n    * @returns {NetworkInfo}\n    */\n    static new(network_id, protocol_magic) {\n        var ret = wasm.networkinfo_new(network_id, protocol_magic);\n        return NetworkInfo.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    network_id() {\n        var ret = wasm.networkinfo_network_id(this.ptr);\n        return ret;\n    }\n    /**\n    * @returns {number}\n    */\n    protocol_magic() {\n        var ret = wasm.networkinfo_protocol_magic(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {NetworkInfo}\n    */\n    static testnet() {\n        var ret = wasm.networkinfo_testnet();\n        return NetworkInfo.__wrap(ret);\n    }\n    /**\n    * @returns {NetworkInfo}\n    */\n    static mainnet() {\n        var ret = wasm.networkinfo_mainnet();\n        return NetworkInfo.__wrap(ret);\n    }\n}\n/**\n*/\nexport class Nonce {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Nonce.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_nonce_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.nonce_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {Nonce}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.nonce_from_bytes(ptr0, len0);\n        return Nonce.__wrap(ret);\n    }\n    /**\n    * @returns {Nonce}\n    */\n    static new_identity() {\n        var ret = wasm.nonce_new_identity();\n        return Nonce.__wrap(ret);\n    }\n    /**\n    * @param {Uint8Array} hash\n    * @returns {Nonce}\n    */\n    static new_from_hash(hash) {\n        var ptr0 = passArray8ToWasm0(hash, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.nonce_new_from_hash(ptr0, len0);\n        return Nonce.__wrap(ret);\n    }\n    /**\n    * @returns {Uint8Array | undefined}\n    */\n    get_hash() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.nonce_get_hash(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            let v0;\n            if (r0 !== 0) {\n                v0 = getArrayU8FromWasm0(r0, r1).slice();\n                wasm.__wbindgen_free(r0, r1 * 1);\n            }\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n*/\nexport class OperationalCert {\n\n    static __wrap(ptr) {\n        const obj = Object.create(OperationalCert.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_operationalcert_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.operationalcert_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {OperationalCert}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.operationalcert_from_bytes(ptr0, len0);\n        return OperationalCert.__wrap(ret);\n    }\n    /**\n    * @returns {KESVKey}\n    */\n    hot_vkey() {\n        var ret = wasm.operationalcert_hot_vkey(this.ptr);\n        return KESVKey.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    sequence_number() {\n        var ret = wasm.operationalcert_sequence_number(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {number}\n    */\n    kes_period() {\n        var ret = wasm.operationalcert_kes_period(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {Ed25519Signature}\n    */\n    sigma() {\n        var ret = wasm.operationalcert_sigma(this.ptr);\n        return Ed25519Signature.__wrap(ret);\n    }\n    /**\n    * @param {KESVKey} hot_vkey\n    * @param {number} sequence_number\n    * @param {number} kes_period\n    * @param {Ed25519Signature} sigma\n    * @returns {OperationalCert}\n    */\n    static new(hot_vkey, sequence_number, kes_period, sigma) {\n        _assertClass(hot_vkey, KESVKey);\n        _assertClass(sigma, Ed25519Signature);\n        var ret = wasm.operationalcert_new(hot_vkey.ptr, sequence_number, kes_period, sigma.ptr);\n        return OperationalCert.__wrap(ret);\n    }\n}\n/**\n*/\nexport class PlutusData {\n\n    static __wrap(ptr) {\n        const obj = Object.create(PlutusData.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_plutusdata_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.plutusdata_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {PlutusData}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.plutusdata_from_bytes(ptr0, len0);\n        return PlutusData.__wrap(ret);\n    }\n    /**\n    * @param {ConstrPlutusData} constr_plutus_data\n    * @returns {PlutusData}\n    */\n    static new_constr_plutus_data(constr_plutus_data) {\n        _assertClass(constr_plutus_data, ConstrPlutusData);\n        var ret = wasm.plutusdata_new_constr_plutus_data(constr_plutus_data.ptr);\n        return PlutusData.__wrap(ret);\n    }\n    /**\n    * @param {PlutusMap} map\n    * @returns {PlutusData}\n    */\n    static new_map(map) {\n        _assertClass(map, PlutusMap);\n        var ret = wasm.plutusdata_new_map(map.ptr);\n        return PlutusData.__wrap(ret);\n    }\n    /**\n    * @param {PlutusList} list\n    * @returns {PlutusData}\n    */\n    static new_list(list) {\n        _assertClass(list, PlutusList);\n        var ret = wasm.plutusdata_new_list(list.ptr);\n        return PlutusData.__wrap(ret);\n    }\n    /**\n    * @param {BigInt} integer\n    * @returns {PlutusData}\n    */\n    static new_integer(integer) {\n        _assertClass(integer, BigInt);\n        var ret = wasm.plutusdata_new_integer(integer.ptr);\n        return PlutusData.__wrap(ret);\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {PlutusData}\n    */\n    static new_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.plutusdata_new_bytes(ptr0, len0);\n        return PlutusData.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    kind() {\n        var ret = wasm.plutusdata_kind(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {ConstrPlutusData | undefined}\n    */\n    as_constr_plutus_data() {\n        var ret = wasm.plutusdata_as_constr_plutus_data(this.ptr);\n        return ret === 0 ? undefined : ConstrPlutusData.__wrap(ret);\n    }\n    /**\n    * @returns {PlutusMap | undefined}\n    */\n    as_map() {\n        var ret = wasm.plutusdata_as_map(this.ptr);\n        return ret === 0 ? undefined : PlutusMap.__wrap(ret);\n    }\n    /**\n    * @returns {PlutusList | undefined}\n    */\n    as_list() {\n        var ret = wasm.plutusdata_as_list(this.ptr);\n        return ret === 0 ? undefined : PlutusList.__wrap(ret);\n    }\n    /**\n    * @returns {BigInt | undefined}\n    */\n    as_integer() {\n        var ret = wasm.plutusdata_as_integer(this.ptr);\n        return ret === 0 ? undefined : BigInt.__wrap(ret);\n    }\n    /**\n    * @returns {Uint8Array | undefined}\n    */\n    as_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.plutusdata_as_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            let v0;\n            if (r0 !== 0) {\n                v0 = getArrayU8FromWasm0(r0, r1).slice();\n                wasm.__wbindgen_free(r0, r1 * 1);\n            }\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n*/\nexport class PlutusList {\n\n    static __wrap(ptr) {\n        const obj = Object.create(PlutusList.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_plutuslist_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.plutuslist_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {PlutusList}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.plutuslist_from_bytes(ptr0, len0);\n        return PlutusList.__wrap(ret);\n    }\n    /**\n    * @returns {PlutusList}\n    */\n    static new() {\n        var ret = wasm.plutuslist_new();\n        return PlutusList.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.plutuslist_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} index\n    * @returns {PlutusData}\n    */\n    get(index) {\n        var ret = wasm.plutuslist_get(this.ptr, index);\n        return PlutusData.__wrap(ret);\n    }\n    /**\n    * @param {PlutusData} elem\n    */\n    add(elem) {\n        _assertClass(elem, PlutusData);\n        wasm.plutuslist_add(this.ptr, elem.ptr);\n    }\n}\n/**\n*/\nexport class PlutusMap {\n\n    static __wrap(ptr) {\n        const obj = Object.create(PlutusMap.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_plutusmap_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.plutusmap_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {PlutusMap}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.plutusmap_from_bytes(ptr0, len0);\n        return PlutusMap.__wrap(ret);\n    }\n    /**\n    * @returns {PlutusMap}\n    */\n    static new() {\n        var ret = wasm.plutusmap_new();\n        return PlutusMap.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.plutusmap_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {PlutusData} key\n    * @param {PlutusData} value\n    * @returns {PlutusData | undefined}\n    */\n    insert(key, value) {\n        _assertClass(key, PlutusData);\n        _assertClass(value, PlutusData);\n        var ret = wasm.plutusmap_insert(this.ptr, key.ptr, value.ptr);\n        return ret === 0 ? undefined : PlutusData.__wrap(ret);\n    }\n    /**\n    * @param {PlutusData} key\n    * @returns {PlutusData | undefined}\n    */\n    get(key) {\n        _assertClass(key, PlutusData);\n        var ret = wasm.plutusmap_get(this.ptr, key.ptr);\n        return ret === 0 ? undefined : PlutusData.__wrap(ret);\n    }\n    /**\n    * @returns {PlutusList}\n    */\n    keys() {\n        var ret = wasm.plutusmap_keys(this.ptr);\n        return PlutusList.__wrap(ret);\n    }\n}\n/**\n*/\nexport class PlutusScript {\n\n    static __wrap(ptr) {\n        const obj = Object.create(PlutusScript.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_plutusscript_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.plutusscript_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {PlutusScript}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.plutusscript_from_bytes(ptr0, len0);\n        return PlutusScript.__wrap(ret);\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {PlutusScript}\n    */\n    static new(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.plutusscript_new(ptr0, len0);\n        return PlutusScript.__wrap(ret);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.plutusscript_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n*/\nexport class PlutusScripts {\n\n    static __wrap(ptr) {\n        const obj = Object.create(PlutusScripts.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_plutusscripts_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.plutusscripts_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {PlutusScripts}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.plutusscripts_from_bytes(ptr0, len0);\n        return PlutusScripts.__wrap(ret);\n    }\n    /**\n    * @returns {PlutusScripts}\n    */\n    static new() {\n        var ret = wasm.plutusscripts_new();\n        return PlutusScripts.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.plutusscripts_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} index\n    * @returns {PlutusScript}\n    */\n    get(index) {\n        var ret = wasm.plutusscripts_get(this.ptr, index);\n        return PlutusScript.__wrap(ret);\n    }\n    /**\n    * @param {PlutusScript} elem\n    */\n    add(elem) {\n        _assertClass(elem, PlutusScript);\n        wasm.plutusscripts_add(this.ptr, elem.ptr);\n    }\n}\n/**\n*/\nexport class Pointer {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Pointer.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_pointer_free(ptr);\n    }\n    /**\n    * @param {number} slot\n    * @param {number} tx_index\n    * @param {number} cert_index\n    * @returns {Pointer}\n    */\n    static new(slot, tx_index, cert_index) {\n        var ret = wasm.pointer_new(slot, tx_index, cert_index);\n        return Pointer.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    slot() {\n        var ret = wasm.pointer_slot(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {number}\n    */\n    tx_index() {\n        var ret = wasm.pointer_tx_index(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {number}\n    */\n    cert_index() {\n        var ret = wasm.pointer_cert_index(this.ptr);\n        return ret >>> 0;\n    }\n}\n/**\n*/\nexport class PointerAddress {\n\n    static __wrap(ptr) {\n        const obj = Object.create(PointerAddress.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_pointeraddress_free(ptr);\n    }\n    /**\n    * @param {number} network\n    * @param {StakeCredential} payment\n    * @param {Pointer} stake\n    * @returns {PointerAddress}\n    */\n    static new(network, payment, stake) {\n        _assertClass(payment, StakeCredential);\n        _assertClass(stake, Pointer);\n        var ret = wasm.pointeraddress_new(network, payment.ptr, stake.ptr);\n        return PointerAddress.__wrap(ret);\n    }\n    /**\n    * @returns {StakeCredential}\n    */\n    payment_cred() {\n        var ret = wasm.pointeraddress_payment_cred(this.ptr);\n        return StakeCredential.__wrap(ret);\n    }\n    /**\n    * @returns {Pointer}\n    */\n    stake_pointer() {\n        var ret = wasm.pointeraddress_stake_pointer(this.ptr);\n        return Pointer.__wrap(ret);\n    }\n    /**\n    * @returns {Address}\n    */\n    to_address() {\n        var ret = wasm.pointeraddress_to_address(this.ptr);\n        return Address.__wrap(ret);\n    }\n    /**\n    * @param {Address} addr\n    * @returns {PointerAddress | undefined}\n    */\n    static from_address(addr) {\n        _assertClass(addr, Address);\n        var ret = wasm.pointeraddress_from_address(addr.ptr);\n        return ret === 0 ? undefined : PointerAddress.__wrap(ret);\n    }\n}\n/**\n*/\nexport class PoolMetadata {\n\n    static __wrap(ptr) {\n        const obj = Object.create(PoolMetadata.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_poolmetadata_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.poolmetadata_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {PoolMetadata}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.poolmetadata_from_bytes(ptr0, len0);\n        return PoolMetadata.__wrap(ret);\n    }\n    /**\n    * @returns {URL}\n    */\n    url() {\n        var ret = wasm.poolmetadata_url(this.ptr);\n        return URL.__wrap(ret);\n    }\n    /**\n    * @returns {PoolMetadataHash}\n    */\n    pool_metadata_hash() {\n        var ret = wasm.poolmetadata_pool_metadata_hash(this.ptr);\n        return PoolMetadataHash.__wrap(ret);\n    }\n    /**\n    * @param {URL} url\n    * @param {PoolMetadataHash} pool_metadata_hash\n    * @returns {PoolMetadata}\n    */\n    static new(url, pool_metadata_hash) {\n        _assertClass(url, URL);\n        _assertClass(pool_metadata_hash, PoolMetadataHash);\n        var ret = wasm.poolmetadata_new(url.ptr, pool_metadata_hash.ptr);\n        return PoolMetadata.__wrap(ret);\n    }\n}\n/**\n*/\nexport class PoolMetadataHash {\n\n    static __wrap(ptr) {\n        const obj = Object.create(PoolMetadataHash.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_poolmetadatahash_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.poolmetadatahash_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} prefix\n    * @returns {string}\n    */\n    to_bech32(prefix) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passStringToWasm0(prefix, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.poolmetadatahash_to_bech32(retptr, this.ptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} bech_str\n    * @returns {PoolMetadataHash}\n    */\n    static from_bech32(bech_str) {\n        var ptr0 = passStringToWasm0(bech_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.poolmetadatahash_from_bech32(ptr0, len0);\n        return PoolMetadataHash.__wrap(ret);\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {PoolMetadataHash}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.poolmetadatahash_from_bytes(ptr0, len0);\n        return PoolMetadataHash.__wrap(ret);\n    }\n}\n/**\n*/\nexport class PoolParams {\n\n    static __wrap(ptr) {\n        const obj = Object.create(PoolParams.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_poolparams_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.poolparams_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {PoolParams}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.poolparams_from_bytes(ptr0, len0);\n        return PoolParams.__wrap(ret);\n    }\n    /**\n    * @returns {Ed25519KeyHash}\n    */\n    operator() {\n        var ret = wasm.poolparams_operator(this.ptr);\n        return Ed25519KeyHash.__wrap(ret);\n    }\n    /**\n    * @returns {VRFKeyHash}\n    */\n    vrf_keyhash() {\n        var ret = wasm.poolparams_vrf_keyhash(this.ptr);\n        return VRFKeyHash.__wrap(ret);\n    }\n    /**\n    * @returns {BigNum}\n    */\n    pledge() {\n        var ret = wasm.poolparams_pledge(this.ptr);\n        return BigNum.__wrap(ret);\n    }\n    /**\n    * @returns {BigNum}\n    */\n    cost() {\n        var ret = wasm.poolparams_cost(this.ptr);\n        return BigNum.__wrap(ret);\n    }\n    /**\n    * @returns {UnitInterval}\n    */\n    margin() {\n        var ret = wasm.poolparams_margin(this.ptr);\n        return UnitInterval.__wrap(ret);\n    }\n    /**\n    * @returns {RewardAddress}\n    */\n    reward_account() {\n        var ret = wasm.poolparams_reward_account(this.ptr);\n        return RewardAddress.__wrap(ret);\n    }\n    /**\n    * @returns {Ed25519KeyHashes}\n    */\n    pool_owners() {\n        var ret = wasm.poolparams_pool_owners(this.ptr);\n        return Ed25519KeyHashes.__wrap(ret);\n    }\n    /**\n    * @returns {Relays}\n    */\n    relays() {\n        var ret = wasm.poolparams_relays(this.ptr);\n        return Relays.__wrap(ret);\n    }\n    /**\n    * @returns {PoolMetadata | undefined}\n    */\n    pool_metadata() {\n        var ret = wasm.poolparams_pool_metadata(this.ptr);\n        return ret === 0 ? undefined : PoolMetadata.__wrap(ret);\n    }\n    /**\n    * @param {Ed25519KeyHash} operator\n    * @param {VRFKeyHash} vrf_keyhash\n    * @param {BigNum} pledge\n    * @param {BigNum} cost\n    * @param {UnitInterval} margin\n    * @param {RewardAddress} reward_account\n    * @param {Ed25519KeyHashes} pool_owners\n    * @param {Relays} relays\n    * @param {PoolMetadata | undefined} pool_metadata\n    * @returns {PoolParams}\n    */\n    static new(operator, vrf_keyhash, pledge, cost, margin, reward_account, pool_owners, relays, pool_metadata) {\n        _assertClass(operator, Ed25519KeyHash);\n        _assertClass(vrf_keyhash, VRFKeyHash);\n        _assertClass(pledge, BigNum);\n        _assertClass(cost, BigNum);\n        _assertClass(margin, UnitInterval);\n        _assertClass(reward_account, RewardAddress);\n        _assertClass(pool_owners, Ed25519KeyHashes);\n        _assertClass(relays, Relays);\n        let ptr0 = 0;\n        if (!isLikeNone(pool_metadata)) {\n            _assertClass(pool_metadata, PoolMetadata);\n            ptr0 = pool_metadata.ptr;\n            pool_metadata.ptr = 0;\n        }\n        var ret = wasm.poolparams_new(operator.ptr, vrf_keyhash.ptr, pledge.ptr, cost.ptr, margin.ptr, reward_account.ptr, pool_owners.ptr, relays.ptr, ptr0);\n        return PoolParams.__wrap(ret);\n    }\n}\n/**\n*/\nexport class PoolRegistration {\n\n    static __wrap(ptr) {\n        const obj = Object.create(PoolRegistration.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_poolregistration_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.poolregistration_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {PoolRegistration}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.poolregistration_from_bytes(ptr0, len0);\n        return PoolRegistration.__wrap(ret);\n    }\n    /**\n    * @returns {PoolParams}\n    */\n    pool_params() {\n        var ret = wasm.poolregistration_pool_params(this.ptr);\n        return PoolParams.__wrap(ret);\n    }\n    /**\n    * @param {PoolParams} pool_params\n    * @returns {PoolRegistration}\n    */\n    static new(pool_params) {\n        _assertClass(pool_params, PoolParams);\n        var ret = wasm.poolregistration_new(pool_params.ptr);\n        return PoolRegistration.__wrap(ret);\n    }\n}\n/**\n*/\nexport class PoolRetirement {\n\n    static __wrap(ptr) {\n        const obj = Object.create(PoolRetirement.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_poolretirement_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.poolretirement_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {PoolRetirement}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.poolretirement_from_bytes(ptr0, len0);\n        return PoolRetirement.__wrap(ret);\n    }\n    /**\n    * @returns {Ed25519KeyHash}\n    */\n    pool_keyhash() {\n        var ret = wasm.poolretirement_pool_keyhash(this.ptr);\n        return Ed25519KeyHash.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    epoch() {\n        var ret = wasm.poolretirement_epoch(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {Ed25519KeyHash} pool_keyhash\n    * @param {number} epoch\n    * @returns {PoolRetirement}\n    */\n    static new(pool_keyhash, epoch) {\n        _assertClass(pool_keyhash, Ed25519KeyHash);\n        var ret = wasm.poolretirement_new(pool_keyhash.ptr, epoch);\n        return PoolRetirement.__wrap(ret);\n    }\n}\n/**\n*/\nexport class PrivateKey {\n\n    static __wrap(ptr) {\n        const obj = Object.create(PrivateKey.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_privatekey_free(ptr);\n    }\n    /**\n    * @returns {PublicKey}\n    */\n    to_public() {\n        var ret = wasm.privatekey_to_public(this.ptr);\n        return PublicKey.__wrap(ret);\n    }\n    /**\n    * @returns {PrivateKey}\n    */\n    static generate_ed25519() {\n        var ret = wasm.privatekey_generate_ed25519();\n        return PrivateKey.__wrap(ret);\n    }\n    /**\n    * @returns {PrivateKey}\n    */\n    static generate_ed25519extended() {\n        var ret = wasm.privatekey_generate_ed25519extended();\n        return PrivateKey.__wrap(ret);\n    }\n    /**\n    * Get private key from its bech32 representation\n    * ```javascript\n    * PrivateKey.from_bech32(&#39;ed25519_sk1ahfetf02qwwg4dkq7mgp4a25lx5vh9920cr5wnxmpzz9906qvm8qwvlts0&#39;);\n    * ```\n    * For an extended 25519 key\n    * ```javascript\n    * PrivateKey.from_bech32(&#39;ed25519e_sk1gqwl4szuwwh6d0yk3nsqcc6xxc3fpvjlevgwvt60df59v8zd8f8prazt8ln3lmz096ux3xvhhvm3ca9wj2yctdh3pnw0szrma07rt5gl748fp&#39;);\n    * ```\n    * @param {string} bech32_str\n    * @returns {PrivateKey}\n    */\n    static from_bech32(bech32_str) {\n        var ptr0 = passStringToWasm0(bech32_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.privatekey_from_bech32(ptr0, len0);\n        return PrivateKey.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_bech32() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.privatekey_to_bech32(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    as_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.privatekey_as_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {PrivateKey}\n    */\n    static from_extended_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.privatekey_from_extended_bytes(ptr0, len0);\n        return PrivateKey.__wrap(ret);\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {PrivateKey}\n    */\n    static from_normal_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.privatekey_from_normal_bytes(ptr0, len0);\n        return PrivateKey.__wrap(ret);\n    }\n    /**\n    * @param {Uint8Array} message\n    * @returns {Ed25519Signature}\n    */\n    sign(message) {\n        var ptr0 = passArray8ToWasm0(message, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.privatekey_sign(this.ptr, ptr0, len0);\n        return Ed25519Signature.__wrap(ret);\n    }\n}\n/**\n*/\nexport class ProposedProtocolParameterUpdates {\n\n    static __wrap(ptr) {\n        const obj = Object.create(ProposedProtocolParameterUpdates.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_proposedprotocolparameterupdates_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.proposedprotocolparameterupdates_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {ProposedProtocolParameterUpdates}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.proposedprotocolparameterupdates_from_bytes(ptr0, len0);\n        return ProposedProtocolParameterUpdates.__wrap(ret);\n    }\n    /**\n    * @returns {ProposedProtocolParameterUpdates}\n    */\n    static new() {\n        var ret = wasm.proposedprotocolparameterupdates_new();\n        return ProposedProtocolParameterUpdates.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.proposedprotocolparameterupdates_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {GenesisHash} key\n    * @param {ProtocolParamUpdate} value\n    * @returns {ProtocolParamUpdate | undefined}\n    */\n    insert(key, value) {\n        _assertClass(key, GenesisHash);\n        _assertClass(value, ProtocolParamUpdate);\n        var ret = wasm.proposedprotocolparameterupdates_insert(this.ptr, key.ptr, value.ptr);\n        return ret === 0 ? undefined : ProtocolParamUpdate.__wrap(ret);\n    }\n    /**\n    * @param {GenesisHash} key\n    * @returns {ProtocolParamUpdate | undefined}\n    */\n    get(key) {\n        _assertClass(key, GenesisHash);\n        var ret = wasm.proposedprotocolparameterupdates_get(this.ptr, key.ptr);\n        return ret === 0 ? undefined : ProtocolParamUpdate.__wrap(ret);\n    }\n    /**\n    * @returns {GenesisHashes}\n    */\n    keys() {\n        var ret = wasm.proposedprotocolparameterupdates_keys(this.ptr);\n        return GenesisHashes.__wrap(ret);\n    }\n}\n/**\n*/\nexport class ProtocolParamUpdate {\n\n    static __wrap(ptr) {\n        const obj = Object.create(ProtocolParamUpdate.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_protocolparamupdate_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.protocolparamupdate_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {ProtocolParamUpdate}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.protocolparamupdate_from_bytes(ptr0, len0);\n        return ProtocolParamUpdate.__wrap(ret);\n    }\n    /**\n    * @param {BigNum} minfee_a\n    */\n    set_minfee_a(minfee_a) {\n        _assertClass(minfee_a, BigNum);\n        wasm.protocolparamupdate_set_minfee_a(this.ptr, minfee_a.ptr);\n    }\n    /**\n    * @returns {BigNum | undefined}\n    */\n    minfee_a() {\n        var ret = wasm.protocolparamupdate_minfee_a(this.ptr);\n        return ret === 0 ? undefined : BigNum.__wrap(ret);\n    }\n    /**\n    * @param {BigNum} minfee_b\n    */\n    set_minfee_b(minfee_b) {\n        _assertClass(minfee_b, BigNum);\n        wasm.protocolparamupdate_set_minfee_b(this.ptr, minfee_b.ptr);\n    }\n    /**\n    * @returns {BigNum | undefined}\n    */\n    minfee_b() {\n        var ret = wasm.protocolparamupdate_minfee_b(this.ptr);\n        return ret === 0 ? undefined : BigNum.__wrap(ret);\n    }\n    /**\n    * @param {number} max_block_body_size\n    */\n    set_max_block_body_size(max_block_body_size) {\n        wasm.protocolparamupdate_set_max_block_body_size(this.ptr, max_block_body_size);\n    }\n    /**\n    * @returns {number | undefined}\n    */\n    max_block_body_size() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.protocolparamupdate_max_block_body_size(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1 >>> 0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {number} max_tx_size\n    */\n    set_max_tx_size(max_tx_size) {\n        wasm.protocolparamupdate_set_max_tx_size(this.ptr, max_tx_size);\n    }\n    /**\n    * @returns {number | undefined}\n    */\n    max_tx_size() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.protocolparamupdate_max_tx_size(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1 >>> 0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {number} max_block_header_size\n    */\n    set_max_block_header_size(max_block_header_size) {\n        wasm.protocolparamupdate_set_max_block_header_size(this.ptr, max_block_header_size);\n    }\n    /**\n    * @returns {number | undefined}\n    */\n    max_block_header_size() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.protocolparamupdate_max_block_header_size(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1 >>> 0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {BigNum} key_deposit\n    */\n    set_key_deposit(key_deposit) {\n        _assertClass(key_deposit, BigNum);\n        wasm.protocolparamupdate_set_key_deposit(this.ptr, key_deposit.ptr);\n    }\n    /**\n    * @returns {BigNum | undefined}\n    */\n    key_deposit() {\n        var ret = wasm.protocolparamupdate_key_deposit(this.ptr);\n        return ret === 0 ? undefined : BigNum.__wrap(ret);\n    }\n    /**\n    * @param {BigNum} pool_deposit\n    */\n    set_pool_deposit(pool_deposit) {\n        _assertClass(pool_deposit, BigNum);\n        wasm.protocolparamupdate_set_pool_deposit(this.ptr, pool_deposit.ptr);\n    }\n    /**\n    * @returns {BigNum | undefined}\n    */\n    pool_deposit() {\n        var ret = wasm.protocolparamupdate_pool_deposit(this.ptr);\n        return ret === 0 ? undefined : BigNum.__wrap(ret);\n    }\n    /**\n    * @param {number} max_epoch\n    */\n    set_max_epoch(max_epoch) {\n        wasm.protocolparamupdate_set_max_epoch(this.ptr, max_epoch);\n    }\n    /**\n    * @returns {number | undefined}\n    */\n    max_epoch() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.protocolparamupdate_max_epoch(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1 >>> 0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {number} n_opt\n    */\n    set_n_opt(n_opt) {\n        wasm.protocolparamupdate_set_n_opt(this.ptr, n_opt);\n    }\n    /**\n    * @returns {number | undefined}\n    */\n    n_opt() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.protocolparamupdate_n_opt(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1 >>> 0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {UnitInterval} pool_pledge_influence\n    */\n    set_pool_pledge_influence(pool_pledge_influence) {\n        _assertClass(pool_pledge_influence, UnitInterval);\n        wasm.protocolparamupdate_set_pool_pledge_influence(this.ptr, pool_pledge_influence.ptr);\n    }\n    /**\n    * @returns {UnitInterval | undefined}\n    */\n    pool_pledge_influence() {\n        var ret = wasm.protocolparamupdate_pool_pledge_influence(this.ptr);\n        return ret === 0 ? undefined : UnitInterval.__wrap(ret);\n    }\n    /**\n    * @param {UnitInterval} expansion_rate\n    */\n    set_expansion_rate(expansion_rate) {\n        _assertClass(expansion_rate, UnitInterval);\n        wasm.protocolparamupdate_set_expansion_rate(this.ptr, expansion_rate.ptr);\n    }\n    /**\n    * @returns {UnitInterval | undefined}\n    */\n    expansion_rate() {\n        var ret = wasm.protocolparamupdate_expansion_rate(this.ptr);\n        return ret === 0 ? undefined : UnitInterval.__wrap(ret);\n    }\n    /**\n    * @param {UnitInterval} treasury_growth_rate\n    */\n    set_treasury_growth_rate(treasury_growth_rate) {\n        _assertClass(treasury_growth_rate, UnitInterval);\n        wasm.protocolparamupdate_set_treasury_growth_rate(this.ptr, treasury_growth_rate.ptr);\n    }\n    /**\n    * @returns {UnitInterval | undefined}\n    */\n    treasury_growth_rate() {\n        var ret = wasm.protocolparamupdate_treasury_growth_rate(this.ptr);\n        return ret === 0 ? undefined : UnitInterval.__wrap(ret);\n    }\n    /**\n    * @param {UnitInterval} d\n    */\n    set_d(d) {\n        _assertClass(d, UnitInterval);\n        wasm.protocolparamupdate_set_d(this.ptr, d.ptr);\n    }\n    /**\n    * @returns {UnitInterval | undefined}\n    */\n    d() {\n        var ret = wasm.protocolparamupdate_d(this.ptr);\n        return ret === 0 ? undefined : UnitInterval.__wrap(ret);\n    }\n    /**\n    * @param {Nonce} extra_entropy\n    */\n    set_extra_entropy(extra_entropy) {\n        _assertClass(extra_entropy, Nonce);\n        wasm.protocolparamupdate_set_extra_entropy(this.ptr, extra_entropy.ptr);\n    }\n    /**\n    * @returns {Nonce | undefined}\n    */\n    extra_entropy() {\n        var ret = wasm.protocolparamupdate_extra_entropy(this.ptr);\n        return ret === 0 ? undefined : Nonce.__wrap(ret);\n    }\n    /**\n    * @param {ProtocolVersions} protocol_version\n    */\n    set_protocol_version(protocol_version) {\n        _assertClass(protocol_version, ProtocolVersions);\n        wasm.protocolparamupdate_set_protocol_version(this.ptr, protocol_version.ptr);\n    }\n    /**\n    * @returns {ProtocolVersions | undefined}\n    */\n    protocol_version() {\n        var ret = wasm.protocolparamupdate_protocol_version(this.ptr);\n        return ret === 0 ? undefined : ProtocolVersions.__wrap(ret);\n    }\n    /**\n    * @param {BigNum} min_pool_cost\n    */\n    set_min_pool_cost(min_pool_cost) {\n        _assertClass(min_pool_cost, BigNum);\n        wasm.protocolparamupdate_set_min_pool_cost(this.ptr, min_pool_cost.ptr);\n    }\n    /**\n    * @returns {BigNum | undefined}\n    */\n    min_pool_cost() {\n        var ret = wasm.protocolparamupdate_min_pool_cost(this.ptr);\n        return ret === 0 ? undefined : BigNum.__wrap(ret);\n    }\n    /**\n    * @param {BigNum} ada_per_utxo_byte\n    */\n    set_ada_per_utxo_byte(ada_per_utxo_byte) {\n        _assertClass(ada_per_utxo_byte, BigNum);\n        wasm.protocolparamupdate_set_ada_per_utxo_byte(this.ptr, ada_per_utxo_byte.ptr);\n    }\n    /**\n    * @returns {BigNum | undefined}\n    */\n    ada_per_utxo_byte() {\n        var ret = wasm.protocolparamupdate_ada_per_utxo_byte(this.ptr);\n        return ret === 0 ? undefined : BigNum.__wrap(ret);\n    }\n    /**\n    * @param {Costmdls} cost_models\n    */\n    set_cost_models(cost_models) {\n        _assertClass(cost_models, Costmdls);\n        wasm.protocolparamupdate_set_cost_models(this.ptr, cost_models.ptr);\n    }\n    /**\n    * @returns {Costmdls | undefined}\n    */\n    cost_models() {\n        var ret = wasm.protocolparamupdate_cost_models(this.ptr);\n        return ret === 0 ? undefined : Costmdls.__wrap(ret);\n    }\n    /**\n    * @param {ExUnitPrices} execution_costs\n    */\n    set_execution_costs(execution_costs) {\n        _assertClass(execution_costs, ExUnitPrices);\n        wasm.protocolparamupdate_set_execution_costs(this.ptr, execution_costs.ptr);\n    }\n    /**\n    * @returns {ExUnitPrices | undefined}\n    */\n    execution_costs() {\n        var ret = wasm.protocolparamupdate_execution_costs(this.ptr);\n        return ret === 0 ? undefined : ExUnitPrices.__wrap(ret);\n    }\n    /**\n    * @param {ExUnits} max_tx_ex_units\n    */\n    set_max_tx_ex_units(max_tx_ex_units) {\n        _assertClass(max_tx_ex_units, ExUnits);\n        wasm.protocolparamupdate_set_max_tx_ex_units(this.ptr, max_tx_ex_units.ptr);\n    }\n    /**\n    * @returns {ExUnits | undefined}\n    */\n    max_tx_ex_units() {\n        var ret = wasm.protocolparamupdate_max_tx_ex_units(this.ptr);\n        return ret === 0 ? undefined : ExUnits.__wrap(ret);\n    }\n    /**\n    * @param {ExUnits} max_block_ex_units\n    */\n    set_max_block_ex_units(max_block_ex_units) {\n        _assertClass(max_block_ex_units, ExUnits);\n        wasm.protocolparamupdate_set_max_block_ex_units(this.ptr, max_block_ex_units.ptr);\n    }\n    /**\n    * @returns {ExUnits | undefined}\n    */\n    max_block_ex_units() {\n        var ret = wasm.protocolparamupdate_max_block_ex_units(this.ptr);\n        return ret === 0 ? undefined : ExUnits.__wrap(ret);\n    }\n    /**\n    * @param {number} max_value_size\n    */\n    set_max_value_size(max_value_size) {\n        wasm.protocolparamupdate_set_max_value_size(this.ptr, max_value_size);\n    }\n    /**\n    * @returns {number | undefined}\n    */\n    max_value_size() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.protocolparamupdate_max_value_size(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1 >>> 0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {ProtocolParamUpdate}\n    */\n    static new() {\n        var ret = wasm.protocolparamupdate_new();\n        return ProtocolParamUpdate.__wrap(ret);\n    }\n}\n/**\n*/\nexport class ProtocolVersion {\n\n    static __wrap(ptr) {\n        const obj = Object.create(ProtocolVersion.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_protocolversion_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.protocolversion_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {ProtocolVersion}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.protocolversion_from_bytes(ptr0, len0);\n        return ProtocolVersion.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    major() {\n        var ret = wasm.protocolversion_major(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {number}\n    */\n    minor() {\n        var ret = wasm.protocolversion_minor(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} major\n    * @param {number} minor\n    * @returns {ProtocolVersion}\n    */\n    static new(major, minor) {\n        var ret = wasm.protocolversion_new(major, minor);\n        return ProtocolVersion.__wrap(ret);\n    }\n}\n/**\n*/\nexport class ProtocolVersions {\n\n    static __wrap(ptr) {\n        const obj = Object.create(ProtocolVersions.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_protocolversions_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.protocolversions_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {ProtocolVersions}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.protocolversions_from_bytes(ptr0, len0);\n        return ProtocolVersions.__wrap(ret);\n    }\n    /**\n    * @returns {ProtocolVersions}\n    */\n    static new() {\n        var ret = wasm.protocolversions_new();\n        return ProtocolVersions.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.protocolversions_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} index\n    * @returns {ProtocolVersion}\n    */\n    get(index) {\n        var ret = wasm.protocolversions_get(this.ptr, index);\n        return ProtocolVersion.__wrap(ret);\n    }\n    /**\n    * @param {ProtocolVersion} elem\n    */\n    add(elem) {\n        _assertClass(elem, ProtocolVersion);\n        wasm.protocolversions_add(this.ptr, elem.ptr);\n    }\n}\n/**\n* ED25519 key used as public key\n*/\nexport class PublicKey {\n\n    static __wrap(ptr) {\n        const obj = Object.create(PublicKey.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_publickey_free(ptr);\n    }\n    /**\n    * Get public key from its bech32 representation\n    * Example:\n    * ```javascript\n    * const pkey = PublicKey.from_bech32(&#39;ed25519_pk1dgaagyh470y66p899txcl3r0jaeaxu6yd7z2dxyk55qcycdml8gszkxze2&#39;);\n    * ```\n    * @param {string} bech32_str\n    * @returns {PublicKey}\n    */\n    static from_bech32(bech32_str) {\n        var ptr0 = passStringToWasm0(bech32_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.publickey_from_bech32(ptr0, len0);\n        return PublicKey.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_bech32() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.publickey_to_bech32(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    as_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.publickey_as_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {PublicKey}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.publickey_from_bytes(ptr0, len0);\n        return PublicKey.__wrap(ret);\n    }\n    /**\n    * @param {Uint8Array} data\n    * @param {Ed25519Signature} signature\n    * @returns {boolean}\n    */\n    verify(data, signature) {\n        var ptr0 = passArray8ToWasm0(data, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        _assertClass(signature, Ed25519Signature);\n        var ret = wasm.publickey_verify(this.ptr, ptr0, len0, signature.ptr);\n        return ret !== 0;\n    }\n    /**\n    * @returns {Ed25519KeyHash}\n    */\n    hash() {\n        var ret = wasm.publickey_hash(this.ptr);\n        return Ed25519KeyHash.__wrap(ret);\n    }\n}\n/**\n*/\nexport class PublicKeys {\n\n    static __wrap(ptr) {\n        const obj = Object.create(PublicKeys.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_publickeys_free(ptr);\n    }\n    /**\n    */\n    constructor() {\n        var ret = wasm.publickeys_new();\n        return PublicKeys.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    size() {\n        var ret = wasm.publickeys_size(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} index\n    * @returns {PublicKey}\n    */\n    get(index) {\n        var ret = wasm.publickeys_get(this.ptr, index);\n        return PublicKey.__wrap(ret);\n    }\n    /**\n    * @param {PublicKey} key\n    */\n    add(key) {\n        _assertClass(key, PublicKey);\n        wasm.publickeys_add(this.ptr, key.ptr);\n    }\n}\n/**\n*/\nexport class Redeemer {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Redeemer.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_redeemer_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.redeemer_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {Redeemer}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.redeemer_from_bytes(ptr0, len0);\n        return Redeemer.__wrap(ret);\n    }\n    /**\n    * @returns {RedeemerTag}\n    */\n    tag() {\n        var ret = wasm.redeemer_tag(this.ptr);\n        return RedeemerTag.__wrap(ret);\n    }\n    /**\n    * @returns {BigNum}\n    */\n    index() {\n        var ret = wasm.redeemer_index(this.ptr);\n        return BigNum.__wrap(ret);\n    }\n    /**\n    * @returns {PlutusData}\n    */\n    data() {\n        var ret = wasm.redeemer_data(this.ptr);\n        return PlutusData.__wrap(ret);\n    }\n    /**\n    * @returns {ExUnits}\n    */\n    ex_units() {\n        var ret = wasm.redeemer_ex_units(this.ptr);\n        return ExUnits.__wrap(ret);\n    }\n    /**\n    * @param {RedeemerTag} tag\n    * @param {BigNum} index\n    * @param {PlutusData} data\n    * @param {ExUnits} ex_units\n    * @returns {Redeemer}\n    */\n    static new(tag, index, data, ex_units) {\n        _assertClass(tag, RedeemerTag);\n        _assertClass(index, BigNum);\n        _assertClass(data, PlutusData);\n        _assertClass(ex_units, ExUnits);\n        var ret = wasm.redeemer_new(tag.ptr, index.ptr, data.ptr, ex_units.ptr);\n        return Redeemer.__wrap(ret);\n    }\n}\n/**\n*/\nexport class RedeemerTag {\n\n    static __wrap(ptr) {\n        const obj = Object.create(RedeemerTag.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_redeemertag_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.redeemertag_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {RedeemerTag}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.redeemertag_from_bytes(ptr0, len0);\n        return RedeemerTag.__wrap(ret);\n    }\n    /**\n    * @returns {RedeemerTag}\n    */\n    static new_spend() {\n        var ret = wasm.redeemertag_new_spend();\n        return RedeemerTag.__wrap(ret);\n    }\n    /**\n    * @returns {RedeemerTag}\n    */\n    static new_mint() {\n        var ret = wasm.redeemertag_new_mint();\n        return RedeemerTag.__wrap(ret);\n    }\n    /**\n    * @returns {RedeemerTag}\n    */\n    static new_cert() {\n        var ret = wasm.redeemertag_new_cert();\n        return RedeemerTag.__wrap(ret);\n    }\n    /**\n    * @returns {RedeemerTag}\n    */\n    static new_reward() {\n        var ret = wasm.redeemertag_new_reward();\n        return RedeemerTag.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    kind() {\n        var ret = wasm.redeemertag_kind(this.ptr);\n        return ret >>> 0;\n    }\n}\n/**\n*/\nexport class Redeemers {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Redeemers.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_redeemers_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.redeemers_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {Redeemers}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.redeemers_from_bytes(ptr0, len0);\n        return Redeemers.__wrap(ret);\n    }\n    /**\n    * @returns {Redeemers}\n    */\n    static new() {\n        var ret = wasm.redeemers_new();\n        return Redeemers.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.redeemers_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} index\n    * @returns {Redeemer}\n    */\n    get(index) {\n        var ret = wasm.redeemers_get(this.ptr, index);\n        return Redeemer.__wrap(ret);\n    }\n    /**\n    * @param {Redeemer} elem\n    */\n    add(elem) {\n        _assertClass(elem, Redeemer);\n        wasm.redeemers_add(this.ptr, elem.ptr);\n    }\n}\n/**\n*/\nexport class Relay {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Relay.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_relay_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.relay_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {Relay}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.relay_from_bytes(ptr0, len0);\n        return Relay.__wrap(ret);\n    }\n    /**\n    * @param {SingleHostAddr} single_host_addr\n    * @returns {Relay}\n    */\n    static new_single_host_addr(single_host_addr) {\n        _assertClass(single_host_addr, SingleHostAddr);\n        var ret = wasm.relay_new_single_host_addr(single_host_addr.ptr);\n        return Relay.__wrap(ret);\n    }\n    /**\n    * @param {SingleHostName} single_host_name\n    * @returns {Relay}\n    */\n    static new_single_host_name(single_host_name) {\n        _assertClass(single_host_name, SingleHostName);\n        var ret = wasm.relay_new_single_host_name(single_host_name.ptr);\n        return Relay.__wrap(ret);\n    }\n    /**\n    * @param {MultiHostName} multi_host_name\n    * @returns {Relay}\n    */\n    static new_multi_host_name(multi_host_name) {\n        _assertClass(multi_host_name, MultiHostName);\n        var ret = wasm.relay_new_multi_host_name(multi_host_name.ptr);\n        return Relay.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    kind() {\n        var ret = wasm.relay_kind(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {SingleHostAddr | undefined}\n    */\n    as_single_host_addr() {\n        var ret = wasm.relay_as_single_host_addr(this.ptr);\n        return ret === 0 ? undefined : SingleHostAddr.__wrap(ret);\n    }\n    /**\n    * @returns {SingleHostName | undefined}\n    */\n    as_single_host_name() {\n        var ret = wasm.relay_as_single_host_name(this.ptr);\n        return ret === 0 ? undefined : SingleHostName.__wrap(ret);\n    }\n    /**\n    * @returns {MultiHostName | undefined}\n    */\n    as_multi_host_name() {\n        var ret = wasm.relay_as_multi_host_name(this.ptr);\n        return ret === 0 ? undefined : MultiHostName.__wrap(ret);\n    }\n}\n/**\n*/\nexport class Relays {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Relays.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_relays_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.relays_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {Relays}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.relays_from_bytes(ptr0, len0);\n        return Relays.__wrap(ret);\n    }\n    /**\n    * @returns {Relays}\n    */\n    static new() {\n        var ret = wasm.relays_new();\n        return Relays.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.relays_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} index\n    * @returns {Relay}\n    */\n    get(index) {\n        var ret = wasm.relays_get(this.ptr, index);\n        return Relay.__wrap(ret);\n    }\n    /**\n    * @param {Relay} elem\n    */\n    add(elem) {\n        _assertClass(elem, Relay);\n        wasm.relays_add(this.ptr, elem.ptr);\n    }\n}\n/**\n*/\nexport class RewardAddress {\n\n    static __wrap(ptr) {\n        const obj = Object.create(RewardAddress.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rewardaddress_free(ptr);\n    }\n    /**\n    * @param {number} network\n    * @param {StakeCredential} payment\n    * @returns {RewardAddress}\n    */\n    static new(network, payment) {\n        _assertClass(payment, StakeCredential);\n        var ret = wasm.rewardaddress_new(network, payment.ptr);\n        return RewardAddress.__wrap(ret);\n    }\n    /**\n    * @returns {StakeCredential}\n    */\n    payment_cred() {\n        var ret = wasm.rewardaddress_payment_cred(this.ptr);\n        return StakeCredential.__wrap(ret);\n    }\n    /**\n    * @returns {Address}\n    */\n    to_address() {\n        var ret = wasm.rewardaddress_to_address(this.ptr);\n        return Address.__wrap(ret);\n    }\n    /**\n    * @param {Address} addr\n    * @returns {RewardAddress | undefined}\n    */\n    static from_address(addr) {\n        _assertClass(addr, Address);\n        var ret = wasm.rewardaddress_from_address(addr.ptr);\n        return ret === 0 ? undefined : RewardAddress.__wrap(ret);\n    }\n}\n/**\n*/\nexport class RewardAddresses {\n\n    static __wrap(ptr) {\n        const obj = Object.create(RewardAddresses.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rewardaddresses_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rewardaddresses_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {RewardAddresses}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.rewardaddresses_from_bytes(ptr0, len0);\n        return RewardAddresses.__wrap(ret);\n    }\n    /**\n    * @returns {RewardAddresses}\n    */\n    static new() {\n        var ret = wasm.rewardaddresses_new();\n        return RewardAddresses.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.rewardaddresses_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} index\n    * @returns {RewardAddress}\n    */\n    get(index) {\n        var ret = wasm.rewardaddresses_get(this.ptr, index);\n        return RewardAddress.__wrap(ret);\n    }\n    /**\n    * @param {RewardAddress} elem\n    */\n    add(elem) {\n        _assertClass(elem, RewardAddress);\n        wasm.rewardaddresses_add(this.ptr, elem.ptr);\n    }\n}\n/**\n*/\nexport class ScriptAll {\n\n    static __wrap(ptr) {\n        const obj = Object.create(ScriptAll.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_scriptall_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.scriptall_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {ScriptAll}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.scriptall_from_bytes(ptr0, len0);\n        return ScriptAll.__wrap(ret);\n    }\n    /**\n    * @returns {NativeScripts}\n    */\n    native_scripts() {\n        var ret = wasm.scriptall_native_scripts(this.ptr);\n        return NativeScripts.__wrap(ret);\n    }\n    /**\n    * @param {NativeScripts} native_scripts\n    * @returns {ScriptAll}\n    */\n    static new(native_scripts) {\n        _assertClass(native_scripts, NativeScripts);\n        var ret = wasm.scriptall_new(native_scripts.ptr);\n        return ScriptAll.__wrap(ret);\n    }\n}\n/**\n*/\nexport class ScriptAny {\n\n    static __wrap(ptr) {\n        const obj = Object.create(ScriptAny.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_scriptany_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.scriptany_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {ScriptAny}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.scriptany_from_bytes(ptr0, len0);\n        return ScriptAny.__wrap(ret);\n    }\n    /**\n    * @returns {NativeScripts}\n    */\n    native_scripts() {\n        var ret = wasm.scriptany_native_scripts(this.ptr);\n        return NativeScripts.__wrap(ret);\n    }\n    /**\n    * @param {NativeScripts} native_scripts\n    * @returns {ScriptAny}\n    */\n    static new(native_scripts) {\n        _assertClass(native_scripts, NativeScripts);\n        var ret = wasm.scriptany_new(native_scripts.ptr);\n        return ScriptAny.__wrap(ret);\n    }\n}\n/**\n*/\nexport class ScriptDataHash {\n\n    static __wrap(ptr) {\n        const obj = Object.create(ScriptDataHash.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_scriptdatahash_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.scriptdatahash_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} prefix\n    * @returns {string}\n    */\n    to_bech32(prefix) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passStringToWasm0(prefix, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.scriptdatahash_to_bech32(retptr, this.ptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} bech_str\n    * @returns {ScriptDataHash}\n    */\n    static from_bech32(bech_str) {\n        var ptr0 = passStringToWasm0(bech_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.scriptdatahash_from_bech32(ptr0, len0);\n        return ScriptDataHash.__wrap(ret);\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {ScriptDataHash}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.scriptdatahash_from_bytes(ptr0, len0);\n        return ScriptDataHash.__wrap(ret);\n    }\n}\n/**\n*/\nexport class ScriptHash {\n\n    static __wrap(ptr) {\n        const obj = Object.create(ScriptHash.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_scripthash_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.scripthash_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} prefix\n    * @returns {string}\n    */\n    to_bech32(prefix) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passStringToWasm0(prefix, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.scripthash_to_bech32(retptr, this.ptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} bech_str\n    * @returns {ScriptHash}\n    */\n    static from_bech32(bech_str) {\n        var ptr0 = passStringToWasm0(bech_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.scripthash_from_bech32(ptr0, len0);\n        return ScriptHash.__wrap(ret);\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {ScriptHash}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.scripthash_from_bytes(ptr0, len0);\n        return ScriptHash.__wrap(ret);\n    }\n}\n/**\n*/\nexport class ScriptHashes {\n\n    static __wrap(ptr) {\n        const obj = Object.create(ScriptHashes.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_scripthashes_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.scripthashes_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {ScriptHashes}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.scripthashes_from_bytes(ptr0, len0);\n        return ScriptHashes.__wrap(ret);\n    }\n    /**\n    * @returns {ScriptHashes}\n    */\n    static new() {\n        var ret = wasm.scripthashes_new();\n        return ScriptHashes.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.scripthashes_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} index\n    * @returns {ScriptHash}\n    */\n    get(index) {\n        var ret = wasm.scripthashes_get(this.ptr, index);\n        return ScriptHash.__wrap(ret);\n    }\n    /**\n    * @param {ScriptHash} elem\n    */\n    add(elem) {\n        _assertClass(elem, ScriptHash);\n        wasm.scripthashes_add(this.ptr, elem.ptr);\n    }\n}\n/**\n*/\nexport class ScriptNOfK {\n\n    static __wrap(ptr) {\n        const obj = Object.create(ScriptNOfK.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_scriptnofk_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.scriptnofk_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {ScriptNOfK}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.scriptnofk_from_bytes(ptr0, len0);\n        return ScriptNOfK.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    n() {\n        var ret = wasm.scriptnofk_n(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {NativeScripts}\n    */\n    native_scripts() {\n        var ret = wasm.scriptnofk_native_scripts(this.ptr);\n        return NativeScripts.__wrap(ret);\n    }\n    /**\n    * @param {number} n\n    * @param {NativeScripts} native_scripts\n    * @returns {ScriptNOfK}\n    */\n    static new(n, native_scripts) {\n        _assertClass(native_scripts, NativeScripts);\n        var ret = wasm.scriptnofk_new(n, native_scripts.ptr);\n        return ScriptNOfK.__wrap(ret);\n    }\n}\n/**\n*/\nexport class ScriptPubkey {\n\n    static __wrap(ptr) {\n        const obj = Object.create(ScriptPubkey.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_scriptpubkey_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.scriptpubkey_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {ScriptPubkey}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.scriptpubkey_from_bytes(ptr0, len0);\n        return ScriptPubkey.__wrap(ret);\n    }\n    /**\n    * @returns {Ed25519KeyHash}\n    */\n    addr_keyhash() {\n        var ret = wasm.scriptpubkey_addr_keyhash(this.ptr);\n        return Ed25519KeyHash.__wrap(ret);\n    }\n    /**\n    * @param {Ed25519KeyHash} addr_keyhash\n    * @returns {ScriptPubkey}\n    */\n    static new(addr_keyhash) {\n        _assertClass(addr_keyhash, Ed25519KeyHash);\n        var ret = wasm.scriptpubkey_new(addr_keyhash.ptr);\n        return ScriptPubkey.__wrap(ret);\n    }\n}\n/**\n*/\nexport class SingleHostAddr {\n\n    static __wrap(ptr) {\n        const obj = Object.create(SingleHostAddr.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_singlehostaddr_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.singlehostaddr_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {SingleHostAddr}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.singlehostaddr_from_bytes(ptr0, len0);\n        return SingleHostAddr.__wrap(ret);\n    }\n    /**\n    * @returns {number | undefined}\n    */\n    port() {\n        var ret = wasm.singlehostaddr_port(this.ptr);\n        return ret === 0xFFFFFF ? undefined : ret;\n    }\n    /**\n    * @returns {Ipv4 | undefined}\n    */\n    ipv4() {\n        var ret = wasm.singlehostaddr_ipv4(this.ptr);\n        return ret === 0 ? undefined : Ipv4.__wrap(ret);\n    }\n    /**\n    * @returns {Ipv6 | undefined}\n    */\n    ipv6() {\n        var ret = wasm.singlehostaddr_ipv6(this.ptr);\n        return ret === 0 ? undefined : Ipv6.__wrap(ret);\n    }\n    /**\n    * @param {number | undefined} port\n    * @param {Ipv4 | undefined} ipv4\n    * @param {Ipv6 | undefined} ipv6\n    * @returns {SingleHostAddr}\n    */\n    static new(port, ipv4, ipv6) {\n        let ptr0 = 0;\n        if (!isLikeNone(ipv4)) {\n            _assertClass(ipv4, Ipv4);\n            ptr0 = ipv4.ptr;\n            ipv4.ptr = 0;\n        }\n        let ptr1 = 0;\n        if (!isLikeNone(ipv6)) {\n            _assertClass(ipv6, Ipv6);\n            ptr1 = ipv6.ptr;\n            ipv6.ptr = 0;\n        }\n        var ret = wasm.singlehostaddr_new(isLikeNone(port) ? 0xFFFFFF : port, ptr0, ptr1);\n        return SingleHostAddr.__wrap(ret);\n    }\n}\n/**\n*/\nexport class SingleHostName {\n\n    static __wrap(ptr) {\n        const obj = Object.create(SingleHostName.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_singlehostname_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.singlehostname_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {SingleHostName}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.singlehostname_from_bytes(ptr0, len0);\n        return SingleHostName.__wrap(ret);\n    }\n    /**\n    * @returns {number | undefined}\n    */\n    port() {\n        var ret = wasm.singlehostname_port(this.ptr);\n        return ret === 0xFFFFFF ? undefined : ret;\n    }\n    /**\n    * @returns {DNSRecordAorAAAA}\n    */\n    dns_name() {\n        var ret = wasm.singlehostname_dns_name(this.ptr);\n        return DNSRecordAorAAAA.__wrap(ret);\n    }\n    /**\n    * @param {number | undefined} port\n    * @param {DNSRecordAorAAAA} dns_name\n    * @returns {SingleHostName}\n    */\n    static new(port, dns_name) {\n        _assertClass(dns_name, DNSRecordAorAAAA);\n        var ret = wasm.singlehostname_new(isLikeNone(port) ? 0xFFFFFF : port, dns_name.ptr);\n        return SingleHostName.__wrap(ret);\n    }\n}\n/**\n*/\nexport class StakeCredential {\n\n    static __wrap(ptr) {\n        const obj = Object.create(StakeCredential.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_stakecredential_free(ptr);\n    }\n    /**\n    * @param {Ed25519KeyHash} hash\n    * @returns {StakeCredential}\n    */\n    static from_keyhash(hash) {\n        _assertClass(hash, Ed25519KeyHash);\n        var ret = wasm.stakecredential_from_keyhash(hash.ptr);\n        return StakeCredential.__wrap(ret);\n    }\n    /**\n    * @param {ScriptHash} hash\n    * @returns {StakeCredential}\n    */\n    static from_scripthash(hash) {\n        _assertClass(hash, ScriptHash);\n        var ret = wasm.stakecredential_from_scripthash(hash.ptr);\n        return StakeCredential.__wrap(ret);\n    }\n    /**\n    * @returns {Ed25519KeyHash | undefined}\n    */\n    to_keyhash() {\n        var ret = wasm.stakecredential_to_keyhash(this.ptr);\n        return ret === 0 ? undefined : Ed25519KeyHash.__wrap(ret);\n    }\n    /**\n    * @returns {ScriptHash | undefined}\n    */\n    to_scripthash() {\n        var ret = wasm.stakecredential_to_scripthash(this.ptr);\n        return ret === 0 ? undefined : ScriptHash.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    kind() {\n        var ret = wasm.stakecredential_kind(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.stakecredential_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {StakeCredential}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.stakecredential_from_bytes(ptr0, len0);\n        return StakeCredential.__wrap(ret);\n    }\n}\n/**\n*/\nexport class StakeCredentials {\n\n    static __wrap(ptr) {\n        const obj = Object.create(StakeCredentials.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_stakecredentials_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.stakecredentials_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {StakeCredentials}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.stakecredentials_from_bytes(ptr0, len0);\n        return StakeCredentials.__wrap(ret);\n    }\n    /**\n    * @returns {StakeCredentials}\n    */\n    static new() {\n        var ret = wasm.stakecredentials_new();\n        return StakeCredentials.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.stakecredentials_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} index\n    * @returns {StakeCredential}\n    */\n    get(index) {\n        var ret = wasm.stakecredentials_get(this.ptr, index);\n        return StakeCredential.__wrap(ret);\n    }\n    /**\n    * @param {StakeCredential} elem\n    */\n    add(elem) {\n        _assertClass(elem, StakeCredential);\n        wasm.stakecredentials_add(this.ptr, elem.ptr);\n    }\n}\n/**\n*/\nexport class StakeDelegation {\n\n    static __wrap(ptr) {\n        const obj = Object.create(StakeDelegation.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_stakedelegation_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.stakedelegation_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {StakeDelegation}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.stakedelegation_from_bytes(ptr0, len0);\n        return StakeDelegation.__wrap(ret);\n    }\n    /**\n    * @returns {StakeCredential}\n    */\n    stake_credential() {\n        var ret = wasm.stakedelegation_stake_credential(this.ptr);\n        return StakeCredential.__wrap(ret);\n    }\n    /**\n    * @returns {Ed25519KeyHash}\n    */\n    pool_keyhash() {\n        var ret = wasm.stakedelegation_pool_keyhash(this.ptr);\n        return Ed25519KeyHash.__wrap(ret);\n    }\n    /**\n    * @param {StakeCredential} stake_credential\n    * @param {Ed25519KeyHash} pool_keyhash\n    * @returns {StakeDelegation}\n    */\n    static new(stake_credential, pool_keyhash) {\n        _assertClass(stake_credential, StakeCredential);\n        _assertClass(pool_keyhash, Ed25519KeyHash);\n        var ret = wasm.stakedelegation_new(stake_credential.ptr, pool_keyhash.ptr);\n        return StakeDelegation.__wrap(ret);\n    }\n}\n/**\n*/\nexport class StakeDeregistration {\n\n    static __wrap(ptr) {\n        const obj = Object.create(StakeDeregistration.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_stakederegistration_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.stakederegistration_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {StakeDeregistration}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.stakederegistration_from_bytes(ptr0, len0);\n        return StakeDeregistration.__wrap(ret);\n    }\n    /**\n    * @returns {StakeCredential}\n    */\n    stake_credential() {\n        var ret = wasm.stakederegistration_stake_credential(this.ptr);\n        return StakeCredential.__wrap(ret);\n    }\n    /**\n    * @param {StakeCredential} stake_credential\n    * @returns {StakeDeregistration}\n    */\n    static new(stake_credential) {\n        _assertClass(stake_credential, StakeCredential);\n        var ret = wasm.stakederegistration_new(stake_credential.ptr);\n        return StakeDeregistration.__wrap(ret);\n    }\n}\n/**\n*/\nexport class StakeRegistration {\n\n    static __wrap(ptr) {\n        const obj = Object.create(StakeRegistration.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_stakeregistration_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.stakeregistration_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {StakeRegistration}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.stakeregistration_from_bytes(ptr0, len0);\n        return StakeRegistration.__wrap(ret);\n    }\n    /**\n    * @returns {StakeCredential}\n    */\n    stake_credential() {\n        var ret = wasm.stakeregistration_stake_credential(this.ptr);\n        return StakeCredential.__wrap(ret);\n    }\n    /**\n    * @param {StakeCredential} stake_credential\n    * @returns {StakeRegistration}\n    */\n    static new(stake_credential) {\n        _assertClass(stake_credential, StakeCredential);\n        var ret = wasm.stakeregistration_new(stake_credential.ptr);\n        return StakeRegistration.__wrap(ret);\n    }\n}\n/**\n*/\nexport class Strings {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Strings.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_strings_free(ptr);\n    }\n    /**\n    * @returns {Strings}\n    */\n    static new() {\n        var ret = wasm.strings_new();\n        return Strings.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.strings_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} index\n    * @returns {string}\n    */\n    get(index) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.strings_get(retptr, this.ptr, index);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} elem\n    */\n    add(elem) {\n        var ptr0 = passStringToWasm0(elem, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        wasm.strings_add(this.ptr, ptr0, len0);\n    }\n}\n/**\n*/\nexport class TimelockExpiry {\n\n    static __wrap(ptr) {\n        const obj = Object.create(TimelockExpiry.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_timelockexpiry_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.timelockexpiry_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {TimelockExpiry}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.timelockexpiry_from_bytes(ptr0, len0);\n        return TimelockExpiry.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    slot() {\n        var ret = wasm.timelockexpiry_slot(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} slot\n    * @returns {TimelockExpiry}\n    */\n    static new(slot) {\n        var ret = wasm.timelockexpiry_new(slot);\n        return TimelockExpiry.__wrap(ret);\n    }\n}\n/**\n*/\nexport class TimelockStart {\n\n    static __wrap(ptr) {\n        const obj = Object.create(TimelockStart.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_timelockstart_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.timelockstart_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {TimelockStart}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.timelockstart_from_bytes(ptr0, len0);\n        return TimelockStart.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    slot() {\n        var ret = wasm.timelockstart_slot(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} slot\n    * @returns {TimelockStart}\n    */\n    static new(slot) {\n        var ret = wasm.timelockstart_new(slot);\n        return TimelockStart.__wrap(ret);\n    }\n}\n/**\n*/\nexport class Transaction {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Transaction.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_transaction_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transaction_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {Transaction}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.transaction_from_bytes(ptr0, len0);\n        return Transaction.__wrap(ret);\n    }\n    /**\n    * @returns {TransactionBody}\n    */\n    body() {\n        var ret = wasm.transaction_body(this.ptr);\n        return TransactionBody.__wrap(ret);\n    }\n    /**\n    * @returns {TransactionWitnessSet}\n    */\n    witness_set() {\n        var ret = wasm.transaction_witness_set(this.ptr);\n        return TransactionWitnessSet.__wrap(ret);\n    }\n    /**\n    * @returns {boolean}\n    */\n    is_valid() {\n        var ret = wasm.transaction_is_valid(this.ptr);\n        return ret !== 0;\n    }\n    /**\n    * @returns {AuxiliaryData | undefined}\n    */\n    auxiliary_data() {\n        var ret = wasm.transaction_auxiliary_data(this.ptr);\n        return ret === 0 ? undefined : AuxiliaryData.__wrap(ret);\n    }\n    /**\n    * @param {boolean} valid\n    */\n    set_is_valid(valid) {\n        wasm.transaction_set_is_valid(this.ptr, valid);\n    }\n    /**\n    * @param {TransactionBody} body\n    * @param {TransactionWitnessSet} witness_set\n    * @param {AuxiliaryData | undefined} auxiliary_data\n    * @returns {Transaction}\n    */\n    static new(body, witness_set, auxiliary_data) {\n        _assertClass(body, TransactionBody);\n        _assertClass(witness_set, TransactionWitnessSet);\n        let ptr0 = 0;\n        if (!isLikeNone(auxiliary_data)) {\n            _assertClass(auxiliary_data, AuxiliaryData);\n            ptr0 = auxiliary_data.ptr;\n            auxiliary_data.ptr = 0;\n        }\n        var ret = wasm.transaction_new(body.ptr, witness_set.ptr, ptr0);\n        return Transaction.__wrap(ret);\n    }\n}\n/**\n*/\nexport class TransactionBodies {\n\n    static __wrap(ptr) {\n        const obj = Object.create(TransactionBodies.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_transactionbodies_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionbodies_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {TransactionBodies}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.transactionbodies_from_bytes(ptr0, len0);\n        return TransactionBodies.__wrap(ret);\n    }\n    /**\n    * @returns {TransactionBodies}\n    */\n    static new() {\n        var ret = wasm.transactionbodies_new();\n        return TransactionBodies.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.transactionbodies_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} index\n    * @returns {TransactionBody}\n    */\n    get(index) {\n        var ret = wasm.transactionbodies_get(this.ptr, index);\n        return TransactionBody.__wrap(ret);\n    }\n    /**\n    * @param {TransactionBody} elem\n    */\n    add(elem) {\n        _assertClass(elem, TransactionBody);\n        wasm.transactionbodies_add(this.ptr, elem.ptr);\n    }\n}\n/**\n*/\nexport class TransactionBody {\n\n    static __wrap(ptr) {\n        const obj = Object.create(TransactionBody.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_transactionbody_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionbody_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {TransactionBody}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.transactionbody_from_bytes(ptr0, len0);\n        return TransactionBody.__wrap(ret);\n    }\n    /**\n    * @returns {TransactionInputs}\n    */\n    inputs() {\n        var ret = wasm.transactionbody_inputs(this.ptr);\n        return TransactionInputs.__wrap(ret);\n    }\n    /**\n    * @returns {TransactionOutputs}\n    */\n    outputs() {\n        var ret = wasm.transactionbody_outputs(this.ptr);\n        return TransactionOutputs.__wrap(ret);\n    }\n    /**\n    * @returns {BigNum}\n    */\n    fee() {\n        var ret = wasm.transactionbody_fee(this.ptr);\n        return BigNum.__wrap(ret);\n    }\n    /**\n    * @returns {number | undefined}\n    */\n    ttl() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionbody_ttl(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1 >>> 0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Certificates} certs\n    */\n    set_certs(certs) {\n        _assertClass(certs, Certificates);\n        wasm.transactionbody_set_certs(this.ptr, certs.ptr);\n    }\n    /**\n    * @returns {Certificates | undefined}\n    */\n    certs() {\n        var ret = wasm.transactionbody_certs(this.ptr);\n        return ret === 0 ? undefined : Certificates.__wrap(ret);\n    }\n    /**\n    * @param {Withdrawals} withdrawals\n    */\n    set_withdrawals(withdrawals) {\n        _assertClass(withdrawals, Withdrawals);\n        wasm.transactionbody_set_withdrawals(this.ptr, withdrawals.ptr);\n    }\n    /**\n    * @returns {Withdrawals | undefined}\n    */\n    withdrawals() {\n        var ret = wasm.transactionbody_withdrawals(this.ptr);\n        return ret === 0 ? undefined : Withdrawals.__wrap(ret);\n    }\n    /**\n    * @param {Update} update\n    */\n    set_update(update) {\n        _assertClass(update, Update);\n        wasm.transactionbody_set_update(this.ptr, update.ptr);\n    }\n    /**\n    * @returns {Update | undefined}\n    */\n    update() {\n        var ret = wasm.transactionbody_update(this.ptr);\n        return ret === 0 ? undefined : Update.__wrap(ret);\n    }\n    /**\n    * @param {AuxiliaryDataHash} auxiliary_data_hash\n    */\n    set_auxiliary_data_hash(auxiliary_data_hash) {\n        _assertClass(auxiliary_data_hash, AuxiliaryDataHash);\n        wasm.transactionbody_set_auxiliary_data_hash(this.ptr, auxiliary_data_hash.ptr);\n    }\n    /**\n    * @returns {AuxiliaryDataHash | undefined}\n    */\n    auxiliary_data_hash() {\n        var ret = wasm.transactionbody_auxiliary_data_hash(this.ptr);\n        return ret === 0 ? undefined : AuxiliaryDataHash.__wrap(ret);\n    }\n    /**\n    * @param {number} validity_start_interval\n    */\n    set_validity_start_interval(validity_start_interval) {\n        wasm.transactionbody_set_validity_start_interval(this.ptr, validity_start_interval);\n    }\n    /**\n    * @returns {number | undefined}\n    */\n    validity_start_interval() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionbody_validity_start_interval(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1 >>> 0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Mint} mint\n    */\n    set_mint(mint) {\n        _assertClass(mint, Mint);\n        wasm.transactionbody_set_mint(this.ptr, mint.ptr);\n    }\n    /**\n    * @returns {Mint | undefined}\n    */\n    multiassets() {\n        var ret = wasm.transactionbody_multiassets(this.ptr);\n        return ret === 0 ? undefined : Mint.__wrap(ret);\n    }\n    /**\n    * @param {ScriptDataHash} script_data_hash\n    */\n    set_script_data_hash(script_data_hash) {\n        _assertClass(script_data_hash, ScriptDataHash);\n        wasm.transactionbody_set_script_data_hash(this.ptr, script_data_hash.ptr);\n    }\n    /**\n    * @returns {ScriptDataHash | undefined}\n    */\n    script_data_hash() {\n        var ret = wasm.transactionbody_script_data_hash(this.ptr);\n        return ret === 0 ? undefined : ScriptDataHash.__wrap(ret);\n    }\n    /**\n    * @param {TransactionInputs} collateral\n    */\n    set_collateral(collateral) {\n        _assertClass(collateral, TransactionInputs);\n        wasm.transactionbody_set_collateral(this.ptr, collateral.ptr);\n    }\n    /**\n    * @returns {TransactionInputs | undefined}\n    */\n    collateral() {\n        var ret = wasm.transactionbody_collateral(this.ptr);\n        return ret === 0 ? undefined : TransactionInputs.__wrap(ret);\n    }\n    /**\n    * @param {Ed25519KeyHashes} required_signers\n    */\n    set_required_signers(required_signers) {\n        _assertClass(required_signers, Ed25519KeyHashes);\n        wasm.transactionbody_set_required_signers(this.ptr, required_signers.ptr);\n    }\n    /**\n    * @returns {Ed25519KeyHashes | undefined}\n    */\n    required_signers() {\n        var ret = wasm.transactionbody_required_signers(this.ptr);\n        return ret === 0 ? undefined : Ed25519KeyHashes.__wrap(ret);\n    }\n    /**\n    * @param {NetworkId} network_id\n    */\n    set_network_id(network_id) {\n        _assertClass(network_id, NetworkId);\n        wasm.transactionbody_set_network_id(this.ptr, network_id.ptr);\n    }\n    /**\n    * @returns {NetworkId | undefined}\n    */\n    network_id() {\n        var ret = wasm.transactionbody_network_id(this.ptr);\n        return ret === 0 ? undefined : NetworkId.__wrap(ret);\n    }\n    /**\n    * @param {TransactionInputs} inputs\n    * @param {TransactionOutputs} outputs\n    * @param {BigNum} fee\n    * @param {number | undefined} ttl\n    * @returns {TransactionBody}\n    */\n    static new(inputs, outputs, fee, ttl) {\n        _assertClass(inputs, TransactionInputs);\n        _assertClass(outputs, TransactionOutputs);\n        _assertClass(fee, BigNum);\n        var ret = wasm.transactionbody_new(inputs.ptr, outputs.ptr, fee.ptr, !isLikeNone(ttl), isLikeNone(ttl) ? 0 : ttl);\n        return TransactionBody.__wrap(ret);\n    }\n}\n/**\n*/\nexport class TransactionBuilder {\n\n    static __wrap(ptr) {\n        const obj = Object.create(TransactionBuilder.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_transactionbuilder_free(ptr);\n    }\n    /**\n    * @param {Ed25519KeyHash} hash\n    * @param {TransactionInput} input\n    * @param {Value} amount\n    */\n    add_key_input(hash, input, amount) {\n        _assertClass(hash, Ed25519KeyHash);\n        _assertClass(input, TransactionInput);\n        _assertClass(amount, Value);\n        wasm.transactionbuilder_add_key_input(this.ptr, hash.ptr, input.ptr, amount.ptr);\n    }\n    /**\n    * @param {ScriptHash} hash\n    * @param {TransactionInput} input\n    * @param {Value} amount\n    */\n    add_script_input(hash, input, amount) {\n        _assertClass(hash, ScriptHash);\n        _assertClass(input, TransactionInput);\n        _assertClass(amount, Value);\n        wasm.transactionbuilder_add_script_input(this.ptr, hash.ptr, input.ptr, amount.ptr);\n    }\n    /**\n    * @param {ByronAddress} hash\n    * @param {TransactionInput} input\n    * @param {Value} amount\n    */\n    add_bootstrap_input(hash, input, amount) {\n        _assertClass(hash, ByronAddress);\n        _assertClass(input, TransactionInput);\n        _assertClass(amount, Value);\n        wasm.transactionbuilder_add_bootstrap_input(this.ptr, hash.ptr, input.ptr, amount.ptr);\n    }\n    /**\n    * @param {Address} address\n    * @param {TransactionInput} input\n    * @param {Value} amount\n    */\n    add_input(address, input, amount) {\n        _assertClass(address, Address);\n        _assertClass(input, TransactionInput);\n        _assertClass(amount, Value);\n        wasm.transactionbuilder_add_input(this.ptr, address.ptr, input.ptr, amount.ptr);\n    }\n    /**\n    * calculates how much the fee would increase if you added a given output\n    * @param {Address} address\n    * @param {TransactionInput} input\n    * @param {Value} amount\n    * @returns {BigNum}\n    */\n    fee_for_input(address, input, amount) {\n        _assertClass(address, Address);\n        _assertClass(input, TransactionInput);\n        _assertClass(amount, Value);\n        var ret = wasm.transactionbuilder_fee_for_input(this.ptr, address.ptr, input.ptr, amount.ptr);\n        return BigNum.__wrap(ret);\n    }\n    /**\n    * @param {TransactionOutput} output\n    */\n    add_output(output) {\n        _assertClass(output, TransactionOutput);\n        wasm.transactionbuilder_add_output(this.ptr, output.ptr);\n    }\n    /**\n    * calculates how much the fee would increase if you added a given output\n    * @param {TransactionOutput} output\n    * @returns {BigNum}\n    */\n    fee_for_output(output) {\n        _assertClass(output, TransactionOutput);\n        var ret = wasm.transactionbuilder_fee_for_output(this.ptr, output.ptr);\n        return BigNum.__wrap(ret);\n    }\n    /**\n    * @param {BigNum} fee\n    */\n    set_fee(fee) {\n        _assertClass(fee, BigNum);\n        wasm.transactionbuilder_set_fee(this.ptr, fee.ptr);\n    }\n    /**\n    * @param {number} ttl\n    */\n    set_ttl(ttl) {\n        wasm.transactionbuilder_set_ttl(this.ptr, ttl);\n    }\n    /**\n    * @param {number} validity_start_interval\n    */\n    set_validity_start_interval(validity_start_interval) {\n        wasm.transactionbuilder_set_validity_start_interval(this.ptr, validity_start_interval);\n    }\n    /**\n    * @param {Certificates} certs\n    */\n    set_certs(certs) {\n        _assertClass(certs, Certificates);\n        wasm.transactionbuilder_set_certs(this.ptr, certs.ptr);\n    }\n    /**\n    * @param {Withdrawals} withdrawals\n    */\n    set_withdrawals(withdrawals) {\n        _assertClass(withdrawals, Withdrawals);\n        wasm.transactionbuilder_set_withdrawals(this.ptr, withdrawals.ptr);\n    }\n    /**\n    * @param {AuxiliaryData} auxiliary_data\n    */\n    set_auxiliary_data(auxiliary_data) {\n        _assertClass(auxiliary_data, AuxiliaryData);\n        wasm.transactionbuilder_set_auxiliary_data(this.ptr, auxiliary_data.ptr);\n    }\n    /**\n    * @param {boolean} prefer_pure_change\n    */\n    set_prefer_pure_change(prefer_pure_change) {\n        wasm.transactionbuilder_set_prefer_pure_change(this.ptr, prefer_pure_change);\n    }\n    /**\n    * @param {LinearFee} linear_fee\n    * @param {BigNum} pool_deposit\n    * @param {BigNum} key_deposit\n    * @param {number} max_value_size\n    * @param {number} max_tx_size\n    * @param {BigNum} coins_per_utxo_word\n    * @returns {TransactionBuilder}\n    */\n    static new(linear_fee, pool_deposit, key_deposit, max_value_size, max_tx_size, coins_per_utxo_word) {\n        _assertClass(linear_fee, LinearFee);\n        _assertClass(pool_deposit, BigNum);\n        _assertClass(key_deposit, BigNum);\n        _assertClass(coins_per_utxo_word, BigNum);\n        var ret = wasm.transactionbuilder_new(linear_fee.ptr, pool_deposit.ptr, key_deposit.ptr, max_value_size, max_tx_size, coins_per_utxo_word.ptr);\n        return TransactionBuilder.__wrap(ret);\n    }\n    /**\n    * does not include refunds or withdrawals\n    * @returns {Value}\n    */\n    get_explicit_input() {\n        var ret = wasm.transactionbuilder_get_explicit_input(this.ptr);\n        return Value.__wrap(ret);\n    }\n    /**\n    * withdrawals and refunds\n    * @returns {Value}\n    */\n    get_implicit_input() {\n        var ret = wasm.transactionbuilder_get_implicit_input(this.ptr);\n        return Value.__wrap(ret);\n    }\n    /**\n    * does not include fee\n    * @returns {Value}\n    */\n    get_explicit_output() {\n        var ret = wasm.transactionbuilder_get_explicit_output(this.ptr);\n        return Value.__wrap(ret);\n    }\n    /**\n    * @returns {BigNum}\n    */\n    get_deposit() {\n        var ret = wasm.transactionbuilder_get_deposit(this.ptr);\n        return BigNum.__wrap(ret);\n    }\n    /**\n    * @returns {BigNum | undefined}\n    */\n    get_fee_if_set() {\n        var ret = wasm.transactionbuilder_get_fee_if_set(this.ptr);\n        return ret === 0 ? undefined : BigNum.__wrap(ret);\n    }\n    /**\n    * Warning: this function will mutate the /fee/ field\n    * @param {Address} address\n    * @returns {boolean}\n    */\n    add_change_if_needed(address) {\n        _assertClass(address, Address);\n        var ret = wasm.transactionbuilder_add_change_if_needed(this.ptr, address.ptr);\n        return ret !== 0;\n    }\n    /**\n    * @returns {number}\n    */\n    full_size() {\n        var ret = wasm.transactionbuilder_full_size(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {Uint32Array}\n    */\n    output_sizes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionbuilder_output_sizes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU32FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 4);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {TransactionBody}\n    */\n    build() {\n        var ret = wasm.transactionbuilder_build(this.ptr);\n        return TransactionBody.__wrap(ret);\n    }\n    /**\n    * warning: sum of all parts of a transaction must equal 0. You cannot just set the fee to the min value and forget about it\n    * warning: min_fee may be slightly larger than the actual minimum fee (ex: a few lovelaces)\n    * this is done to simplify the library code, but can be fixed later\n    * @returns {BigNum}\n    */\n    min_fee() {\n        var ret = wasm.transactionbuilder_min_fee(this.ptr);\n        return BigNum.__wrap(ret);\n    }\n}\n/**\n*/\nexport class TransactionHash {\n\n    static __wrap(ptr) {\n        const obj = Object.create(TransactionHash.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_transactionhash_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionhash_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} prefix\n    * @returns {string}\n    */\n    to_bech32(prefix) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passStringToWasm0(prefix, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.transactionhash_to_bech32(retptr, this.ptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} bech_str\n    * @returns {TransactionHash}\n    */\n    static from_bech32(bech_str) {\n        var ptr0 = passStringToWasm0(bech_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.transactionhash_from_bech32(ptr0, len0);\n        return TransactionHash.__wrap(ret);\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {TransactionHash}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.transactionhash_from_bytes(ptr0, len0);\n        return TransactionHash.__wrap(ret);\n    }\n}\n/**\n*/\nexport class TransactionInput {\n\n    static __wrap(ptr) {\n        const obj = Object.create(TransactionInput.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_transactioninput_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactioninput_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {TransactionInput}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.transactioninput_from_bytes(ptr0, len0);\n        return TransactionInput.__wrap(ret);\n    }\n    /**\n    * @returns {TransactionHash}\n    */\n    transaction_id() {\n        var ret = wasm.transactioninput_transaction_id(this.ptr);\n        return TransactionHash.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    index() {\n        var ret = wasm.transactioninput_index(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {TransactionHash} transaction_id\n    * @param {number} index\n    * @returns {TransactionInput}\n    */\n    static new(transaction_id, index) {\n        _assertClass(transaction_id, TransactionHash);\n        var ret = wasm.transactioninput_new(transaction_id.ptr, index);\n        return TransactionInput.__wrap(ret);\n    }\n}\n/**\n*/\nexport class TransactionInputs {\n\n    static __wrap(ptr) {\n        const obj = Object.create(TransactionInputs.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_transactioninputs_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactioninputs_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {TransactionInputs}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.transactioninputs_from_bytes(ptr0, len0);\n        return TransactionInputs.__wrap(ret);\n    }\n    /**\n    * @returns {TransactionInputs}\n    */\n    static new() {\n        var ret = wasm.transactioninputs_new();\n        return TransactionInputs.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.transactioninputs_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} index\n    * @returns {TransactionInput}\n    */\n    get(index) {\n        var ret = wasm.transactioninputs_get(this.ptr, index);\n        return TransactionInput.__wrap(ret);\n    }\n    /**\n    * @param {TransactionInput} elem\n    */\n    add(elem) {\n        _assertClass(elem, TransactionInput);\n        wasm.transactioninputs_add(this.ptr, elem.ptr);\n    }\n}\n/**\n*/\nexport class TransactionMetadatum {\n\n    static __wrap(ptr) {\n        const obj = Object.create(TransactionMetadatum.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_transactionmetadatum_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionmetadatum_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {TransactionMetadatum}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.transactionmetadatum_from_bytes(ptr0, len0);\n        return TransactionMetadatum.__wrap(ret);\n    }\n    /**\n    * @param {MetadataMap} map\n    * @returns {TransactionMetadatum}\n    */\n    static new_map(map) {\n        _assertClass(map, MetadataMap);\n        var ret = wasm.transactionmetadatum_new_map(map.ptr);\n        return TransactionMetadatum.__wrap(ret);\n    }\n    /**\n    * @param {MetadataList} list\n    * @returns {TransactionMetadatum}\n    */\n    static new_list(list) {\n        _assertClass(list, MetadataList);\n        var ret = wasm.transactionmetadatum_new_list(list.ptr);\n        return TransactionMetadatum.__wrap(ret);\n    }\n    /**\n    * @param {Int} int\n    * @returns {TransactionMetadatum}\n    */\n    static new_int(int) {\n        _assertClass(int, Int);\n        var ret = wasm.transactionmetadatum_new_int(int.ptr);\n        return TransactionMetadatum.__wrap(ret);\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {TransactionMetadatum}\n    */\n    static new_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.transactionmetadatum_new_bytes(ptr0, len0);\n        return TransactionMetadatum.__wrap(ret);\n    }\n    /**\n    * @param {string} text\n    * @returns {TransactionMetadatum}\n    */\n    static new_text(text) {\n        var ptr0 = passStringToWasm0(text, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.transactionmetadatum_new_text(ptr0, len0);\n        return TransactionMetadatum.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    kind() {\n        var ret = wasm.transactionmetadatum_kind(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {MetadataMap}\n    */\n    as_map() {\n        var ret = wasm.transactionmetadatum_as_map(this.ptr);\n        return MetadataMap.__wrap(ret);\n    }\n    /**\n    * @returns {MetadataList}\n    */\n    as_list() {\n        var ret = wasm.transactionmetadatum_as_list(this.ptr);\n        return MetadataList.__wrap(ret);\n    }\n    /**\n    * @returns {Int}\n    */\n    as_int() {\n        var ret = wasm.transactionmetadatum_as_int(this.ptr);\n        return Int.__wrap(ret);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    as_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionmetadatum_as_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    as_text() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionmetadatum_as_text(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n}\n/**\n*/\nexport class TransactionMetadatumLabels {\n\n    static __wrap(ptr) {\n        const obj = Object.create(TransactionMetadatumLabels.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_transactionmetadatumlabels_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionmetadatumlabels_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {TransactionMetadatumLabels}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.transactionmetadatumlabels_from_bytes(ptr0, len0);\n        return TransactionMetadatumLabels.__wrap(ret);\n    }\n    /**\n    * @returns {TransactionMetadatumLabels}\n    */\n    static new() {\n        var ret = wasm.transactionmetadatumlabels_new();\n        return TransactionMetadatumLabels.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.transactionmetadatumlabels_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} index\n    * @returns {BigNum}\n    */\n    get(index) {\n        var ret = wasm.transactionmetadatumlabels_get(this.ptr, index);\n        return BigNum.__wrap(ret);\n    }\n    /**\n    * @param {BigNum} elem\n    */\n    add(elem) {\n        _assertClass(elem, BigNum);\n        wasm.transactionmetadatumlabels_add(this.ptr, elem.ptr);\n    }\n}\n/**\n*/\nexport class TransactionOutput {\n\n    static __wrap(ptr) {\n        const obj = Object.create(TransactionOutput.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_transactionoutput_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionoutput_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {TransactionOutput}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.transactionoutput_from_bytes(ptr0, len0);\n        return TransactionOutput.__wrap(ret);\n    }\n    /**\n    * @returns {Address}\n    */\n    address() {\n        var ret = wasm.transactionoutput_address(this.ptr);\n        return Address.__wrap(ret);\n    }\n    /**\n    * @returns {Value}\n    */\n    amount() {\n        var ret = wasm.transactionoutput_amount(this.ptr);\n        return Value.__wrap(ret);\n    }\n    /**\n    * @returns {DataHash | undefined}\n    */\n    data_hash() {\n        var ret = wasm.transactionoutput_data_hash(this.ptr);\n        return ret === 0 ? undefined : DataHash.__wrap(ret);\n    }\n    /**\n    * @param {DataHash} data_hash\n    */\n    set_data_hash(data_hash) {\n        _assertClass(data_hash, DataHash);\n        wasm.transactionoutput_set_data_hash(this.ptr, data_hash.ptr);\n    }\n    /**\n    * @param {Address} address\n    * @param {Value} amount\n    * @returns {TransactionOutput}\n    */\n    static new(address, amount) {\n        _assertClass(address, Address);\n        _assertClass(amount, Value);\n        var ret = wasm.transactionoutput_new(address.ptr, amount.ptr);\n        return TransactionOutput.__wrap(ret);\n    }\n}\n/**\n*/\nexport class TransactionOutputs {\n\n    static __wrap(ptr) {\n        const obj = Object.create(TransactionOutputs.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_transactionoutputs_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionoutputs_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {TransactionOutputs}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.transactionoutputs_from_bytes(ptr0, len0);\n        return TransactionOutputs.__wrap(ret);\n    }\n    /**\n    * @returns {TransactionOutputs}\n    */\n    static new() {\n        var ret = wasm.transactionoutputs_new();\n        return TransactionOutputs.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.transactionoutputs_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} index\n    * @returns {TransactionOutput}\n    */\n    get(index) {\n        var ret = wasm.transactionoutputs_get(this.ptr, index);\n        return TransactionOutput.__wrap(ret);\n    }\n    /**\n    * @param {TransactionOutput} elem\n    */\n    add(elem) {\n        _assertClass(elem, TransactionOutput);\n        wasm.transactionoutputs_add(this.ptr, elem.ptr);\n    }\n}\n/**\n*/\nexport class TransactionUnspentOutput {\n\n    static __wrap(ptr) {\n        const obj = Object.create(TransactionUnspentOutput.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_transactionunspentoutput_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionunspentoutput_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {TransactionUnspentOutput}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.transactionunspentoutput_from_bytes(ptr0, len0);\n        return TransactionUnspentOutput.__wrap(ret);\n    }\n    /**\n    * @param {TransactionInput} input\n    * @param {TransactionOutput} output\n    * @returns {TransactionUnspentOutput}\n    */\n    static new(input, output) {\n        _assertClass(input, TransactionInput);\n        _assertClass(output, TransactionOutput);\n        var ret = wasm.transactionunspentoutput_new(input.ptr, output.ptr);\n        return TransactionUnspentOutput.__wrap(ret);\n    }\n    /**\n    * @returns {TransactionInput}\n    */\n    input() {\n        var ret = wasm.transactionunspentoutput_input(this.ptr);\n        return TransactionInput.__wrap(ret);\n    }\n    /**\n    * @returns {TransactionOutput}\n    */\n    output() {\n        var ret = wasm.transactionunspentoutput_output(this.ptr);\n        return TransactionOutput.__wrap(ret);\n    }\n}\n/**\n*/\nexport class TransactionWitnessSet {\n\n    static __wrap(ptr) {\n        const obj = Object.create(TransactionWitnessSet.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_transactionwitnessset_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionwitnessset_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {TransactionWitnessSet}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.transactionwitnessset_from_bytes(ptr0, len0);\n        return TransactionWitnessSet.__wrap(ret);\n    }\n    /**\n    * @param {Vkeywitnesses} vkeys\n    */\n    set_vkeys(vkeys) {\n        _assertClass(vkeys, Vkeywitnesses);\n        wasm.transactionwitnessset_set_vkeys(this.ptr, vkeys.ptr);\n    }\n    /**\n    * @returns {Vkeywitnesses | undefined}\n    */\n    vkeys() {\n        var ret = wasm.transactionwitnessset_vkeys(this.ptr);\n        return ret === 0 ? undefined : Vkeywitnesses.__wrap(ret);\n    }\n    /**\n    * @param {NativeScripts} native_scripts\n    */\n    set_native_scripts(native_scripts) {\n        _assertClass(native_scripts, NativeScripts);\n        wasm.transactionwitnessset_set_native_scripts(this.ptr, native_scripts.ptr);\n    }\n    /**\n    * @returns {NativeScripts | undefined}\n    */\n    native_scripts() {\n        var ret = wasm.transactionwitnessset_native_scripts(this.ptr);\n        return ret === 0 ? undefined : NativeScripts.__wrap(ret);\n    }\n    /**\n    * @param {BootstrapWitnesses} bootstraps\n    */\n    set_bootstraps(bootstraps) {\n        _assertClass(bootstraps, BootstrapWitnesses);\n        wasm.transactionwitnessset_set_bootstraps(this.ptr, bootstraps.ptr);\n    }\n    /**\n    * @returns {BootstrapWitnesses | undefined}\n    */\n    bootstraps() {\n        var ret = wasm.transactionwitnessset_bootstraps(this.ptr);\n        return ret === 0 ? undefined : BootstrapWitnesses.__wrap(ret);\n    }\n    /**\n    * @param {PlutusScripts} plutus_scripts\n    */\n    set_plutus_scripts(plutus_scripts) {\n        _assertClass(plutus_scripts, PlutusScripts);\n        wasm.transactionwitnessset_set_plutus_scripts(this.ptr, plutus_scripts.ptr);\n    }\n    /**\n    * @returns {PlutusScripts | undefined}\n    */\n    plutus_scripts() {\n        var ret = wasm.transactionwitnessset_plutus_scripts(this.ptr);\n        return ret === 0 ? undefined : PlutusScripts.__wrap(ret);\n    }\n    /**\n    * @param {PlutusList} plutus_data\n    */\n    set_plutus_data(plutus_data) {\n        _assertClass(plutus_data, PlutusList);\n        wasm.transactionwitnessset_set_plutus_data(this.ptr, plutus_data.ptr);\n    }\n    /**\n    * @returns {PlutusList | undefined}\n    */\n    plutus_data() {\n        var ret = wasm.transactionwitnessset_plutus_data(this.ptr);\n        return ret === 0 ? undefined : PlutusList.__wrap(ret);\n    }\n    /**\n    * @param {Redeemers} redeemers\n    */\n    set_redeemers(redeemers) {\n        _assertClass(redeemers, Redeemers);\n        wasm.transactionwitnessset_set_redeemers(this.ptr, redeemers.ptr);\n    }\n    /**\n    * @returns {Redeemers | undefined}\n    */\n    redeemers() {\n        var ret = wasm.transactionwitnessset_redeemers(this.ptr);\n        return ret === 0 ? undefined : Redeemers.__wrap(ret);\n    }\n    /**\n    * @returns {TransactionWitnessSet}\n    */\n    static new() {\n        var ret = wasm.transactionwitnessset_new();\n        return TransactionWitnessSet.__wrap(ret);\n    }\n}\n/**\n*/\nexport class TransactionWitnessSets {\n\n    static __wrap(ptr) {\n        const obj = Object.create(TransactionWitnessSets.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_transactionwitnesssets_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transactionwitnesssets_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {TransactionWitnessSets}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.transactionwitnesssets_from_bytes(ptr0, len0);\n        return TransactionWitnessSets.__wrap(ret);\n    }\n    /**\n    * @returns {TransactionWitnessSets}\n    */\n    static new() {\n        var ret = wasm.transactionwitnesssets_new();\n        return TransactionWitnessSets.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.transactionwitnesssets_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} index\n    * @returns {TransactionWitnessSet}\n    */\n    get(index) {\n        var ret = wasm.transactionwitnesssets_get(this.ptr, index);\n        return TransactionWitnessSet.__wrap(ret);\n    }\n    /**\n    * @param {TransactionWitnessSet} elem\n    */\n    add(elem) {\n        _assertClass(elem, TransactionWitnessSet);\n        wasm.transactionwitnesssets_add(this.ptr, elem.ptr);\n    }\n}\n/**\n*/\nexport class URL {\n\n    static __wrap(ptr) {\n        const obj = Object.create(URL.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_url_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.url_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {URL}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.url_from_bytes(ptr0, len0);\n        return URL.__wrap(ret);\n    }\n    /**\n    * @param {string} url\n    * @returns {URL}\n    */\n    static new(url) {\n        var ptr0 = passStringToWasm0(url, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.url_new(ptr0, len0);\n        return URL.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    url() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.url_url(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n}\n/**\n*/\nexport class UnitInterval {\n\n    static __wrap(ptr) {\n        const obj = Object.create(UnitInterval.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_unitinterval_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.unitinterval_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {UnitInterval}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.unitinterval_from_bytes(ptr0, len0);\n        return UnitInterval.__wrap(ret);\n    }\n    /**\n    * @returns {BigNum}\n    */\n    numerator() {\n        var ret = wasm.unitinterval_numerator(this.ptr);\n        return BigNum.__wrap(ret);\n    }\n    /**\n    * @returns {BigNum}\n    */\n    denominator() {\n        var ret = wasm.unitinterval_denominator(this.ptr);\n        return BigNum.__wrap(ret);\n    }\n    /**\n    * @param {BigNum} numerator\n    * @param {BigNum} denominator\n    * @returns {UnitInterval}\n    */\n    static new(numerator, denominator) {\n        _assertClass(numerator, BigNum);\n        _assertClass(denominator, BigNum);\n        var ret = wasm.unitinterval_new(numerator.ptr, denominator.ptr);\n        return UnitInterval.__wrap(ret);\n    }\n}\n/**\n*/\nexport class Update {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Update.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_update_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.update_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {Update}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.update_from_bytes(ptr0, len0);\n        return Update.__wrap(ret);\n    }\n    /**\n    * @returns {ProposedProtocolParameterUpdates}\n    */\n    proposed_protocol_parameter_updates() {\n        var ret = wasm.update_proposed_protocol_parameter_updates(this.ptr);\n        return ProposedProtocolParameterUpdates.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    epoch() {\n        var ret = wasm.update_epoch(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {ProposedProtocolParameterUpdates} proposed_protocol_parameter_updates\n    * @param {number} epoch\n    * @returns {Update}\n    */\n    static new(proposed_protocol_parameter_updates, epoch) {\n        _assertClass(proposed_protocol_parameter_updates, ProposedProtocolParameterUpdates);\n        var ret = wasm.update_new(proposed_protocol_parameter_updates.ptr, epoch);\n        return Update.__wrap(ret);\n    }\n}\n/**\n*/\nexport class VRFCert {\n\n    static __wrap(ptr) {\n        const obj = Object.create(VRFCert.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_vrfcert_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.vrfcert_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {VRFCert}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.vrfcert_from_bytes(ptr0, len0);\n        return VRFCert.__wrap(ret);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    output() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.vrfcert_output(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    proof() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.vrfcert_proof(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} output\n    * @param {Uint8Array} proof\n    * @returns {VRFCert}\n    */\n    static new(output, proof) {\n        var ptr0 = passArray8ToWasm0(output, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ptr1 = passArray8ToWasm0(proof, wasm.__wbindgen_malloc);\n        var len1 = WASM_VECTOR_LEN;\n        var ret = wasm.vrfcert_new(ptr0, len0, ptr1, len1);\n        return VRFCert.__wrap(ret);\n    }\n}\n/**\n*/\nexport class VRFKeyHash {\n\n    static __wrap(ptr) {\n        const obj = Object.create(VRFKeyHash.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_vrfkeyhash_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.vrfkeyhash_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} prefix\n    * @returns {string}\n    */\n    to_bech32(prefix) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passStringToWasm0(prefix, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.vrfkeyhash_to_bech32(retptr, this.ptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} bech_str\n    * @returns {VRFKeyHash}\n    */\n    static from_bech32(bech_str) {\n        var ptr0 = passStringToWasm0(bech_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.vrfkeyhash_from_bech32(ptr0, len0);\n        return VRFKeyHash.__wrap(ret);\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {VRFKeyHash}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.vrfkeyhash_from_bytes(ptr0, len0);\n        return VRFKeyHash.__wrap(ret);\n    }\n}\n/**\n*/\nexport class VRFVKey {\n\n    static __wrap(ptr) {\n        const obj = Object.create(VRFVKey.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_vrfvkey_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.vrfvkey_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string} prefix\n    * @returns {string}\n    */\n    to_bech32(prefix) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = passStringToWasm0(prefix, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.vrfvkey_to_bech32(retptr, this.ptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {string} bech_str\n    * @returns {VRFVKey}\n    */\n    static from_bech32(bech_str) {\n        var ptr0 = passStringToWasm0(bech_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.vrfvkey_from_bech32(ptr0, len0);\n        return VRFVKey.__wrap(ret);\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {VRFVKey}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.vrfvkey_from_bytes(ptr0, len0);\n        return VRFVKey.__wrap(ret);\n    }\n}\n/**\n*/\nexport class Value {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Value.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_value_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.value_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {Value}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.value_from_bytes(ptr0, len0);\n        return Value.__wrap(ret);\n    }\n    /**\n    * @param {BigNum} coin\n    * @returns {Value}\n    */\n    static new(coin) {\n        _assertClass(coin, BigNum);\n        var ret = wasm.value_new(coin.ptr);\n        return Value.__wrap(ret);\n    }\n    /**\n    * @returns {Value}\n    */\n    static zero() {\n        var ret = wasm.value_zero();\n        return Value.__wrap(ret);\n    }\n    /**\n    * @returns {boolean}\n    */\n    is_zero() {\n        var ret = wasm.value_is_zero(this.ptr);\n        return ret !== 0;\n    }\n    /**\n    * @returns {BigNum}\n    */\n    coin() {\n        var ret = wasm.value_coin(this.ptr);\n        return BigNum.__wrap(ret);\n    }\n    /**\n    * @param {BigNum} coin\n    */\n    set_coin(coin) {\n        _assertClass(coin, BigNum);\n        wasm.value_set_coin(this.ptr, coin.ptr);\n    }\n    /**\n    * @returns {MultiAsset | undefined}\n    */\n    multiasset() {\n        var ret = wasm.value_multiasset(this.ptr);\n        return ret === 0 ? undefined : MultiAsset.__wrap(ret);\n    }\n    /**\n    * @param {MultiAsset} multiasset\n    */\n    set_multiasset(multiasset) {\n        _assertClass(multiasset, MultiAsset);\n        wasm.value_set_multiasset(this.ptr, multiasset.ptr);\n    }\n    /**\n    * @param {Value} rhs\n    * @returns {Value}\n    */\n    checked_add(rhs) {\n        _assertClass(rhs, Value);\n        var ret = wasm.value_checked_add(this.ptr, rhs.ptr);\n        return Value.__wrap(ret);\n    }\n    /**\n    * @param {Value} rhs_value\n    * @returns {Value}\n    */\n    checked_sub(rhs_value) {\n        _assertClass(rhs_value, Value);\n        var ret = wasm.value_checked_sub(this.ptr, rhs_value.ptr);\n        return Value.__wrap(ret);\n    }\n    /**\n    * @param {Value} rhs_value\n    * @returns {Value}\n    */\n    clamped_sub(rhs_value) {\n        _assertClass(rhs_value, Value);\n        var ret = wasm.value_clamped_sub(this.ptr, rhs_value.ptr);\n        return Value.__wrap(ret);\n    }\n    /**\n    * note: values are only partially comparable\n    * @param {Value} rhs_value\n    * @returns {number | undefined}\n    */\n    compare(rhs_value) {\n        _assertClass(rhs_value, Value);\n        var ret = wasm.value_compare(this.ptr, rhs_value.ptr);\n        return ret === 0xFFFFFF ? undefined : ret;\n    }\n}\n/**\n*/\nexport class Vkey {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Vkey.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_vkey_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.vkey_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {Vkey}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.vkey_from_bytes(ptr0, len0);\n        return Vkey.__wrap(ret);\n    }\n    /**\n    * @param {PublicKey} pk\n    * @returns {Vkey}\n    */\n    static new(pk) {\n        _assertClass(pk, PublicKey);\n        var ret = wasm.vkey_new(pk.ptr);\n        return Vkey.__wrap(ret);\n    }\n    /**\n    * @returns {PublicKey}\n    */\n    public_key() {\n        var ret = wasm.vkey_public_key(this.ptr);\n        return PublicKey.__wrap(ret);\n    }\n}\n/**\n*/\nexport class Vkeys {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Vkeys.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_vkeys_free(ptr);\n    }\n    /**\n    * @returns {Vkeys}\n    */\n    static new() {\n        var ret = wasm.vkeys_new();\n        return Vkeys.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.vkeys_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} index\n    * @returns {Vkey}\n    */\n    get(index) {\n        var ret = wasm.vkeys_get(this.ptr, index);\n        return Vkey.__wrap(ret);\n    }\n    /**\n    * @param {Vkey} elem\n    */\n    add(elem) {\n        _assertClass(elem, Vkey);\n        wasm.vkeys_add(this.ptr, elem.ptr);\n    }\n}\n/**\n*/\nexport class Vkeywitness {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Vkeywitness.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_vkeywitness_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.vkeywitness_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {Vkeywitness}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.vkeywitness_from_bytes(ptr0, len0);\n        return Vkeywitness.__wrap(ret);\n    }\n    /**\n    * @param {Vkey} vkey\n    * @param {Ed25519Signature} signature\n    * @returns {Vkeywitness}\n    */\n    static new(vkey, signature) {\n        _assertClass(vkey, Vkey);\n        _assertClass(signature, Ed25519Signature);\n        var ret = wasm.vkeywitness_new(vkey.ptr, signature.ptr);\n        return Vkeywitness.__wrap(ret);\n    }\n    /**\n    * @returns {Vkey}\n    */\n    vkey() {\n        var ret = wasm.vkeywitness_vkey(this.ptr);\n        return Vkey.__wrap(ret);\n    }\n    /**\n    * @returns {Ed25519Signature}\n    */\n    signature() {\n        var ret = wasm.vkeywitness_signature(this.ptr);\n        return Ed25519Signature.__wrap(ret);\n    }\n}\n/**\n*/\nexport class Vkeywitnesses {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Vkeywitnesses.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_vkeywitnesses_free(ptr);\n    }\n    /**\n    * @returns {Vkeywitnesses}\n    */\n    static new() {\n        var ret = wasm.vkeywitnesses_new();\n        return Vkeywitnesses.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.vkeywitnesses_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} index\n    * @returns {Vkeywitness}\n    */\n    get(index) {\n        var ret = wasm.vkeywitnesses_get(this.ptr, index);\n        return Vkeywitness.__wrap(ret);\n    }\n    /**\n    * @param {Vkeywitness} elem\n    */\n    add(elem) {\n        _assertClass(elem, Vkeywitness);\n        wasm.vkeywitnesses_add(this.ptr, elem.ptr);\n    }\n}\n/**\n*/\nexport class Withdrawals {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Withdrawals.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_withdrawals_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.withdrawals_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {Withdrawals}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.withdrawals_from_bytes(ptr0, len0);\n        return Withdrawals.__wrap(ret);\n    }\n    /**\n    * @returns {Withdrawals}\n    */\n    static new() {\n        var ret = wasm.withdrawals_new();\n        return Withdrawals.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.withdrawals_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {RewardAddress} key\n    * @param {BigNum} value\n    * @returns {BigNum | undefined}\n    */\n    insert(key, value) {\n        _assertClass(key, RewardAddress);\n        _assertClass(value, BigNum);\n        var ret = wasm.withdrawals_insert(this.ptr, key.ptr, value.ptr);\n        return ret === 0 ? undefined : BigNum.__wrap(ret);\n    }\n    /**\n    * @param {RewardAddress} key\n    * @returns {BigNum | undefined}\n    */\n    get(key) {\n        _assertClass(key, RewardAddress);\n        var ret = wasm.withdrawals_get(this.ptr, key.ptr);\n        return ret === 0 ? undefined : BigNum.__wrap(ret);\n    }\n    /**\n    * @returns {RewardAddresses}\n    */\n    keys() {\n        var ret = wasm.withdrawals_keys(this.ptr);\n        return RewardAddresses.__wrap(ret);\n    }\n}\n\nexport function __wbindgen_object_drop_ref(arg0) {\n    takeObject(arg0);\n};\n\nexport function __wbindgen_string_new(arg0, arg1) {\n    var ret = getStringFromWasm0(arg0, arg1);\n    return addHeapObject(ret);\n};\n\nexport function __wbg_new_3a746f2619705add(arg0, arg1) {\n    var ret = new Function(getStringFromWasm0(arg0, arg1));\n    return addHeapObject(ret);\n};\n\nexport function __wbg_call_f54d3a6dadb199ca(arg0, arg1) {\n    var ret = getObject(arg0).call(getObject(arg1));\n    return addHeapObject(ret);\n};\n\nexport function __wbindgen_jsval_eq(arg0, arg1) {\n    var ret = getObject(arg0) === getObject(arg1);\n    return ret;\n};\n\nexport function __wbg_self_ac379e780a0d8b94(arg0) {\n    var ret = getObject(arg0).self;\n    return addHeapObject(ret);\n};\n\nexport function __wbg_crypto_1e4302b85d4f64a2(arg0) {\n    var ret = getObject(arg0).crypto;\n    return addHeapObject(ret);\n};\n\nexport function __wbindgen_is_undefined(arg0) {\n    var ret = getObject(arg0) === undefined;\n    return ret;\n};\n\nexport function __wbg_getRandomValues_1b4ba144162a5c9e(arg0) {\n    var ret = getObject(arg0).getRandomValues;\n    return addHeapObject(ret);\n};\n\nexport function __wbg_require_6461b1e9a0d7c34a(arg0, arg1) {\n    var ret = require(getStringFromWasm0(arg0, arg1));\n    return addHeapObject(ret);\n};\n\nexport function __wbg_getRandomValues_1ef11e888e5228e9(arg0, arg1, arg2) {\n    getObject(arg0).getRandomValues(getArrayU8FromWasm0(arg1, arg2));\n};\n\nexport function __wbg_randomFillSync_1b52c8482374c55b(arg0, arg1, arg2) {\n    getObject(arg0).randomFillSync(getArrayU8FromWasm0(arg1, arg2));\n};\n\nexport function __wbindgen_string_get(arg0, arg1) {\n    const obj = getObject(arg1);\n    var ret = typeof(obj) === 'string' ? obj : undefined;\n    var ptr0 = isLikeNone(ret) ? 0 : passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n    var len0 = WASM_VECTOR_LEN;\n    getInt32Memory0()[arg0 / 4 + 1] = len0;\n    getInt32Memory0()[arg0 / 4 + 0] = ptr0;\n};\n\nexport function __wbindgen_debug_string(arg0, arg1) {\n    var ret = debugString(getObject(arg1));\n    var ptr0 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n    var len0 = WASM_VECTOR_LEN;\n    getInt32Memory0()[arg0 / 4 + 1] = len0;\n    getInt32Memory0()[arg0 / 4 + 0] = ptr0;\n};\n\nexport function __wbindgen_throw(arg0, arg1) {\n    throw new Error(getStringFromWasm0(arg0, arg1));\n};\n\nexport function __wbindgen_rethrow(arg0) {\n    throw takeObject(arg0);\n};\n\n","function webpackEmptyContext(req) {\n\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\te.code = 'MODULE_NOT_FOUND';\n\tthrow e;\n}\nwebpackEmptyContext.keys = function() { return []; };\nwebpackEmptyContext.resolve = webpackEmptyContext;\nmodule.exports = webpackEmptyContext;\nwebpackEmptyContext.id = \"1d18\";","export default function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}","import * as wasm from \"./cardano_serialization_lib_bg.wasm\";\nexport * from \"./cardano_serialization_lib_bg.js\";","module.exports = function(originalModule) {\n\tif (!originalModule.webpackPolyfill) {\n\t\tvar module = Object.create(originalModule);\n\t\t// module.parent = undefined by default\n\t\tif (!module.children) module.children = [];\n\t\tObject.defineProperty(module, \"loaded\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.l;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"id\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.i;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"exports\", {\n\t\t\tenumerable: true\n\t\t});\n\t\tmodule.webpackPolyfill = 1;\n\t}\n\treturn module;\n};\n","var createTypedArrayConstructor = require('../internals/typed-array-constructor');\n\n// `Uint32Array` constructor\n// https://tc39.es/ecma262/#sec-typedarray-objects\ncreateTypedArrayConstructor('Uint32', function (init) {\n  return function Uint32Array(data, byteOffset, length) {\n    return init(this, data, byteOffset, length);\n  };\n});\n"],"sourceRoot":""}