{"version":3,"sources":["webpack://web3-cardano-token/./temporary_modules/@emurgo/cardano-message-signing-browser/emurgo_message_signing.js","webpack://web3-cardano-token/./temporary_modules/@emurgo/cardano-message-signing-browser/emurgo_message_signing_bg.js","webpack://web3-cardano-token/./node_modules/core-js/modules/es.typed-array.float64-array.js","webpack://web3-cardano-token/./node_modules/@babel/runtime/helpers/esm/typeof.js","webpack://web3-cardano-token/(webpack)/buildin/harmony-module.js"],"names":["heap","Array","fill","undefined","getObject","idx","push","heap_next","length","dropObject","takeObject","ret","lTextDecoder","TextDecoder","module","require","cachedTextDecoder","ignoreBOM","fatal","decode","cachegetUint8Memory0","getUint8Memory0","buffer","wasm","Uint8Array","getStringFromWasm0","ptr","len","subarray","addHeapObject","obj","debugString","val","type","description","name","isArray","debug","i","className","builtInMatches","exec","toString","call","JSON","stringify","_","Error","message","stack","WASM_VECTOR_LEN","lTextEncoder","TextEncoder","cachedTextEncoder","encodeString","encodeInto","arg","view","buf","encode","set","read","written","passStringToWasm0","malloc","realloc","mem","offset","code","charCodeAt","slice","cachegetInt32Memory0","getInt32Memory0","Int32Array","getArrayU8FromWasm0","passArray8ToWasm0","_assertClass","instance","klass","isLikeNone","x","cachegetFloat64Memory0","getFloat64Memory0","Float64Array","LabelKind","Object","freeze","Int","Text","SignedMessageKind","COSESIGN","COSESIGN1","SigContext","Signature","Signature1","CounterSignature","CBORSpecialType","Bool","Float","Unassigned","Break","Undefined","Null","CBORValueKind","Bytes","TaggedCBOR","Special","AlgorithmId","EdDSA","ChaCha20Poly1305","KeyType","OKP","EC2","Symmetric","ECKey","CRV","X","Y","D","CurveType","P256","P384","P521","X25519","X448","Ed25519","Ed448","KeyOperation","Sign","Verify","Encrypt","Decrypt","WrapKey","UnwrapKey","DeriveKey","DeriveBits","BigNum","this","__destroy_into_raw","retptr","r0","r1","v0","other","__wrap","create","prototype","bytes","ptr0","len0","string","CBORArray","index","CBORValue","elem","use_definite","CBORObject","key","value","CBORSpecial","b","u","int","text","arr","tagged","special","COSEEncrypt","Headers","COSERecipients","headers","ciphertext","recipients","COSEEncrypt0","COSEKey","key_type","Label","key_id","algorithm_id","key_ops","Labels","base_init_vector","label","COSERecipient","COSESign","COSESignatures","payload","signatures","COSESign1","external_aad","external_payload","ptr1","len1","SigStructure","signature","COSESign1Builder","signed_sig_structure","is_payload_external","COSESignBuilder","COSESignature","cose_signature","cose_signatures","EdDSA25519Key","private_key_bytes","pubkey_bytes","HeaderMap","criticality","content_type","init_vector","partial_init_vector","counter_signature","ProtectedHeaderMap","protected_","unprotected_","id","ec_key","curve_type","key_op","PasswordEncryption","data","header_map","PubKeyEncryption","sign_protected","context","body_protected","SignedMessage","cose_sign","cose_sign1","s","tag","__wbindgen_object_drop_ref","arg0","__wbindgen_string_new","arg1","__wbindgen_debug_string","__wbindgen_throw","__wbindgen_rethrow","createTypedArrayConstructor","init","byteOffset","_typeof","Symbol","iterator","constructor","exports","originalModule","webpackPolyfill","children","defineProperty","enumerable","get","l"],"mappings":"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","file":"web3-cardano-token.umd.min.5.js","sourcesContent":["import * as wasm from \"./emurgo_message_signing_bg.wasm\";\nexport * from \"./emurgo_message_signing_bg.js\";","import * as wasm from './emurgo_message_signing_bg.wasm';\n\nconst heap = new Array(32).fill(undefined);\n\nheap.push(undefined, null, true, false);\n\nfunction getObject(idx) { return heap[idx]; }\n\nlet heap_next = heap.length;\n\nfunction dropObject(idx) {\n    if (idx < 36) return;\n    heap[idx] = heap_next;\n    heap_next = idx;\n}\n\nfunction takeObject(idx) {\n    const ret = getObject(idx);\n    dropObject(idx);\n    return ret;\n}\n\nconst lTextDecoder = typeof TextDecoder === 'undefined' ? (0, module.require)('util').TextDecoder : TextDecoder;\n\nlet cachedTextDecoder = new lTextDecoder('utf-8', { ignoreBOM: true, fatal: true });\n\ncachedTextDecoder.decode();\n\nlet cachegetUint8Memory0 = null;\nfunction getUint8Memory0() {\n    if (cachegetUint8Memory0 === null || cachegetUint8Memory0.buffer !== wasm.memory.buffer) {\n        cachegetUint8Memory0 = new Uint8Array(wasm.memory.buffer);\n    }\n    return cachegetUint8Memory0;\n}\n\nfunction getStringFromWasm0(ptr, len) {\n    return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len));\n}\n\nfunction addHeapObject(obj) {\n    if (heap_next === heap.length) heap.push(heap.length + 1);\n    const idx = heap_next;\n    heap_next = heap[idx];\n\n    heap[idx] = obj;\n    return idx;\n}\n\nfunction debugString(val) {\n    // primitive types\n    const type = typeof val;\n    if (type == 'number' || type == 'boolean' || val == null) {\n        return  `${val}`;\n    }\n    if (type == 'string') {\n        return `\"${val}\"`;\n    }\n    if (type == 'symbol') {\n        const description = val.description;\n        if (description == null) {\n            return 'Symbol';\n        } else {\n            return `Symbol(${description})`;\n        }\n    }\n    if (type == 'function') {\n        const name = val.name;\n        if (typeof name == 'string' && name.length > 0) {\n            return `Function(${name})`;\n        } else {\n            return 'Function';\n        }\n    }\n    // objects\n    if (Array.isArray(val)) {\n        const length = val.length;\n        let debug = '[';\n        if (length > 0) {\n            debug += debugString(val[0]);\n        }\n        for(let i = 1; i < length; i++) {\n            debug += ', ' + debugString(val[i]);\n        }\n        debug += ']';\n        return debug;\n    }\n    // Test for built-in\n    const builtInMatches = /\\[object ([^\\]]+)\\]/.exec(toString.call(val));\n    let className;\n    if (builtInMatches.length > 1) {\n        className = builtInMatches[1];\n    } else {\n        // Failed to match the standard '[object ClassName]'\n        return toString.call(val);\n    }\n    if (className == 'Object') {\n        // we're a user defined class or Object\n        // JSON.stringify avoids problems with cycles, and is generally much\n        // easier than looping through ownProperties of `val`.\n        try {\n            return 'Object(' + JSON.stringify(val) + ')';\n        } catch (_) {\n            return 'Object';\n        }\n    }\n    // errors\n    if (val instanceof Error) {\n        return `${val.name}: ${val.message}\\n${val.stack}`;\n    }\n    // TODO we could test for more things here, like `Set`s and `Map`s.\n    return className;\n}\n\nlet WASM_VECTOR_LEN = 0;\n\nconst lTextEncoder = typeof TextEncoder === 'undefined' ? (0, module.require)('util').TextEncoder : TextEncoder;\n\nlet cachedTextEncoder = new lTextEncoder('utf-8');\n\nconst encodeString = (typeof cachedTextEncoder.encodeInto === 'function'\n    ? function (arg, view) {\n    return cachedTextEncoder.encodeInto(arg, view);\n}\n    : function (arg, view) {\n    const buf = cachedTextEncoder.encode(arg);\n    view.set(buf);\n    return {\n        read: arg.length,\n        written: buf.length\n    };\n});\n\nfunction passStringToWasm0(arg, malloc, realloc) {\n\n    if (realloc === undefined) {\n        const buf = cachedTextEncoder.encode(arg);\n        const ptr = malloc(buf.length);\n        getUint8Memory0().subarray(ptr, ptr + buf.length).set(buf);\n        WASM_VECTOR_LEN = buf.length;\n        return ptr;\n    }\n\n    let len = arg.length;\n    let ptr = malloc(len);\n\n    const mem = getUint8Memory0();\n\n    let offset = 0;\n\n    for (; offset < len; offset++) {\n        const code = arg.charCodeAt(offset);\n        if (code > 0x7F) break;\n        mem[ptr + offset] = code;\n    }\n\n    if (offset !== len) {\n        if (offset !== 0) {\n            arg = arg.slice(offset);\n        }\n        ptr = realloc(ptr, len, len = offset + arg.length * 3);\n        const view = getUint8Memory0().subarray(ptr + offset, ptr + len);\n        const ret = encodeString(arg, view);\n\n        offset += ret.written;\n    }\n\n    WASM_VECTOR_LEN = offset;\n    return ptr;\n}\n\nlet cachegetInt32Memory0 = null;\nfunction getInt32Memory0() {\n    if (cachegetInt32Memory0 === null || cachegetInt32Memory0.buffer !== wasm.memory.buffer) {\n        cachegetInt32Memory0 = new Int32Array(wasm.memory.buffer);\n    }\n    return cachegetInt32Memory0;\n}\n\nfunction getArrayU8FromWasm0(ptr, len) {\n    return getUint8Memory0().subarray(ptr / 1, ptr / 1 + len);\n}\n\nfunction passArray8ToWasm0(arg, malloc) {\n    const ptr = malloc(arg.length * 1);\n    getUint8Memory0().set(arg, ptr / 1);\n    WASM_VECTOR_LEN = arg.length;\n    return ptr;\n}\n\nfunction _assertClass(instance, klass) {\n    if (!(instance instanceof klass)) {\n        throw new Error(`expected instance of ${klass.name}`);\n    }\n    return instance.ptr;\n}\n\nfunction isLikeNone(x) {\n    return x === undefined || x === null;\n}\n\nlet cachegetFloat64Memory0 = null;\nfunction getFloat64Memory0() {\n    if (cachegetFloat64Memory0 === null || cachegetFloat64Memory0.buffer !== wasm.memory.buffer) {\n        cachegetFloat64Memory0 = new Float64Array(wasm.memory.buffer);\n    }\n    return cachegetFloat64Memory0;\n}\n/**\n*/\nexport const LabelKind = Object.freeze({ Int:0,\"0\":\"Int\",Text:1,\"1\":\"Text\", });\n/**\n*/\nexport const SignedMessageKind = Object.freeze({ COSESIGN:0,\"0\":\"COSESIGN\",COSESIGN1:1,\"1\":\"COSESIGN1\", });\n/**\n*/\nexport const SigContext = Object.freeze({ Signature:0,\"0\":\"Signature\",Signature1:1,\"1\":\"Signature1\",CounterSignature:2,\"2\":\"CounterSignature\", });\n/**\n*/\nexport const CBORSpecialType = Object.freeze({ Bool:0,\"0\":\"Bool\",Float:1,\"1\":\"Float\",Unassigned:2,\"2\":\"Unassigned\",Break:3,\"3\":\"Break\",Undefined:4,\"4\":\"Undefined\",Null:5,\"5\":\"Null\", });\n/**\n*/\nexport const CBORValueKind = Object.freeze({ Int:0,\"0\":\"Int\",Bytes:1,\"1\":\"Bytes\",Text:2,\"2\":\"Text\",Array:3,\"3\":\"Array\",Object:4,\"4\":\"Object\",TaggedCBOR:5,\"5\":\"TaggedCBOR\",Special:6,\"6\":\"Special\", });\n/**\n*/\nexport const AlgorithmId = Object.freeze({\n/**\n*r\" EdDSA (Pure EdDSA, not HashedEdDSA) - the algorithm used for Cardano addresses\n*/\nEdDSA:0,\"0\":\"EdDSA\",\n/**\n*r\" ChaCha20/Poly1305 w/ 256-bit key, 128-bit tag\n*/\nChaCha20Poly1305:1,\"1\":\"ChaCha20Poly1305\", });\n/**\n*/\nexport const KeyType = Object.freeze({\n/**\n*r\" octet key pair\n*/\nOKP:0,\"0\":\"OKP\",\n/**\n*r\" 2-coord EC\n*/\nEC2:1,\"1\":\"EC2\",Symmetric:2,\"2\":\"Symmetric\", });\n/**\n*/\nexport const ECKey = Object.freeze({ CRV:0,\"0\":\"CRV\",X:1,\"1\":\"X\",Y:2,\"2\":\"Y\",D:3,\"3\":\"D\", });\n/**\n*/\nexport const CurveType = Object.freeze({ P256:0,\"0\":\"P256\",P384:1,\"1\":\"P384\",P521:2,\"2\":\"P521\",X25519:3,\"3\":\"X25519\",X448:4,\"4\":\"X448\",Ed25519:5,\"5\":\"Ed25519\",Ed448:6,\"6\":\"Ed448\", });\n/**\n*/\nexport const KeyOperation = Object.freeze({ Sign:0,\"0\":\"Sign\",Verify:1,\"1\":\"Verify\",Encrypt:2,\"2\":\"Encrypt\",Decrypt:3,\"3\":\"Decrypt\",WrapKey:4,\"4\":\"WrapKey\",UnwrapKey:5,\"5\":\"UnwrapKey\",DeriveKey:6,\"6\":\"DeriveKey\",DeriveBits:7,\"7\":\"DeriveBits\", });\n/**\n*/\nexport class BigNum {\n\n    static __wrap(ptr) {\n        const obj = Object.create(BigNum.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_bignum_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.bignum_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {BigNum}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.bignum_from_bytes(ptr0, len0);\n        return BigNum.__wrap(ret);\n    }\n    /**\n    * @param {string} string\n    * @returns {BigNum}\n    */\n    static from_str(string) {\n        var ptr0 = passStringToWasm0(string, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.bignum_from_str(ptr0, len0);\n        return BigNum.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_str() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.bignum_to_str(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @param {BigNum} other\n    * @returns {BigNum}\n    */\n    checked_mul(other) {\n        _assertClass(other, BigNum);\n        var ret = wasm.bignum_checked_mul(this.ptr, other.ptr);\n        return BigNum.__wrap(ret);\n    }\n    /**\n    * @param {BigNum} other\n    * @returns {BigNum}\n    */\n    checked_add(other) {\n        _assertClass(other, BigNum);\n        var ret = wasm.bignum_checked_add(this.ptr, other.ptr);\n        return BigNum.__wrap(ret);\n    }\n    /**\n    * @param {BigNum} other\n    * @returns {BigNum}\n    */\n    checked_sub(other) {\n        _assertClass(other, BigNum);\n        var ret = wasm.bignum_checked_sub(this.ptr, other.ptr);\n        return BigNum.__wrap(ret);\n    }\n}\n/**\n*/\nexport class CBORArray {\n\n    static __wrap(ptr) {\n        const obj = Object.create(CBORArray.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_cborarray_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.cborarray_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {CBORArray}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.cborarray_from_bytes(ptr0, len0);\n        return CBORArray.__wrap(ret);\n    }\n    /**\n    * @returns {CBORArray}\n    */\n    static new() {\n        var ret = wasm.cborarray_new();\n        return CBORArray.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.cborarray_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} index\n    * @returns {CBORValue}\n    */\n    get(index) {\n        var ret = wasm.cborarray_get(this.ptr, index);\n        return CBORValue.__wrap(ret);\n    }\n    /**\n    * @param {CBORValue} elem\n    */\n    add(elem) {\n        _assertClass(elem, CBORValue);\n        wasm.cborarray_add(this.ptr, elem.ptr);\n    }\n    /**\n    * @param {boolean} use_definite\n    */\n    set_definite_encoding(use_definite) {\n        wasm.cborarray_set_definite_encoding(this.ptr, use_definite);\n    }\n    /**\n    * @returns {boolean}\n    */\n    is_definite() {\n        var ret = wasm.cborarray_is_definite(this.ptr);\n        return ret !== 0;\n    }\n}\n/**\n*/\nexport class CBORObject {\n\n    static __wrap(ptr) {\n        const obj = Object.create(CBORObject.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_cborobject_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.cborobject_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {CBORObject}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.cborobject_from_bytes(ptr0, len0);\n        return CBORObject.__wrap(ret);\n    }\n    /**\n    * @returns {CBORObject}\n    */\n    static new() {\n        var ret = wasm.cborobject_new();\n        return CBORObject.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.cborobject_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {CBORValue} key\n    * @param {CBORValue} value\n    * @returns {CBORValue | undefined}\n    */\n    insert(key, value) {\n        _assertClass(key, CBORValue);\n        _assertClass(value, CBORValue);\n        var ret = wasm.cborobject_insert(this.ptr, key.ptr, value.ptr);\n        return ret === 0 ? undefined : CBORValue.__wrap(ret);\n    }\n    /**\n    * @param {CBORValue} key\n    * @returns {CBORValue | undefined}\n    */\n    get(key) {\n        _assertClass(key, CBORValue);\n        var ret = wasm.cborobject_get(this.ptr, key.ptr);\n        return ret === 0 ? undefined : CBORValue.__wrap(ret);\n    }\n    /**\n    * @returns {CBORArray}\n    */\n    keys() {\n        var ret = wasm.cborobject_keys(this.ptr);\n        return CBORArray.__wrap(ret);\n    }\n    /**\n    * @param {boolean} use_definite\n    */\n    set_definite_encoding(use_definite) {\n        wasm.cborobject_set_definite_encoding(this.ptr, use_definite);\n    }\n    /**\n    * @returns {boolean}\n    */\n    is_definite() {\n        var ret = wasm.cborobject_is_definite(this.ptr);\n        return ret !== 0;\n    }\n}\n/**\n*/\nexport class CBORSpecial {\n\n    static __wrap(ptr) {\n        const obj = Object.create(CBORSpecial.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_cborspecial_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.cborspecial_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {CBORSpecial}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.cborspecial_from_bytes(ptr0, len0);\n        return CBORSpecial.__wrap(ret);\n    }\n    /**\n    * @param {boolean} b\n    * @returns {CBORSpecial}\n    */\n    static new_bool(b) {\n        var ret = wasm.cborspecial_new_bool(b);\n        return CBORSpecial.__wrap(ret);\n    }\n    /**\n    * @param {number} u\n    * @returns {CBORSpecial}\n    */\n    static new_unassigned(u) {\n        var ret = wasm.cborspecial_new_unassigned(u);\n        return CBORSpecial.__wrap(ret);\n    }\n    /**\n    * @returns {CBORSpecial}\n    */\n    static new_break() {\n        var ret = wasm.cborspecial_new_break();\n        return CBORSpecial.__wrap(ret);\n    }\n    /**\n    * @returns {CBORSpecial}\n    */\n    static new_null() {\n        var ret = wasm.cborspecial_new_null();\n        return CBORSpecial.__wrap(ret);\n    }\n    /**\n    * @returns {CBORSpecial}\n    */\n    static new_undefined() {\n        var ret = wasm.cborspecial_new_undefined();\n        return CBORSpecial.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    kind() {\n        var ret = wasm.cborspecial_kind(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {boolean | undefined}\n    */\n    as_bool() {\n        var ret = wasm.cborspecial_as_bool(this.ptr);\n        return ret === 0xFFFFFF ? undefined : ret !== 0;\n    }\n    /**\n    * @returns {number | undefined}\n    */\n    as_float() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.cborspecial_as_float(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getFloat64Memory0()[retptr / 8 + 1];\n            return r0 === 0 ? undefined : r1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {number | undefined}\n    */\n    as_unassigned() {\n        var ret = wasm.cborspecial_as_unassigned(this.ptr);\n        return ret === 0xFFFFFF ? undefined : ret;\n    }\n}\n/**\n*/\nexport class CBORValue {\n\n    static __wrap(ptr) {\n        const obj = Object.create(CBORValue.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_cborvalue_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.cborvalue_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {CBORValue}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.cborvalue_from_bytes(ptr0, len0);\n        return CBORValue.__wrap(ret);\n    }\n    /**\n    * @param {Int} int\n    * @returns {CBORValue}\n    */\n    static new_int(int) {\n        _assertClass(int, Int);\n        var ret = wasm.cborvalue_new_int(int.ptr);\n        return CBORValue.__wrap(ret);\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {CBORValue}\n    */\n    static new_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.cborvalue_new_bytes(ptr0, len0);\n        return CBORValue.__wrap(ret);\n    }\n    /**\n    * @param {string} text\n    * @returns {CBORValue}\n    */\n    static new_text(text) {\n        var ptr0 = passStringToWasm0(text, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.cborvalue_new_text(ptr0, len0);\n        return CBORValue.__wrap(ret);\n    }\n    /**\n    * @param {CBORArray} arr\n    * @returns {CBORValue}\n    */\n    static new_array(arr) {\n        _assertClass(arr, CBORArray);\n        var ret = wasm.cborvalue_new_array(arr.ptr);\n        return CBORValue.__wrap(ret);\n    }\n    /**\n    * @param {CBORObject} obj\n    * @returns {CBORValue}\n    */\n    static new_object(obj) {\n        _assertClass(obj, CBORObject);\n        var ret = wasm.cborvalue_new_object(obj.ptr);\n        return CBORValue.__wrap(ret);\n    }\n    /**\n    * @param {TaggedCBOR} tagged\n    * @returns {CBORValue}\n    */\n    static new_tagged(tagged) {\n        _assertClass(tagged, TaggedCBOR);\n        var ret = wasm.cborvalue_new_tagged(tagged.ptr);\n        return CBORValue.__wrap(ret);\n    }\n    /**\n    * @param {CBORSpecial} special\n    * @returns {CBORValue}\n    */\n    static new_special(special) {\n        _assertClass(special, CBORSpecial);\n        var ret = wasm.cborvalue_new_special(special.ptr);\n        return CBORValue.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    kind() {\n        var ret = wasm.cborvalue_kind(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {Int | undefined}\n    */\n    as_int() {\n        var ret = wasm.cborvalue_as_int(this.ptr);\n        return ret === 0 ? undefined : Int.__wrap(ret);\n    }\n    /**\n    * @returns {Uint8Array | undefined}\n    */\n    as_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.cborvalue_as_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            let v0;\n            if (r0 !== 0) {\n                v0 = getArrayU8FromWasm0(r0, r1).slice();\n                wasm.__wbindgen_free(r0, r1 * 1);\n            }\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {string | undefined}\n    */\n    as_text() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.cborvalue_as_text(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            let v0;\n            if (r0 !== 0) {\n                v0 = getStringFromWasm0(r0, r1).slice();\n                wasm.__wbindgen_free(r0, r1 * 1);\n            }\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {CBORArray | undefined}\n    */\n    as_array() {\n        var ret = wasm.cborvalue_as_array(this.ptr);\n        return ret === 0 ? undefined : CBORArray.__wrap(ret);\n    }\n    /**\n    * @returns {CBORObject | undefined}\n    */\n    as_object() {\n        var ret = wasm.cborvalue_as_object(this.ptr);\n        return ret === 0 ? undefined : CBORObject.__wrap(ret);\n    }\n    /**\n    * @returns {TaggedCBOR | undefined}\n    */\n    as_tagged() {\n        var ret = wasm.cborvalue_as_tagged(this.ptr);\n        return ret === 0 ? undefined : TaggedCBOR.__wrap(ret);\n    }\n    /**\n    * @returns {CBORSpecial | undefined}\n    */\n    as_special() {\n        var ret = wasm.cborvalue_as_special(this.ptr);\n        return ret === 0 ? undefined : CBORSpecial.__wrap(ret);\n    }\n}\n/**\n*/\nexport class COSEEncrypt {\n\n    static __wrap(ptr) {\n        const obj = Object.create(COSEEncrypt.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_coseencrypt_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.coseencrypt_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {COSEEncrypt}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.coseencrypt_from_bytes(ptr0, len0);\n        return COSEEncrypt.__wrap(ret);\n    }\n    /**\n    * @returns {Headers}\n    */\n    headers() {\n        var ret = wasm.coseencrypt0_headers(this.ptr);\n        return Headers.__wrap(ret);\n    }\n    /**\n    * @returns {Uint8Array | undefined}\n    */\n    ciphertext() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.coseencrypt0_ciphertext(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            let v0;\n            if (r0 !== 0) {\n                v0 = getArrayU8FromWasm0(r0, r1).slice();\n                wasm.__wbindgen_free(r0, r1 * 1);\n            }\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {COSERecipients}\n    */\n    recipients() {\n        var ret = wasm.coseencrypt_recipients(this.ptr);\n        return COSERecipients.__wrap(ret);\n    }\n    /**\n    * @param {Headers} headers\n    * @param {Uint8Array | undefined} ciphertext\n    * @param {COSERecipients} recipients\n    * @returns {COSEEncrypt}\n    */\n    static new(headers, ciphertext, recipients) {\n        _assertClass(headers, Headers);\n        var ptr0 = isLikeNone(ciphertext) ? 0 : passArray8ToWasm0(ciphertext, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        _assertClass(recipients, COSERecipients);\n        var ret = wasm.coseencrypt_new(headers.ptr, ptr0, len0, recipients.ptr);\n        return COSEEncrypt.__wrap(ret);\n    }\n}\n/**\n*/\nexport class COSEEncrypt0 {\n\n    static __wrap(ptr) {\n        const obj = Object.create(COSEEncrypt0.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_coseencrypt0_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.coseencrypt0_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {COSEEncrypt0}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.coseencrypt0_from_bytes(ptr0, len0);\n        return COSEEncrypt0.__wrap(ret);\n    }\n    /**\n    * @returns {Headers}\n    */\n    headers() {\n        var ret = wasm.coseencrypt0_headers(this.ptr);\n        return Headers.__wrap(ret);\n    }\n    /**\n    * @returns {Uint8Array | undefined}\n    */\n    ciphertext() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.coseencrypt0_ciphertext(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            let v0;\n            if (r0 !== 0) {\n                v0 = getArrayU8FromWasm0(r0, r1).slice();\n                wasm.__wbindgen_free(r0, r1 * 1);\n            }\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Headers} headers\n    * @param {Uint8Array | undefined} ciphertext\n    * @returns {COSEEncrypt0}\n    */\n    static new(headers, ciphertext) {\n        _assertClass(headers, Headers);\n        var ptr0 = isLikeNone(ciphertext) ? 0 : passArray8ToWasm0(ciphertext, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.coseencrypt0_new(headers.ptr, ptr0, len0);\n        return COSEEncrypt0.__wrap(ret);\n    }\n}\n/**\n*/\nexport class COSEKey {\n\n    static __wrap(ptr) {\n        const obj = Object.create(COSEKey.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_cosekey_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.cosekey_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {COSEKey}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.cosekey_from_bytes(ptr0, len0);\n        return COSEKey.__wrap(ret);\n    }\n    /**\n    * @param {Label} key_type\n    */\n    set_key_type(key_type) {\n        _assertClass(key_type, Label);\n        wasm.cosekey_set_key_type(this.ptr, key_type.ptr);\n    }\n    /**\n    * @returns {Label}\n    */\n    key_type() {\n        var ret = wasm.cosekey_key_type(this.ptr);\n        return Label.__wrap(ret);\n    }\n    /**\n    * @param {Uint8Array} key_id\n    */\n    set_key_id(key_id) {\n        var ptr0 = passArray8ToWasm0(key_id, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        wasm.cosekey_set_key_id(this.ptr, ptr0, len0);\n    }\n    /**\n    * @returns {Uint8Array | undefined}\n    */\n    key_id() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.cosekey_key_id(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            let v0;\n            if (r0 !== 0) {\n                v0 = getArrayU8FromWasm0(r0, r1).slice();\n                wasm.__wbindgen_free(r0, r1 * 1);\n            }\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Label} algorithm_id\n    */\n    set_algorithm_id(algorithm_id) {\n        _assertClass(algorithm_id, Label);\n        wasm.cosekey_set_algorithm_id(this.ptr, algorithm_id.ptr);\n    }\n    /**\n    * @returns {Label | undefined}\n    */\n    algorithm_id() {\n        var ret = wasm.cosekey_algorithm_id(this.ptr);\n        return ret === 0 ? undefined : Label.__wrap(ret);\n    }\n    /**\n    * @param {Labels} key_ops\n    */\n    set_key_ops(key_ops) {\n        _assertClass(key_ops, Labels);\n        wasm.cosekey_set_key_ops(this.ptr, key_ops.ptr);\n    }\n    /**\n    * @returns {Labels | undefined}\n    */\n    key_ops() {\n        var ret = wasm.cosekey_key_ops(this.ptr);\n        return ret === 0 ? undefined : Labels.__wrap(ret);\n    }\n    /**\n    * @param {Uint8Array} base_init_vector\n    */\n    set_base_init_vector(base_init_vector) {\n        var ptr0 = passArray8ToWasm0(base_init_vector, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        wasm.cosekey_set_base_init_vector(this.ptr, ptr0, len0);\n    }\n    /**\n    * @returns {Uint8Array | undefined}\n    */\n    base_init_vector() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.cosekey_base_init_vector(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            let v0;\n            if (r0 !== 0) {\n                v0 = getArrayU8FromWasm0(r0, r1).slice();\n                wasm.__wbindgen_free(r0, r1 * 1);\n            }\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Label} label\n    * @returns {CBORValue | undefined}\n    */\n    header(label) {\n        _assertClass(label, Label);\n        var ret = wasm.cosekey_header(this.ptr, label.ptr);\n        return ret === 0 ? undefined : CBORValue.__wrap(ret);\n    }\n    /**\n    * @param {Label} label\n    * @param {CBORValue} value\n    */\n    set_header(label, value) {\n        _assertClass(label, Label);\n        _assertClass(value, CBORValue);\n        wasm.cosekey_set_header(this.ptr, label.ptr, value.ptr);\n    }\n    /**\n    * @param {Label} key_type\n    * @returns {COSEKey}\n    */\n    static new(key_type) {\n        _assertClass(key_type, Label);\n        var ret = wasm.cosekey_new(key_type.ptr);\n        return COSEKey.__wrap(ret);\n    }\n}\n/**\n*/\nexport class COSERecipient {\n\n    static __wrap(ptr) {\n        const obj = Object.create(COSERecipient.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_coserecipient_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.coserecipient_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {COSERecipient}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.coserecipient_from_bytes(ptr0, len0);\n        return COSERecipient.__wrap(ret);\n    }\n    /**\n    * @returns {Headers}\n    */\n    headers() {\n        var ret = wasm.coseencrypt0_headers(this.ptr);\n        return Headers.__wrap(ret);\n    }\n    /**\n    * @returns {Uint8Array | undefined}\n    */\n    ciphertext() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.coseencrypt0_ciphertext(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            let v0;\n            if (r0 !== 0) {\n                v0 = getArrayU8FromWasm0(r0, r1).slice();\n                wasm.__wbindgen_free(r0, r1 * 1);\n            }\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Headers} headers\n    * @param {Uint8Array | undefined} ciphertext\n    * @returns {COSERecipient}\n    */\n    static new(headers, ciphertext) {\n        _assertClass(headers, Headers);\n        var ptr0 = isLikeNone(ciphertext) ? 0 : passArray8ToWasm0(ciphertext, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.coseencrypt0_new(headers.ptr, ptr0, len0);\n        return COSERecipient.__wrap(ret);\n    }\n}\n/**\n*/\nexport class COSERecipients {\n\n    static __wrap(ptr) {\n        const obj = Object.create(COSERecipients.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_coserecipients_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.coserecipients_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {COSERecipients}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.coserecipients_from_bytes(ptr0, len0);\n        return COSERecipients.__wrap(ret);\n    }\n    /**\n    * @returns {COSERecipients}\n    */\n    static new() {\n        var ret = wasm.coserecipients_new();\n        return COSERecipients.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.coserecipients_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} index\n    * @returns {COSERecipient}\n    */\n    get(index) {\n        var ret = wasm.coserecipients_get(this.ptr, index);\n        return COSERecipient.__wrap(ret);\n    }\n    /**\n    * @param {COSERecipient} elem\n    */\n    add(elem) {\n        _assertClass(elem, COSERecipient);\n        wasm.coserecipients_add(this.ptr, elem.ptr);\n    }\n}\n/**\n*/\nexport class COSESign {\n\n    static __wrap(ptr) {\n        const obj = Object.create(COSESign.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_cosesign_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.cosesign_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {COSESign}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.cosesign_from_bytes(ptr0, len0);\n        return COSESign.__wrap(ret);\n    }\n    /**\n    * @returns {Headers}\n    */\n    headers() {\n        var ret = wasm.coseencrypt0_headers(this.ptr);\n        return Headers.__wrap(ret);\n    }\n    /**\n    * @returns {Uint8Array | undefined}\n    */\n    payload() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.coseencrypt0_ciphertext(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            let v0;\n            if (r0 !== 0) {\n                v0 = getArrayU8FromWasm0(r0, r1).slice();\n                wasm.__wbindgen_free(r0, r1 * 1);\n            }\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {COSESignatures}\n    */\n    signatures() {\n        var ret = wasm.cosesign_signatures(this.ptr);\n        return COSESignatures.__wrap(ret);\n    }\n    /**\n    * @param {Headers} headers\n    * @param {Uint8Array | undefined} payload\n    * @param {COSESignatures} signatures\n    * @returns {COSESign}\n    */\n    static new(headers, payload, signatures) {\n        _assertClass(headers, Headers);\n        var ptr0 = isLikeNone(payload) ? 0 : passArray8ToWasm0(payload, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        _assertClass(signatures, COSESignatures);\n        var ret = wasm.cosesign_new(headers.ptr, ptr0, len0, signatures.ptr);\n        return COSESign.__wrap(ret);\n    }\n}\n/**\n*/\nexport class COSESign1 {\n\n    static __wrap(ptr) {\n        const obj = Object.create(COSESign1.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_cosesign1_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.cosesign1_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {COSESign1}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.cosesign1_from_bytes(ptr0, len0);\n        return COSESign1.__wrap(ret);\n    }\n    /**\n    * @returns {Headers}\n    */\n    headers() {\n        var ret = wasm.coseencrypt0_headers(this.ptr);\n        return Headers.__wrap(ret);\n    }\n    /**\n    * @returns {Uint8Array | undefined}\n    */\n    payload() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.coseencrypt0_ciphertext(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            let v0;\n            if (r0 !== 0) {\n                v0 = getArrayU8FromWasm0(r0, r1).slice();\n                wasm.__wbindgen_free(r0, r1 * 1);\n            }\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    signature() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.cosesign1_signature(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * For verifying, we will want to reverse-construct this SigStructure to check the signature against\n    * # Arguments\n    * * `external_aad` - External application data - see RFC 8152 section 4.3. Set to None if not using this.\n    * @param {Uint8Array | undefined} external_aad\n    * @param {Uint8Array | undefined} external_payload\n    * @returns {SigStructure}\n    */\n    signed_data(external_aad, external_payload) {\n        var ptr0 = isLikeNone(external_aad) ? 0 : passArray8ToWasm0(external_aad, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ptr1 = isLikeNone(external_payload) ? 0 : passArray8ToWasm0(external_payload, wasm.__wbindgen_malloc);\n        var len1 = WASM_VECTOR_LEN;\n        var ret = wasm.cosesign1_signed_data(this.ptr, ptr0, len0, ptr1, len1);\n        return SigStructure.__wrap(ret);\n    }\n    /**\n    * @param {Headers} headers\n    * @param {Uint8Array | undefined} payload\n    * @param {Uint8Array} signature\n    * @returns {COSESign1}\n    */\n    static new(headers, payload, signature) {\n        _assertClass(headers, Headers);\n        var ptr0 = isLikeNone(payload) ? 0 : passArray8ToWasm0(payload, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ptr1 = passArray8ToWasm0(signature, wasm.__wbindgen_malloc);\n        var len1 = WASM_VECTOR_LEN;\n        var ret = wasm.cosesign1_new(headers.ptr, ptr0, len0, ptr1, len1);\n        return COSESign1.__wrap(ret);\n    }\n}\n/**\n*/\nexport class COSESign1Builder {\n\n    static __wrap(ptr) {\n        const obj = Object.create(COSESign1Builder.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_cosesign1builder_free(ptr);\n    }\n    /**\n    * @param {Headers} headers\n    * @param {Uint8Array} payload\n    * @param {boolean} is_payload_external\n    * @returns {COSESign1Builder}\n    */\n    static new(headers, payload, is_payload_external) {\n        _assertClass(headers, Headers);\n        var ptr0 = passArray8ToWasm0(payload, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.cosesign1builder_new(headers.ptr, ptr0, len0, is_payload_external);\n        return COSESign1Builder.__wrap(ret);\n    }\n    /**\n    */\n    hash_payload() {\n        wasm.cosesign1builder_hash_payload(this.ptr);\n    }\n    /**\n    * @param {Uint8Array} external_aad\n    */\n    set_external_aad(external_aad) {\n        var ptr0 = passArray8ToWasm0(external_aad, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        wasm.cosesign1builder_set_external_aad(this.ptr, ptr0, len0);\n    }\n    /**\n    * @returns {SigStructure}\n    */\n    make_data_to_sign() {\n        var ret = wasm.cosesign1builder_make_data_to_sign(this.ptr);\n        return SigStructure.__wrap(ret);\n    }\n    /**\n    * @param {Uint8Array} signed_sig_structure\n    * @returns {COSESign1}\n    */\n    build(signed_sig_structure) {\n        var ptr0 = passArray8ToWasm0(signed_sig_structure, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.cosesign1builder_build(this.ptr, ptr0, len0);\n        return COSESign1.__wrap(ret);\n    }\n}\n/**\n*/\nexport class COSESignBuilder {\n\n    static __wrap(ptr) {\n        const obj = Object.create(COSESignBuilder.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_cosesignbuilder_free(ptr);\n    }\n    /**\n    * @param {Headers} headers\n    * @param {Uint8Array} payload\n    * @param {boolean} is_payload_external\n    * @returns {COSESignBuilder}\n    */\n    static new(headers, payload, is_payload_external) {\n        _assertClass(headers, Headers);\n        var ptr0 = passArray8ToWasm0(payload, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.cosesignbuilder_new(headers.ptr, ptr0, len0, is_payload_external);\n        return COSESignBuilder.__wrap(ret);\n    }\n    /**\n    */\n    hash_payload() {\n        wasm.cosesign1builder_hash_payload(this.ptr);\n    }\n    /**\n    * @param {Uint8Array} external_aad\n    */\n    set_external_aad(external_aad) {\n        var ptr0 = passArray8ToWasm0(external_aad, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        wasm.cosesign1builder_set_external_aad(this.ptr, ptr0, len0);\n    }\n    /**\n    * @returns {SigStructure}\n    */\n    make_data_to_sign() {\n        var ret = wasm.cosesignbuilder_make_data_to_sign(this.ptr);\n        return SigStructure.__wrap(ret);\n    }\n    /**\n    * @param {COSESignatures} signed_sig_structure\n    * @returns {COSESign}\n    */\n    build(signed_sig_structure) {\n        _assertClass(signed_sig_structure, COSESignatures);\n        var ret = wasm.cosesignbuilder_build(this.ptr, signed_sig_structure.ptr);\n        return COSESign.__wrap(ret);\n    }\n}\n/**\n*/\nexport class COSESignature {\n\n    static __wrap(ptr) {\n        const obj = Object.create(COSESignature.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_cosesignature_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.cosesignature_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {COSESignature}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.cosesignature_from_bytes(ptr0, len0);\n        return COSESignature.__wrap(ret);\n    }\n    /**\n    * @returns {Headers}\n    */\n    headers() {\n        var ret = wasm.coseencrypt0_headers(this.ptr);\n        return Headers.__wrap(ret);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    signature() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.cosesignature_signature(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Headers} headers\n    * @param {Uint8Array} signature\n    * @returns {COSESignature}\n    */\n    static new(headers, signature) {\n        _assertClass(headers, Headers);\n        var ptr0 = passArray8ToWasm0(signature, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.cosesignature_new(headers.ptr, ptr0, len0);\n        return COSESignature.__wrap(ret);\n    }\n}\n/**\n*/\nexport class COSESignatures {\n\n    static __wrap(ptr) {\n        const obj = Object.create(COSESignatures.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_cosesignatures_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.cosesignatures_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {COSESignatures}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.cosesignatures_from_bytes(ptr0, len0);\n        return COSESignatures.__wrap(ret);\n    }\n    /**\n    * @returns {COSESignatures}\n    */\n    static new() {\n        var ret = wasm.coserecipients_new();\n        return COSESignatures.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.coserecipients_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} index\n    * @returns {COSESignature}\n    */\n    get(index) {\n        var ret = wasm.cosesignatures_get(this.ptr, index);\n        return COSESignature.__wrap(ret);\n    }\n    /**\n    * @param {COSESignature} elem\n    */\n    add(elem) {\n        _assertClass(elem, COSESignature);\n        wasm.cosesignatures_add(this.ptr, elem.ptr);\n    }\n}\n/**\n*/\nexport class CounterSignature {\n\n    static __wrap(ptr) {\n        const obj = Object.create(CounterSignature.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_countersignature_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.countersignature_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {CounterSignature}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.countersignature_from_bytes(ptr0, len0);\n        return CounterSignature.__wrap(ret);\n    }\n    /**\n    * @param {COSESignature} cose_signature\n    * @returns {CounterSignature}\n    */\n    static new_single(cose_signature) {\n        _assertClass(cose_signature, COSESignature);\n        var ret = wasm.countersignature_new_single(cose_signature.ptr);\n        return CounterSignature.__wrap(ret);\n    }\n    /**\n    * @param {COSESignatures} cose_signatures\n    * @returns {CounterSignature}\n    */\n    static new_multi(cose_signatures) {\n        _assertClass(cose_signatures, COSESignatures);\n        var ret = wasm.countersignature_new_multi(cose_signatures.ptr);\n        return CounterSignature.__wrap(ret);\n    }\n    /**\n    * @returns {COSESignatures}\n    */\n    signatures() {\n        var ret = wasm.countersignature_signatures(this.ptr);\n        return COSESignatures.__wrap(ret);\n    }\n}\n/**\n*/\nexport class EdDSA25519Key {\n\n    static __wrap(ptr) {\n        const obj = Object.create(EdDSA25519Key.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_eddsa25519key_free(ptr);\n    }\n    /**\n    * @param {Uint8Array} pubkey_bytes\n    * @returns {EdDSA25519Key}\n    */\n    static new(pubkey_bytes) {\n        var ptr0 = passArray8ToWasm0(pubkey_bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.eddsa25519key_new(ptr0, len0);\n        return EdDSA25519Key.__wrap(ret);\n    }\n    /**\n    * @param {Uint8Array} private_key_bytes\n    */\n    set_private_key(private_key_bytes) {\n        var ptr0 = passArray8ToWasm0(private_key_bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        wasm.eddsa25519key_set_private_key(this.ptr, ptr0, len0);\n    }\n    /**\n    */\n    is_for_signing() {\n        wasm.eddsa25519key_is_for_signing(this.ptr);\n    }\n    /**\n    */\n    is_for_verifying() {\n        wasm.eddsa25519key_is_for_verifying(this.ptr);\n    }\n    /**\n    * @returns {COSEKey}\n    */\n    build() {\n        var ret = wasm.eddsa25519key_build(this.ptr);\n        return COSEKey.__wrap(ret);\n    }\n}\n/**\n*/\nexport class HeaderMap {\n\n    static __wrap(ptr) {\n        const obj = Object.create(HeaderMap.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_headermap_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.headermap_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {HeaderMap}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.headermap_from_bytes(ptr0, len0);\n        return HeaderMap.__wrap(ret);\n    }\n    /**\n    * @param {Label} algorithm_id\n    */\n    set_algorithm_id(algorithm_id) {\n        _assertClass(algorithm_id, Label);\n        wasm.headermap_set_algorithm_id(this.ptr, algorithm_id.ptr);\n    }\n    /**\n    * @returns {Label | undefined}\n    */\n    algorithm_id() {\n        var ret = wasm.headermap_algorithm_id(this.ptr);\n        return ret === 0 ? undefined : Label.__wrap(ret);\n    }\n    /**\n    * @param {Labels} criticality\n    */\n    set_criticality(criticality) {\n        _assertClass(criticality, Labels);\n        wasm.headermap_set_criticality(this.ptr, criticality.ptr);\n    }\n    /**\n    * @returns {Labels | undefined}\n    */\n    criticality() {\n        var ret = wasm.headermap_criticality(this.ptr);\n        return ret === 0 ? undefined : Labels.__wrap(ret);\n    }\n    /**\n    * @param {Label} content_type\n    */\n    set_content_type(content_type) {\n        _assertClass(content_type, Label);\n        wasm.cosekey_set_algorithm_id(this.ptr, content_type.ptr);\n    }\n    /**\n    * @returns {Label | undefined}\n    */\n    content_type() {\n        var ret = wasm.cosekey_algorithm_id(this.ptr);\n        return ret === 0 ? undefined : Label.__wrap(ret);\n    }\n    /**\n    * @param {Uint8Array} key_id\n    */\n    set_key_id(key_id) {\n        var ptr0 = passArray8ToWasm0(key_id, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        wasm.headermap_set_key_id(this.ptr, ptr0, len0);\n    }\n    /**\n    * @returns {Uint8Array | undefined}\n    */\n    key_id() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.headermap_key_id(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            let v0;\n            if (r0 !== 0) {\n                v0 = getArrayU8FromWasm0(r0, r1).slice();\n                wasm.__wbindgen_free(r0, r1 * 1);\n            }\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} init_vector\n    */\n    set_init_vector(init_vector) {\n        var ptr0 = passArray8ToWasm0(init_vector, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        wasm.cosekey_set_base_init_vector(this.ptr, ptr0, len0);\n    }\n    /**\n    * @returns {Uint8Array | undefined}\n    */\n    init_vector() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.cosekey_base_init_vector(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            let v0;\n            if (r0 !== 0) {\n                v0 = getArrayU8FromWasm0(r0, r1).slice();\n                wasm.__wbindgen_free(r0, r1 * 1);\n            }\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} partial_init_vector\n    */\n    set_partial_init_vector(partial_init_vector) {\n        var ptr0 = passArray8ToWasm0(partial_init_vector, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        wasm.headermap_set_partial_init_vector(this.ptr, ptr0, len0);\n    }\n    /**\n    * @returns {Uint8Array | undefined}\n    */\n    partial_init_vector() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.headermap_partial_init_vector(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            let v0;\n            if (r0 !== 0) {\n                v0 = getArrayU8FromWasm0(r0, r1).slice();\n                wasm.__wbindgen_free(r0, r1 * 1);\n            }\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {CounterSignature} counter_signature\n    */\n    set_counter_signature(counter_signature) {\n        _assertClass(counter_signature, CounterSignature);\n        wasm.headermap_set_counter_signature(this.ptr, counter_signature.ptr);\n    }\n    /**\n    * @returns {CounterSignature | undefined}\n    */\n    counter_signature() {\n        var ret = wasm.headermap_counter_signature(this.ptr);\n        return ret === 0 ? undefined : CounterSignature.__wrap(ret);\n    }\n    /**\n    * @param {Label} label\n    * @returns {CBORValue | undefined}\n    */\n    header(label) {\n        _assertClass(label, Label);\n        var ret = wasm.headermap_header(this.ptr, label.ptr);\n        return ret === 0 ? undefined : CBORValue.__wrap(ret);\n    }\n    /**\n    * @param {Label} label\n    * @param {CBORValue} value\n    */\n    set_header(label, value) {\n        _assertClass(label, Label);\n        _assertClass(value, CBORValue);\n        wasm.headermap_set_header(this.ptr, label.ptr, value.ptr);\n    }\n    /**\n    * @returns {Labels}\n    */\n    keys() {\n        var ret = wasm.headermap_keys(this.ptr);\n        return Labels.__wrap(ret);\n    }\n    /**\n    * @returns {HeaderMap}\n    */\n    static new() {\n        var ret = wasm.headermap_new();\n        return HeaderMap.__wrap(ret);\n    }\n}\n/**\n*/\nexport class Headers {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Headers.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_headers_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.headers_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {Headers}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.headers_from_bytes(ptr0, len0);\n        return Headers.__wrap(ret);\n    }\n    /**\n    * @returns {ProtectedHeaderMap}\n    */\n    protected() {\n        var ret = wasm.headers_protected(this.ptr);\n        return ProtectedHeaderMap.__wrap(ret);\n    }\n    /**\n    * @returns {HeaderMap}\n    */\n    unprotected() {\n        var ret = wasm.headers_unprotected(this.ptr);\n        return HeaderMap.__wrap(ret);\n    }\n    /**\n    * @param {ProtectedHeaderMap} protected_\n    * @param {HeaderMap} unprotected_\n    * @returns {Headers}\n    */\n    static new(protected_, unprotected_) {\n        _assertClass(protected_, ProtectedHeaderMap);\n        _assertClass(unprotected_, HeaderMap);\n        var ret = wasm.headers_new(protected_.ptr, unprotected_.ptr);\n        return Headers.__wrap(ret);\n    }\n}\n/**\n*/\nexport class Int {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Int.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_int_free(ptr);\n    }\n    /**\n    * @param {BigNum} x\n    * @returns {Int}\n    */\n    static new(x) {\n        _assertClass(x, BigNum);\n        var ptr0 = x.ptr;\n        x.ptr = 0;\n        var ret = wasm.int_new(ptr0);\n        return Int.__wrap(ret);\n    }\n    /**\n    * @param {BigNum} x\n    * @returns {Int}\n    */\n    static new_negative(x) {\n        _assertClass(x, BigNum);\n        var ptr0 = x.ptr;\n        x.ptr = 0;\n        var ret = wasm.int_new_negative(ptr0);\n        return Int.__wrap(ret);\n    }\n    /**\n    * @param {number} x\n    * @returns {Int}\n    */\n    static new_i32(x) {\n        var ret = wasm.int_new_i32(x);\n        return Int.__wrap(ret);\n    }\n    /**\n    * @returns {boolean}\n    */\n    is_positive() {\n        var ret = wasm.int_is_positive(this.ptr);\n        return ret !== 0;\n    }\n    /**\n    * @returns {BigNum | undefined}\n    */\n    as_positive() {\n        var ret = wasm.int_as_positive(this.ptr);\n        return ret === 0 ? undefined : BigNum.__wrap(ret);\n    }\n    /**\n    * @returns {BigNum | undefined}\n    */\n    as_negative() {\n        var ret = wasm.int_as_negative(this.ptr);\n        return ret === 0 ? undefined : BigNum.__wrap(ret);\n    }\n    /**\n    * @returns {number | undefined}\n    */\n    as_i32() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.int_as_i32(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n*/\nexport class Label {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Label.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_label_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.label_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {Label}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.label_from_bytes(ptr0, len0);\n        return Label.__wrap(ret);\n    }\n    /**\n    * @param {Int} int\n    * @returns {Label}\n    */\n    static new_int(int) {\n        _assertClass(int, Int);\n        var ret = wasm.label_new_int(int.ptr);\n        return Label.__wrap(ret);\n    }\n    /**\n    * @param {string} text\n    * @returns {Label}\n    */\n    static new_text(text) {\n        var ptr0 = passStringToWasm0(text, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.label_new_text(ptr0, len0);\n        return Label.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    kind() {\n        var ret = wasm.label_kind(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {Int | undefined}\n    */\n    as_int() {\n        var ret = wasm.label_as_int(this.ptr);\n        return ret === 0 ? undefined : Int.__wrap(ret);\n    }\n    /**\n    * @returns {string | undefined}\n    */\n    as_text() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.label_as_text(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            let v0;\n            if (r0 !== 0) {\n                v0 = getStringFromWasm0(r0, r1).slice();\n                wasm.__wbindgen_free(r0, r1 * 1);\n            }\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {number} id\n    * @returns {Label}\n    */\n    static from_algorithm_id(id) {\n        var ret = wasm.label_from_algorithm_id(id);\n        return Label.__wrap(ret);\n    }\n    /**\n    * @param {number} key_type\n    * @returns {Label}\n    */\n    static from_key_type(key_type) {\n        var ret = wasm.label_from_key_type(key_type);\n        return Label.__wrap(ret);\n    }\n    /**\n    * @param {number} ec_key\n    * @returns {Label}\n    */\n    static from_ec_key(ec_key) {\n        var ret = wasm.label_from_ec_key(ec_key);\n        return Label.__wrap(ret);\n    }\n    /**\n    * @param {number} curve_type\n    * @returns {Label}\n    */\n    static from_curve_type(curve_type) {\n        var ret = wasm.label_from_curve_type(curve_type);\n        return Label.__wrap(ret);\n    }\n    /**\n    * @param {number} key_op\n    * @returns {Label}\n    */\n    static from_key_operation(key_op) {\n        var ret = wasm.label_from_key_operation(key_op);\n        return Label.__wrap(ret);\n    }\n}\n/**\n*/\nexport class Labels {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Labels.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_labels_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.labels_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {Labels}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.labels_from_bytes(ptr0, len0);\n        return Labels.__wrap(ret);\n    }\n    /**\n    * @returns {Labels}\n    */\n    static new() {\n        var ret = wasm.coserecipients_new();\n        return Labels.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        var ret = wasm.coserecipients_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} index\n    * @returns {Label}\n    */\n    get(index) {\n        var ret = wasm.labels_get(this.ptr, index);\n        return Label.__wrap(ret);\n    }\n    /**\n    * @param {Label} elem\n    */\n    add(elem) {\n        _assertClass(elem, Label);\n        wasm.labels_add(this.ptr, elem.ptr);\n    }\n}\n/**\n*/\nexport class PasswordEncryption {\n\n    static __wrap(ptr) {\n        const obj = Object.create(PasswordEncryption.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_passwordencryption_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.passwordencryption_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {PasswordEncryption}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.passwordencryption_from_bytes(ptr0, len0);\n        return PasswordEncryption.__wrap(ret);\n    }\n    /**\n    * @param {COSEEncrypt0} data\n    * @returns {PasswordEncryption}\n    */\n    static new(data) {\n        _assertClass(data, COSEEncrypt0);\n        var ret = wasm.passwordencryption_new(data.ptr);\n        return PasswordEncryption.__wrap(ret);\n    }\n}\n/**\n*/\nexport class ProtectedHeaderMap {\n\n    static __wrap(ptr) {\n        const obj = Object.create(ProtectedHeaderMap.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_protectedheadermap_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.protectedheadermap_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {ProtectedHeaderMap}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.protectedheadermap_from_bytes(ptr0, len0);\n        return ProtectedHeaderMap.__wrap(ret);\n    }\n    /**\n    * @returns {ProtectedHeaderMap}\n    */\n    static new_empty() {\n        var ret = wasm.protectedheadermap_new_empty();\n        return ProtectedHeaderMap.__wrap(ret);\n    }\n    /**\n    * @param {HeaderMap} header_map\n    * @returns {ProtectedHeaderMap}\n    */\n    static new(header_map) {\n        _assertClass(header_map, HeaderMap);\n        var ret = wasm.protectedheadermap_new(header_map.ptr);\n        return ProtectedHeaderMap.__wrap(ret);\n    }\n    /**\n    * @returns {HeaderMap}\n    */\n    deserialized_headers() {\n        var ret = wasm.protectedheadermap_deserialized_headers(this.ptr);\n        return HeaderMap.__wrap(ret);\n    }\n}\n/**\n*/\nexport class PubKeyEncryption {\n\n    static __wrap(ptr) {\n        const obj = Object.create(PubKeyEncryption.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_pubkeyencryption_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.pubkeyencryption_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {PubKeyEncryption}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.pubkeyencryption_from_bytes(ptr0, len0);\n        return PubKeyEncryption.__wrap(ret);\n    }\n    /**\n    * @param {COSEEncrypt} data\n    * @returns {PubKeyEncryption}\n    */\n    static new(data) {\n        _assertClass(data, COSEEncrypt);\n        var ret = wasm.pubkeyencryption_new(data.ptr);\n        return PubKeyEncryption.__wrap(ret);\n    }\n}\n/**\n*/\nexport class SigStructure {\n\n    static __wrap(ptr) {\n        const obj = Object.create(SigStructure.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_sigstructure_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.sigstructure_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {SigStructure}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.sigstructure_from_bytes(ptr0, len0);\n        return SigStructure.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    context() {\n        var ret = wasm.sigstructure_context(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {ProtectedHeaderMap}\n    */\n    body_protected() {\n        var ret = wasm.sigstructure_body_protected(this.ptr);\n        return ProtectedHeaderMap.__wrap(ret);\n    }\n    /**\n    * @returns {ProtectedHeaderMap | undefined}\n    */\n    sign_protected() {\n        var ret = wasm.sigstructure_sign_protected(this.ptr);\n        return ret === 0 ? undefined : ProtectedHeaderMap.__wrap(ret);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    external_aad() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.sigstructure_external_aad(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    payload() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.sigstructure_payload(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {ProtectedHeaderMap} sign_protected\n    */\n    set_sign_protected(sign_protected) {\n        _assertClass(sign_protected, ProtectedHeaderMap);\n        wasm.sigstructure_set_sign_protected(this.ptr, sign_protected.ptr);\n    }\n    /**\n    * @param {number} context\n    * @param {ProtectedHeaderMap} body_protected\n    * @param {Uint8Array} external_aad\n    * @param {Uint8Array} payload\n    * @returns {SigStructure}\n    */\n    static new(context, body_protected, external_aad, payload) {\n        _assertClass(body_protected, ProtectedHeaderMap);\n        var ptr0 = passArray8ToWasm0(external_aad, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ptr1 = passArray8ToWasm0(payload, wasm.__wbindgen_malloc);\n        var len1 = WASM_VECTOR_LEN;\n        var ret = wasm.sigstructure_new(context, body_protected.ptr, ptr0, len0, ptr1, len1);\n        return SigStructure.__wrap(ret);\n    }\n}\n/**\n*/\nexport class SignedMessage {\n\n    static __wrap(ptr) {\n        const obj = Object.create(SignedMessage.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_signedmessage_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.signedmessage_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {SignedMessage}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.signedmessage_from_bytes(ptr0, len0);\n        return SignedMessage.__wrap(ret);\n    }\n    /**\n    * @param {COSESign} cose_sign\n    * @returns {SignedMessage}\n    */\n    static new_cose_sign(cose_sign) {\n        _assertClass(cose_sign, COSESign);\n        var ret = wasm.signedmessage_new_cose_sign(cose_sign.ptr);\n        return SignedMessage.__wrap(ret);\n    }\n    /**\n    * @param {COSESign1} cose_sign1\n    * @returns {SignedMessage}\n    */\n    static new_cose_sign1(cose_sign1) {\n        _assertClass(cose_sign1, COSESign1);\n        var ret = wasm.signedmessage_new_cose_sign1(cose_sign1.ptr);\n        return SignedMessage.__wrap(ret);\n    }\n    /**\n    * @param {string} s\n    * @returns {SignedMessage}\n    */\n    static from_user_facing_encoding(s) {\n        var ptr0 = passStringToWasm0(s, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.signedmessage_from_user_facing_encoding(ptr0, len0);\n        return SignedMessage.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_user_facing_encoding() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.signedmessage_to_user_facing_encoding(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(r0, r1);\n        }\n    }\n    /**\n    * @returns {number}\n    */\n    kind() {\n        var ret = wasm.signedmessage_kind(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {COSESign | undefined}\n    */\n    as_cose_sign() {\n        var ret = wasm.signedmessage_as_cose_sign(this.ptr);\n        return ret === 0 ? undefined : COSESign.__wrap(ret);\n    }\n    /**\n    * @returns {COSESign1 | undefined}\n    */\n    as_cose_sign1() {\n        var ret = wasm.signedmessage_as_cose_sign1(this.ptr);\n        return ret === 0 ? undefined : COSESign1.__wrap(ret);\n    }\n}\n/**\n*/\nexport class TaggedCBOR {\n\n    static __wrap(ptr) {\n        const obj = Object.create(TaggedCBOR.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_taggedcbor_free(ptr);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.taggedcbor_to_bytes(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v0 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {TaggedCBOR}\n    */\n    static from_bytes(bytes) {\n        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = wasm.taggedcbor_from_bytes(ptr0, len0);\n        return TaggedCBOR.__wrap(ret);\n    }\n    /**\n    * @returns {BigNum}\n    */\n    tag() {\n        var ret = wasm.taggedcbor_tag(this.ptr);\n        return BigNum.__wrap(ret);\n    }\n    /**\n    * @returns {CBORValue}\n    */\n    value() {\n        var ret = wasm.taggedcbor_value(this.ptr);\n        return CBORValue.__wrap(ret);\n    }\n    /**\n    * @param {BigNum} tag\n    * @param {CBORValue} value\n    * @returns {TaggedCBOR}\n    */\n    static new(tag, value) {\n        _assertClass(tag, BigNum);\n        var ptr0 = tag.ptr;\n        tag.ptr = 0;\n        _assertClass(value, CBORValue);\n        var ret = wasm.taggedcbor_new(ptr0, value.ptr);\n        return TaggedCBOR.__wrap(ret);\n    }\n}\n\nexport function __wbindgen_object_drop_ref(arg0) {\n    takeObject(arg0);\n};\n\nexport function __wbindgen_string_new(arg0, arg1) {\n    var ret = getStringFromWasm0(arg0, arg1);\n    return addHeapObject(ret);\n};\n\nexport function __wbindgen_debug_string(arg0, arg1) {\n    var ret = debugString(getObject(arg1));\n    var ptr0 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n    var len0 = WASM_VECTOR_LEN;\n    getInt32Memory0()[arg0 / 4 + 1] = len0;\n    getInt32Memory0()[arg0 / 4 + 0] = ptr0;\n};\n\nexport function __wbindgen_throw(arg0, arg1) {\n    throw new Error(getStringFromWasm0(arg0, arg1));\n};\n\nexport function __wbindgen_rethrow(arg0) {\n    throw takeObject(arg0);\n};\n\n","var createTypedArrayConstructor = require('../internals/typed-array-constructor');\n\n// `Float64Array` constructor\n// https://tc39.es/ecma262/#sec-typedarray-objects\ncreateTypedArrayConstructor('Float64', function (init) {\n  return function Float64Array(data, byteOffset, length) {\n    return init(this, data, byteOffset, length);\n  };\n});\n","export default function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}","module.exports = function(originalModule) {\n\tif (!originalModule.webpackPolyfill) {\n\t\tvar module = Object.create(originalModule);\n\t\t// module.parent = undefined by default\n\t\tif (!module.children) module.children = [];\n\t\tObject.defineProperty(module, \"loaded\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.l;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"id\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.i;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"exports\", {\n\t\t\tenumerable: true\n\t\t});\n\t\tmodule.webpackPolyfill = 1;\n\t}\n\treturn module;\n};\n"],"sourceRoot":""}